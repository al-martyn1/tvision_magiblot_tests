##  CMake++ Compiled module

## cmakepp 
##
## An enhancement suite for CMake
## 
##
## This file is the entry point for cmakepp. If you want to use the functions 
## just include this file.
##
## it can also be used as a module file with cmake's find_package() 
cmake_minimum_required(VERSION 3.1)
get_property(is_included GLOBAL PROPERTY cmakepp_include_guard)
if (is_included)
    return()
endif ()
set_property(GLOBAL PROPERTY cmakepp_include_guard true)
if (POLICY CMP0053)
    ## for template compile
    cmake_policy(SET CMP0053 NEW)
endif ()
if (POLICY CMP0054)
    cmake_policy(SET CMP0054 NEW)
endif ()
# installation dir of cmakepp
set(cmakepp_base_dir "${CMAKE_CURRENT_LIST_DIR}")
# include functions needed for initializing cmakepp
include(CMakeParseArguments)
# get temp dir which is needed by a couple of functions in cmakepp
# first uses env variable TMP if it does not exists TMPDIR is used
# if both do not exists current_list_dir/tmp is used
if (UNIX)
    set(cmakepp_tmp_dir $ENV{TMPDIR} /tmp)
else ()
    set(cmakepp_tmp_dir $ENV{TMP} ${CMAKE_CURRENT_LIST_DIR}/tmp)
endif ()
list(GET cmakepp_tmp_dir 0 cmakepp_tmp_dir)
file(TO_CMAKE_PATH "${cmakepp_tmp_dir}" cmakepp_tmp_dir)
# get cache dir (Used for storing executables/tools)
if (UNIX)
    set(cmakepp_cache_dir $ENV{XDG_CACHE_HOME} $ENV{HOME}/.cache)
else ()
    set(cmakepp_cache_dir $ENV{LOCALAPPDATA} ${CMAKE_CURRENT_LIST_DIR}/tmp)
endif ()
list(GET cmakepp_cache_dir 0 cmakepp_cache_dir)
file(TO_CMAKE_PATH "${cmakepp_cache_dir}" cmakepp_cache_dir)
# dummy function which is overwritten and in this form just returns the temp_dir
function(cmakepp_config key)
    creturn("${cmakepp_tmp_dir}")
endfunction()
## create invoke later functions 
# function(task_enqueue callable)
#   ## semicolon encode before string_encode_semicolon exists
#   string(ASCII  31 us)
#   string(REPLACE ";" "${us}" callable "${callable}")
#   set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
#   return()
# endfunction()



## 
##
## when not to use: if your data degrades when evaluated by a macro
## for example escapes are resolved
macro(creturn)
  set(__ans "${ARGN}" PARENT_SCOPE)
	return()
endmacro()





## registers a parameter definition for the specified function name
## the function may parse the input values from this definition
## help function can parse the input parameters
function(parameter_definition name)
  if(name)
    ## cache values until cmakepp is loaded
    set_property(GLOBAL APPEND PROPERTY __param_defs ${name})
    set_property(GLOBAL PROPERTY "__param_defs.${name}" "${ARGN}")
    if(NOT cmakepp_is_loaded)
      creturn()
    endif()

    ## actual function
    function(parameter_definition name)
      typed_value_definitions("${name}" ${ARGN})
      ans(definitions)
      map_set(__global_definitions "${name}" "${definitions}")
      creturn(${definitions})
    endfunction()
  endif()
  if(NOT cmakepp_is_loaded)
    creturn()
  endif()

  ## load cached values
  get_property(names GLOBAL PROPERTY __param_defs)
  foreach(name ${names})
    get_property(defstring GLOBAL PROPERTY "__param_defs.${name}")
    parameter_definition("${name}" ${defstring})
  endforeach()


endfunction()




## this file should not have the extension .cmake 
## because it needs to be included manually and last
## adds a callable as a task which is to be invoked later
function(task_enqueue callable)

  ## semicolon encode before string_encode_semicolon exists
  string(ASCII  31 us)
  string(REPLACE ";" "${us}" callable "${callable}")
  set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
  
  if(cmakepp_is_loaded)
    function(task_enqueue callable)
      task_new("${callable}")
      ans(task)
      task_queue_global()
      ans(task_queue)
      task_queue_push("${task_queue}" "${task}")
      return_ref(task)
    endfunction()
    address_get(__initial_invoke_later_list)
    ans(tasks)
    foreach(task ${tasks})
      string_decode_semicolon("${task}")
      ans(task)
      task_enqueue("${task}")
    endforeach()
  endif()
endfunction()

# initial version of task_enqueue which is used before cmakepp is loaded
# ## create invoke later functions 
# function(task_enqueue callable)
#   ## semicolon encode before string_encode_semicolon exists
#   string(ASCII  31 us)
#   string(REPLACE ";" "${us}" callable "${callable}")
#   set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
#   creturn()
# endfunction()


## includes all cmake files of cmakepp

# File: source/ast/ast.cmake

# parses an abstract syntax tree from str
function(ast str language)
  language("${language}")
  ans(language)
  # set default root definition to expr
  set(root_definition ${ARGN})
  if(NOT root_definition)
    
    map_get("${language}"  root_definition)
    ans(root_definition)
  endif()



  # transform str to a stream
  token_stream_new(${language} "${str}")
  ans(stream)
  # parse ast and return result
  ast_parse(${stream} "${root_definition}" ${language})
  return_ans()
endfunction()

# File: source/ast/ast_eval.cmake


  function(ast_eval ast context)
    if(ARGN)
      set(args ${ARGN})
      list_pop_front( args)
      ans(ast_language)
      map_tryget(${ast_language}  evaluators)
      ans(ast_evaluators)
      function_import_table(${ast_evaluators} ast_evaluator_table)

    endif()
    if(NOT ast_evaluators)
      message(FATAL_ERROR "no ast_evaluators given")
    endif()
  
    #message("evaluator prefix ${ast_evaluators}... ${ARGN}")
    map_get(${ast}  types)
    ans(types)
    is_map("${ast_evaluators}" )
    ans(ismap)
    while(true)
      list_pop_front( types)    
      ans(type) 
      map_tryget(${ast_evaluators}  "${type}")
      ans(eval_command)
     # message("eval command ist ${eval_command}")
      # avaible vars
      # ast context ast_language ast_evaluators
      # available commands ast_evaluator_table
      if(COMMAND "${eval_command}")
        ast_evaluator_table(${type})
        ans(res)
        return_ref(res)
      endif()
      #if(COMMAND "${eval_command}")
       # eval("${eval_command}(\"${ast}\" \"${scope}\")")
        #ans(res)
        #return_ans()
      #endif()
    endwhile()
  endfunction()

# File: source/ast/ast_eval_assignment.cmake


  function(ast_eval_assignment ast scope)
    message("eval assignment")
    map_get(${ast} children)
    #ans(children)

    #address_get(${children})
    ans(rvalue)
    list_pop_front( rvalue)
    ans(lvalue)
    address_print("${lvalue}")
    address_print("${rvalue}")
    ast_eval(${rvalue} ${scope})
    ans(val)
    message("assigning value ${val} to")

    map_get(${lvalue} types)
    ans(types)
    message("types for lvalue ${types}")

    map_get(${lvalue} identifier)
    ans(identifier)
    map_set(${scope} "${identifier}" ${val})

  endfunction()

# File: source/ast/ast_eval_identifier.cmake

function(ast_eval_identifier ast scope)
  map_get(${ast}  data)
  ans(identifier)
  message("resolving identifier: ${identifier} in '${scope}'")

  map_has(${scope}  "${identifier}")
  ans(has_value)
  if(has_value)
    map_get(${scope}  "${identifier}")
    ans()
    return_ref(value)
  endif()
  #message("no value in scope")

  if(COMMAND "${identifier}")
   # message("is command")
    return_ref(identifier)
  endif()

  if(DEFINED "${identifier}")
    message("is a cmake var")
    return_ref(${identifier})
  endif()
  creturn()
  endfunction()

# File: source/ast/ast_eval_literal.cmake




  function(ast_eval_literal ast scope)
    map_get(${ast} literal data)
    ans(literal)
    return_ref(literal)
  endfunction()


# File: source/ast/ast_parse.cmake

function(ast_parse stream definition_id )

  #message_indent_push()
  if(ARGN)
      set(args ${ARGN})
      list_pop_front( args)
      ans(ast_language)

      map_get(${ast_language}  parsers)
      ans(ast_parsers)
      map_get(${ast_language}  definitions)
      ans(ast_definitions)
      function_import_table(${ast_parsers} __ast_call_parser)

#      json_print(${ast_definitions})
  else()
      if(NOT ast_language)
          message(FATAL_ERROR "missing ast_language")
      endif()
  endif()

 # map_get(${ast_language} parsers parsers)
  map_get("${ast_definitions}"  "${definition_id}")
  ans(definition)
 
  map_tryget(${definition}  node)
  ans(create_node)
  map_get(${definition}  parser)  
  ans(parser)
  map_get(${ast_parsers}  "${parser}")
  ans(parser_command)
  map_tryget(${definition}  peek)
  ans(peek)

  #message("trying to parse ${definition_id} with ${parser} parser")
  if(peek)
    token_stream_push(${stream})
  endif()  
  #eval("${parser_command}(\"${definition}\" \"${stream}\" \"${create_node}\")")

  __ast_call_parser("${parser}" "${definition}" "${stream}" "${create_node}")
  ans(node)
  if(peek)
    token_stream_pop(${stream})
  endif()
 
 #if(node)
 #  message(FORMAT "parsed {node.types}")
 #else()
 #  message("failed to parse ${definition_id}")
 #endif()
 #  message_indent_pop()
  return_ref(node)
endfunction()

# File: source/ast/ast_parse_any.cmake

function(ast_parse_any )#definition stream create_node definition_id
  # check if definition contains "any" property
  map_tryget(${definition}  any)
  ans(any)
#  address_get(${any})
#  ans(any)
  
  # try to parse any of the definitions contained in "any" property
  set(node false)
  foreach(def ${any})    
    ast_parse(${stream} "${def}")
    ans(node)
    if(node)
      break()
    endif()
  endforeach()

  # append definition to current node if a node was returned
  is_address("${node}")
  ans(is_map)
  if(is_map)
  
    map_append(${node} types ${definition_id})
  endif()
  
  
  
  return_ref(node)
endfunction()


# File: source/ast/ast_parse_empty.cmake


  function(ast_parse_empty )#definition stream create_node
    map_tryget(${definition}  empty)
    ans(is_empty)
    if(NOT is_empty)
      creturn(false)
    endif()
   # message("parsed empty!")
    if(NOT create_node)
      creturn(true)
    endif()

    map_new()
    ans(node)
    creturn(${node})
  endfunction()

# File: source/ast/ast_parse_end_of_stream.cmake

function(ast_parse_end_of_stream)
  token_stream_isempty(${stream})
  return_ans()
endfunction()

# File: source/ast/ast_parse_list.cmake



 function(ast_parse_list )#definition stream create_node
 
   # message("parsing list")
    token_stream_push(${stream})

    map_tryget(${definition}  begin)
    ans(begin)
    map_tryget(${definition}  end)
    ans(end)
    map_tryget(${definition}  separator)
    ans(separator)
    map_get(${definition}  element)
    ans(element)
   # message(" ${begin} <${element}> <${separator}> ${end}")
    
    #message("create node ${create_node}")
    if(begin)
      ast_parse(${stream} ${begin})
      ans(begin_ast)
      
      if(NOT begin_ast)
        token_stream_pop(${stream})
        creturn(false)
      endif()

    endif()
    set(child_list)
    while(true)
      if(end)
        ast_parse(${stream} ${end})
        ans(end_ast)
        if(end_ast)
          break()
        endif()
      endif()

      if(separator)
        if(child_list)
          ast_parse(${stream} ${separator})
          ans(separator_ast)

          if(NOT separator_ast)
            token_stream_pop(${stream})
          #  message("failed")
            creturn(false)
          endif()
        endif()
      endif()
      
      ast_parse(${stream} ${element})
      ans(element_ast)

      if(NOT element_ast)
        #failed because no element was found
        if(NOT end)
          break()
        endif()
        creturn(false)
      endif()
      list(APPEND child_list ${element_ast})

     # message("appending child ${element_ast}")

      

    endwhile()
    #message("done ${create_node}")
    token_stream_commit(${stream})

    if(NOT create_node)
      creturn(true)
    endif()
#    message("creating node")

    is_map("${begin_ast}" )
    ans(isnode)
    if(NOT isnode)
      set(begin_ast)
    endif()
    is_map("${end_ast}" )
    ans(isnode)
    if(NOT isnode)
      set(end_ast)
    endif()
    map_tryget(${definition}  name)
    ans(def)
    map_new()
    ans(node)
    map_set(${node} types ${def})
    map_set(${node} children ${begin_ast} ${child_list} ${end_ast})
    creturn(${node})
  endfunction()

# File: source/ast/ast_parse_match.cmake


  function(ast_parse_match definition stream create_node)
    # check if definition can be parsed by ast_parse_match
    map_tryget("${definition}"  match)
    ans(match)
    if(NOT match)
      creturn(false)
    endif()

    # take string specified in match from stream (if stream does)
    # not start with "${match}" nothing is returned
   # message("matching match ${match}")
#    stream_print(${stream})
    stream_take_string(${stream} "${match}")
    ans(res)
    # could not parse if stream did not match "${match}"
    if("${res}_" STREQUAL "_")
      creturn(false)
    endif()

    # return result
    if(NOT create_node)
      creturn(true)
    endif()
    map_new(node)
    ans(node)
    map_set(${node} data ${data})
    creturn(${node})
 endfunction()

# File: source/ast/ast_parse_regex.cmake


  function(ast_parse_regex definition stream create_node)
    nav(regex = "definition.regex")
    # regex - try match
    if(NOT regex)
      creturn(false)
    endif()
   # message("regex: ${regex}")
    stream_take_regex(${stream} "${regex}")
    ans(match)
  #  message("matched: '${match}'")
    if(NOT match)
      creturn(false)
    endif()
    nav(replace = definition.replace)
    if(replace)
      #message("replace: ${replace}")
      string(REGEX REPLACE "${regex}" "\\${replace}" match "${match}")
    endif()
    if(NOT create_node)
     # message("create_node: ${create_node}")
      creturn(true)
    endif()
    map_new()
    ans(node)
    map_set(${node} data "${match}")
    creturn(${node})
  endfunction()

# File: source/ast/ast_parse_sequence.cmake

function(ast_parse_sequence )#definition stream create_node definition_id
  map_tryget("${definition}"  sequence)
  ans(sequence)
  set(rsequence)
  if(NOT sequence)
    map_tryget("${definition}"  rsequence)
    ans(sequence)
    set(rsequence true)
  endif()
  if(NOT sequence)
    message(FATAL_ERROR "expected a sequence or a rsequence")
  endif()
  # deref ref array
#  address_get(${sequence} )
#  ans(sequence)
  
  # save current stream
  #message("push")
  token_stream_push(${stream})

  # empty var for sequence
  set(ast_sequence)

  # loop through all definitions in sequence
  # adding all resulting nodes in order to ast_sequence
  foreach(def ${sequence})
    ast_parse(${stream} "${def}")
    ans(res)
    if(res) 
      is_map(${res} )
      ans(ismap)
      if(ismap)
        list(APPEND ast_sequence ${res})
      endif()
    else()
     # message("pop")
      token_stream_pop(${stream})
      creturn(false)
    endif()
   
  endforeach()
  token_stream_commit(${stream})
  # return result
  if(NOT create_node)
    creturn(true)
  endif()
  map_new()
  ans(node)
  map_set(${node} types ${definition_id})
  
  map_set(${node} children ${ast_sequence})
  creturn(${node})
endfunction()


# File: source/ast/ast_parse_token.cmake


  function(ast_parse_token )#definition stream create_node definition_id
    #message(FORMAT "trying to parse {definition.name}")
   # address_print("${definition}")
   # address_print(${definition})

    token_stream_take(${stream} ${definition})
    ans(token)

    if(NOT token)
      creturn(false)
    endif()
    
    #message(FORMAT "parsed {definition.name}: {token.data}")
    if(NOT create_node)
      creturn(true)
    endif()

    map_tryget(${definition}  replace)
    ans(replace)
    if(replace)
      map_get(${token}  data)
      ans(data)
      map_get(${definition}  regex)
      ans(regex)
      string(REGEX REPLACE "${regex}" "\\${replace}" data "${data}")
      #message("data after replace ${data}")
      map_set_hidden(${token} data "${data}")
    endif()
    
    map_set_hidden(${token} types ${definition_id})
    creturn(${token})

  endfunction()

# File: source/ast/evaluate.cmake


  function(evaluate str language expr)
    language(${language})
    ans(language)

    set(scope ${ARGN})
    is_map("${scope}" )
    ans(ismap)
    if(NOT ismap)
      map_new()
      ans(scope)
      foreach(arg ${ARGN})
        map_set(${scope} "${arg}" ${${arg}})
      endforeach()
    endif()


    map_new()
    ans(context)
    map_set(${context} scope ${scope})

  #  message("expr ${expr}")

    ast("${str}" ${language} "${expr}")
    #creturn("gna")
    ans(ast) 
   # address_print(${ast})
    ast_eval(${ast} ${context} ${language})
    ans(res)
    if(NOT ismap)
      map_promote(${scope})
    endif()
    return_ref(res)
  endfunction()

# File: source/ast/expr/expr_compile_assignment.cmake

function(expr_compile_assignment) # scope, ast

  #message("compiling assignment")
  map_tryget(${ast}  children)
  ans(children)
  list_extract(children lvalue_ast rvalue_ast)

  map_tryget(${lvalue_ast}  types)
  ans(types)
  list_extract(types lvalue_type) 
  set(res)


  if("${lvalue_type}" STREQUAL "cmake_identifier" )
    #message("assigning cmake identifier")
    map_tryget(${lvalue_ast}  children)
    ans(children)
    list_extract(children identifier_ast)
    map_tryget(${identifier_ast}  data)
    ans(identifier)
    set(res "
  set(assignment_key \"${identifier}\")
  set(assignment_scope \"\${global}\")")
  elseif("${lvalue_type}" STREQUAL "identifier")
   # message("assigning identifier")
    map_tryget(${lvalue_ast}  data)
    ans(identifier)
    set(res "
  set(assignment_key \"${identifier}\")
  set(assignment_scope \"\${this}\")")
  elseif("${lvalue_type}" STREQUAL "indexation")
    map_tryget(${lvalue_ast}  children)
    ans(indexation_ast)
    ast_eval(${indexation_ast} ${context})
    ans(indexation)
    set(res "
  ${indexation}
  ans(assignment_key)
  set(assignment_scope \"\${this}\")")
  endif()

  ast_eval(${rvalue_ast} ${context})
  ans(rvalue)
  set(res "
  # expr_compile_assignment
  ${rvalue}
  ans(rvalue)
  ${res}
  map_set(\"\${assignment_scope}\" \"\${assignment_key}\" \"\${rvalue}\" )
  set_ans_ref(rvalue)
  # end of expr_compile_assignment")
  return_ref(res)   
endfunction()

# File: source/ast/expr/expr_compile_bind.cmake

function(expr_compile_bind)
  set(res "
  # expr_compile_bind 
  set(this \"\${left}\")
  # end of expr_compile_bind")
  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_call.cmake

function(expr_compile_call)
  map_tryget(${ast}  children) 
  ans(argument_asts)
  set(arguments)
  set(evaluation)
  set(i 0)


  make_symbol()
  ans(symbol)

  foreach(argument_ast ${argument_asts})
    ast_eval(${argument_ast} ${context})
    ans(argument)

    set(evaluation "${evaluation}
  ${argument}
  ans(${symbol}_arg${i})")
    set(arguments "${arguments}\"\${${symbol}_arg${i}}\" " )
    math(EXPR i "${i} + 1")
  endforeach()

  set(res "
  # expr_compile_call 
  ${evaluation}
  call(\"\${left}\"(${arguments}))
  # end of expr_compile_call")

  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_cmake_identifier.cmake

function(expr_compile_cmake_identifier)
  #message("cmake_identifier")
  #address_print(${ast})
  map_get(${ast}  children)
  ans(identifier)
  map_get(${identifier}  data)
  ans(identifier)
  
  set(res "
  #expr_compile_cmake_identifier
  if(COMMAND \"${identifier}\")
    set_ans(\"${identifier}\")
  else() 
    set_ans_ref(\"${identifier}\") 
  endif()
  # end of expr_compile_cmake_identifier")
  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_coalescing.cmake

function(expr_compile_coalescing)
  map_tryget(${ast}  children)
  ans(expr_ast)
  ast_eval(${expr_ast} ${context})
  ans(expr)
  set(res "
  # expr_compile_coalescing 
  if(NOT left)
    ${expr}
  endif()
  # end of expr_compile_coalescing")
  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_expression.cmake

function(expr_compile_expression)
  #message("compiling expression")
  map_get(${ast}  children)
  ans(children)
  set(result "")
  
  list(LENGTH children len)
  if(len GREATER 1)

    make_symbol()
    ans(symbol)
    foreach(rvalue_ast ${children})
      ast_eval(${rvalue_ast} ${context})
      ans(rvalue)

      set(result "${result}
  ${rvalue}
  ans(left)")
      map_set(${context} left ${rvalue})
      map_set(${context} left_ast ${rvalue_ast})
    endforeach()
    
    map_append_string(${context} code "
#expr_compile_expression
function(${symbol})
  set(left)
  ${result}
  return_ref(left)
endfunction()
#end of expr_compile_expression")

    set(symbol "
  #expr_compile_expression
  ${symbol}()
  #end of expr_compile_expression")
  else()
    ast_eval(${children} ${context})
    ans(symbol)
  endif()


  return_ref(symbol)
endfunction()

# File: source/ast/expr/expr_compile_expression_statement.cmake

function(expr_compile_expression_statement) # context, ast
  map_tryget(${ast}  children)
  ans(statement_ast)
  ast_eval(${statement_ast} ${context})
  ans(statement)
  set(res "
  # expr_compile_statement
  ${statement}
  # end of expr_compile_statement")
  return_ref(res)  
endfunction()

# File: source/ast/expr/expr_compile_function.cmake

function(expr_compile_function) # context, ast
 # message("expr_compile_function")

  map_tryget(${ast} children)
  ans(children)

  #message("children ${children}")

  list_extract(children signature_ast body_ast)

  map_tryget(${signature_ast} children)
  ans(signature_identifiers)
  set(signature_vars)
  set(identifiers)
  foreach(identifier ${signature_identifiers})
    map_tryget(${identifier} data)
    ans(identifier)
    list(APPEND identifiers "${identifier}")
    set(signature_vars "${signature_vars} ${identifier}")
  endforeach()  
  #message("signature_identifiers ${identifiers}")

  map_tryget(${body_ast} types)
  ans(body_types)

  list_contains(body_types closure)
  ans(is_closure)
  
  if(is_closure)
   map_tryget(${body_ast} children)
    ans(body_ast)

  endif()

  make_symbol()
  ans(symbol)
 # message("body_types ${body_types}")

  ast_eval(${body_ast} ${context})
  ans(body)

map_append_string(${context} code "#expr_compile_function
function(\"${symbol}\"${signature_vars})
  map_new()
  ans(local)  
  map_capture(\"\${local}\" this global${signature_vars})
  ${body}
  return_ans()
endfunction()
#end of expr_compile_function")
  

  set(res "set_ans(\"${symbol}\")")

  return_ref(res)  
endfunction()

# File: source/ast/expr/expr_compile_identifier.cmake

function(expr_compile_identifier)# ast context
  
#message("ast: ${ast}")
  
  map_tryget(${ast}  data)
  ans(data)
  set(res "
  # expr_compile_identifier
  #map_tryget(\"\${local}\" \"${data}\")
  scope_resolve(\"${data}\")
  obj_get(\"\${this}\" \"${data}\")
  # end of expr_compile_identifier")
  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_indexation.cmake

function(expr_compile_indexation)
  map_tryget(${ast}  children)
  ans(indexation_expression_ast)
  ast_eval(${indexation_expression_ast} ${context})
  ans(indexation_expression)

  set(res "
  # expr_compile_indexation
  ${indexation_expression}
  ans(index)
  set(this \"\${left}\")
  map_get(\"\${this}\" \"\${index}\")
  # end of expr_compile_indexation")


  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_list.cmake

function(expr_compile_list)
  map_tryget(${ast}  children) 
  ans(element_asts)
  set(arguments)
  set(evaluation)
  set(i 0)

  make_symbol()
  ans(symbol)
  set(elements)
  foreach(element_ast ${element_asts})
    ast_eval(${element_ast} ${context})
    ans(element)

    set(evaluation "${evaluation}
  ${element}
  ans(${symbol}_arg${i})")
    set(elements "${elements}\"\${${symbol}_arg${i}}\" " )
    math(EXPR i "${i} + 1")
  endforeach()
  set(res "
  #expr_compile_list
  ${evaluation}
  set(${symbol} ${elements})
  set_ans_ref(${symbol})
  #end of expr_compile_list")
  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_new.cmake

function(expr_compile_new)
#json_print(${ast})
  map_tryget(${ast} children)
  ans(children)

  list_extract(children className_ast call_ast)

  map_tryget(${className_ast} data)
  ans(className)

  map_tryget(${call_ast} children)
  ans(argument_asts)


 # message("class name is ${className} ")

  set(arguments)
  set(evaluation)
  set(i 0)

  make_symbol()
  ans(symbol)

  foreach(argument_ast ${argument_asts})
    ast_eval(${argument_ast} ${context})
    ans(argument)

    set(evaluation "${evaluation}
  ${argument}
  ans(${symbol}_arg${i})")
    set(arguments "${arguments}\"\${${symbol}_arg${i}}\" " )
    math(EXPR i "${i} + 1")
  endforeach()

  set(res "
#expr_compile_new
${evaluation}
obj_new(\"${className}\" ${arguments})
#end of expr_compile_new
  ")


return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_new_object.cmake

function(expr_compile_new_object)
  map_tryget(${ast}  children)
  ans(keyvalues)
  map_tryget(${keyvalues}  children)
  ans(keyvalues)

  make_symbol()
  ans(symbol)

  set(evaluation)
  foreach(keyvalue ${keyvalues})
    map_tryget(${keyvalue}  children)
    ans(pair)
    list_extract(pair key_ast value_ast)
    map_tryget(${key_ast}  data)
    ans(key)
    ast_eval(${value_ast} ${context})
    ans(value)
    #string(REPLACE "\${" "\${" value "${value}")
    set(evaluation "${evaluation}
    ${value}
    ans(${symbol}_tmp)
    map_set(\"\${${symbol}}\" \"${key}\" \"\${${symbol}_tmp}\")")
  endforeach()

  set(res "
  #expr_compile_new_object
  map_new()
  ans(${symbol})
  ${evaluation}
  set_ans_ref(${symbol})
  #end of expr_compile_new_object
  ")

  return_ref(res)

endfunction()

# File: source/ast/expr/expr_compile_number.cmake

function(expr_compile_number) # scope, ast

  map_tryget(${ast}  data)
  ans(data)
  make_symbol()
  ans(symbol)
  
 
  set(res "
  # expr_compile_number
  set_ans(\"${data}\")
  # end of expr_compile_number")
  return_ref(res)  
endfunction()

# File: source/ast/expr/expr_compile_parentheses.cmake

function(expr_compile_parentheses)

  map_tryget(${ast}  children)
  ans(expression_ast)
  ast_eval(${expression_ast} ${context})
  ans(expression)

  set(res "
  # expr_compile_parentheses
  ${expression}
  # end of expr_compile_parentheses")


  return_ref(res)
endfunction()

# File: source/ast/expr/expr_compile_statements.cmake

function(expr_compile_statements) # scope, ast
  map_tryget(${ast}  children)
  ans(statement_asts)
  set(statements)
  #message("children: ${statement_asts}")
  list(LENGTH statement_asts len)
  set(index 0)
  foreach(statement_ast ${statement_asts})
    math(EXPR index "${index} + 1")
    ast_eval(${statement_ast} ${context})
    ans(statement)
    set(statements "${statements}
  #statement ${index} / ${len}
  ${statement}")
  endforeach()
  map_tryget(${ast}  data)
  ans(data)
  make_symbol()
  ans(symbol)
  
  make_symbol()
  ans(symbol)

  map_append_string(${context} code "
# expr_compile_statements
function(\"${symbol}\")
  ${statements}
  return_ans()
endfunction()
# end of expr_compile_statements")
  
  set(res "${symbol}()")

#  message("${res}")
  return_ref(res)  
endfunction()

# File: source/ast/expr/expr_compile_string.cmake

function(expr_compile_string) # scope, ast

  map_tryget(${ast}  data)
  ans(data)
  make_symbol()
  ans(symbol)
  
 
  set(res "
  # expr_compile_string
  set_ans(\"${data}\")
  # end of expr_compile_string")
  return_ref(res)  
endfunction()

# File: source/ast/expr/expr_definition.cmake

## file containing data from resources/expr.json 
function(expr_definition)
map()
 key("name")
  val("oocmake")
 key("phases")
 map()
  key("name")
   val("tokenize")
  key("function")
   val("token_stream_new\(/0\ /1\)")
  key("input")
   val("global")
   val("str")
  key("output")
   val("tokens")
 end()
 map()
  key("name")
   val("parse")
  key("function")
   val("ast_parse\(/0\ /1\ /2\ /3\ /4\)")
  key("input")
   val("tokens")
   val("root_definition")
   val("global")
   val("parsers")
   val("definitions")
  key("output")
   val("ast")
 end()
 map()
  key("name")
   val("compile")
  key("function")
   val("ast_eval\(/0\ /1\ /2\ /3\)")
  key("input")
   val("ast")
   val("context")
   val("global")
   val("evaluators")
  key("output")
   val("symbol")
 end()
 key("parsers")
 map()
  key("token")
   val("ast_parse_token")
  key("any")
   val("ast_parse_any")
  key("sequence")
   val("ast_parse_sequence")
  key("list")
   val("ast_parse_list")
  key("empty")
   val("ast_parse_empty")
  key("end_of_stream")
   val("ast_parse_end_of_stream")
 end()
 key("evaluators")
 map()
  key("string")
   val("expr_compile_string")
  key("number")
   val("expr_compile_number")
  key("cmake_identifier")
   val("expr_compile_cmake_identifier")
  key("call")
   val("expr_compile_call")
  key("expression")
   val("expr_compile_expression")
  key("bind")
   val("expr_compile_bind")
  key("indexation")
   val("expr_compile_indexation")
  key("identifier")
   val("expr_compile_identifier")
  key("list")
   val("expr_compile_list")
  key("new_object")
   val("expr_compile_new_object")
  key("assignment")
   val("expr_compile_assignment")
  key("parentheses")
   val("expr_compile_parentheses")
  key("null_coalescing")
   val("expr_compile_coalescing")
  key("statements")
   val("expr_compile_statements")
  key("expression_statement")
   val("expr_compile_expression_statement")
  key("function")
   val("expr_compile_function")
  key("if")
   val("expr_compile_if")
  key("while")
   val("expr_compile_while")
  key("for")
   val("expr_compile_for")
  key("foreach")
   val("expr_compile_foreach")
  key("new")
   val("expr_compile_new")
 end()
 key("root_definition")
  val("statements")
 key("definitions")
 map()
  key("statements")
  map()
   key("node")
    val("true")
   key("parser")
    val("list")
   key("element")
    val("statement")
  end()
  key("if")
  map()
   key("node")
    val("true")
   key("parser")
    val("any")
   key("any")
    val("if_else")
    val("if_only")
  end()
  key("for_keyword")
  map()
   key("parser")
    val("token")
   key("regex")
    val("for")
  end()
  key("while_keyword")
  map()
   key("parser")
    val("token")
   key("regex")
    val("while")
  end()
  key("new")
  map()
   key("parser")
    val("sequence")
   key("node")
    val("true")
   key("sequence")
    val("new_keyword")
    val("identifier")
    val("call")
  end()
  key("for")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("for_keyword")
    val("paren_open")
    val("expression")
    val("expression")
    val("expression")
    val("paren_close")
    val("statement")
  end()
  key("while")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("while_keyword")
    val("paren_open")
    val("expression")
    val("paren_close")
    val("statement")
  end()
  key("foreach")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("while_keyword")
    val("paren_open")
    val("expression")
    val("paren_close")
    val("statement")
  end()
  key("if_only")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("if_keyword")
    val("paren_open")
    val("expression")
    val("paren_close")
    val("statement")
  end()
  key("if_else")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("if_only")
    val("else_keyword")
    val("statement")
  end()
  key("if_keyword")
  map()
   key("parser")
    val("token")
   key("regex")
    val("if")
  end()
  key("else_keyword")
  map()
   key("parser")
    val("token")
   key("regex")
    val("else")
  end()
  key("expression_statement")
  map()
   key("parser")
    val("sequence")
   key("node")
    val("true")
   key("sequence")
    val("expression")
    val("end_of_statement")
  end()
  key("statement")
  map()
   key("parser")
    val("any")
   key("any")
    val("expression_statement")
  end()
  key("end_of_statement")
  map()
   key("parser")
    val("any")
   key("any")
    val("semicolon")
    val("end_of_stream")
  end()
  key("expression")
  map()
   key("node")
    val("true")
   key("parser")
    val("list")
   key("begin")
    val("value")
   key("element")
    val("operation")
   key("end")
    val("end_of_expression")
  end()
  key("function")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("function_signature")
    val("hyphen")
    val("angular_bracket_close")
    val("function_body")
  end()
  key("hyphen")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[-]")
  end()
  key("angular_bracket_open")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[<]")
  end()
  key("angular_bracket_close")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[>]")
  end()
  key("function_signature")
  map()
   key("node")
    val("true")
   key("parser")
    val("list")
   key("element")
    val("identifier")
   key("begin")
    val("paren_open")
   key("end")
    val("paren_close")
   key("separator")
    val("comma")
  end()
  key("function_body")
  map()
   key("parser")
    val("any")
   key("any")
    val("closure")
    val("expression")
  end()
  key("closure")
  map()
   key("parser")
    val("sequence")
   key("node")
    val("true")
   key("sequence")
    val("brace_open")
    val("statements")
    val("brace_close")
  end()
  key("value")
  map()
   key("parser")
    val("any")
   key("any")
    val("assignment")
    val("function")
    val("parentheses")
    val("literal")
    val("lvalue")
    val("list")
    val("new_object")
    val("new")
  end()
  key("lvalue")
  map()
   key("parser")
    val("any")
   key("any")
    val("cmake_identifier")
    val("identifier")
    val("indexation")
  end()
  key("operation")
  map()
   key("parser")
    val("any")
   key("any")
    val("assignment")
    val("identifier")
    val("call")
    val("bind")
    val("indexation")
    val("null_coalescing")
  end()
  key("null_coalescing")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("query")
    val("query")
    val("expression")
  end()
  key("query")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[?]")
  end()
  key("parentheses")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("paren_open")
    val("expression")
    val("paren_close")
  end()
  key("assignment")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("lvalue")
    val("equals")
    val("expression")
  end()
  key("indexation")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("bracket_open")
    val("expression")
    val("bracket_close")
  end()
  key("bind")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("period")
  end()
  key("new_object")
  map()
   key("node")
    val("true")
   key("parser")
    val("sequence")
   key("sequence")
    val("key_value_list")
  end()
  key("key_value_list")
  map()
   key("parser")
    val("list")
   key("node")
    val("true")
   key("begin")
    val("brace_open")
   key("end")
    val("brace_close")
   key("element")
    val("key_value")
   key("separator")
    val("comma")
  end()
  key("call")
  map()
   key("parser")
    val("list")
   key("begin")
    val("paren_open")
   key("element")
    val("expression")
   key("separator")
    val("comma")
   key("end")
    val("paren_close")
   key("node")
    val("true")
  end()
  key("end_of_expression")
  map()
   key("parser")
    val("any")
   key("peek")
    val("true")
   key("any")
    val("comma")
    val("paren_close")
    val("semicolon")
    val("bracket_close")
    val("brace_close")
    val("end_of_stream")
  end()
  key("list")
  map()
   key("parser")
    val("list")
   key("begin")
    val("bracket_open")
   key("end")
    val("bracket_close")
   key("separator")
    val("comma")
   key("element")
    val("expression")
   key("node")
    val("true")
  end()
  key("new_keyword")
  map()
   key("parser")
    val("token")
   key("regex")
    val("new")
  end()
  key("key_value")
  map()
   key("parser")
    val("sequence")
   key("node")
    val("true")
   key("sequence")
    val("key")
    val("colon")
    val("key_value_value")
  end()
  key("key_value_value")
  map()
   key("parser")
    val("any")
   key("any")
    val("list")
    val("expression")
  end()
  key("key")
  map()
   key("parser")
    val("any")
   key("any")
    val("identifier")
    val("string")
  end()
  key("identifier")
  map()
   key("parser")
    val("token")
   key("node")
    val("true")
   key("regex")
    val("\([a-zA-Z_-][a-zA-Z0-9_\\-]*\)")
   key("except")
    val("\(new|for|while\)")
  end()
  key("cmake_identifier")
  map()
   key("parser")
    val("sequence")
   key("node")
    val("true")
   key("sequence")
    val("dollar")
    val("identifier")
  end()
  key("end_of_stream")
  map()
   key("parser")
    val("end_of_stream")
  end()
  key("nothing")
  map()
   key("parser")
    val("empty")
   key("empty")
    val("true")
  end()
  key("colon")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[:]")
  end()
  key("semicolon")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[\\\\\;]")
  end()
  key("period")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[\\.]")
  end()
  key("dollar")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[\\\$]")
  end()
  key("equals")
  map()
   key("parser")
    val("token")
   key("regex")
    val("=")
  end()
  key("literal")
  map()
   key("parser")
    val("any")
   key("any")
    val("string")
    val("number")
  end()
  key("paren_close")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[\)]")
  end()
  key("paren_open")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[\(]")
  end()
  key("bracket_close")
  map()
   key("parser")
    val("token")
   key("regex")
    val("]")
  end()
  key("bracket_open")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[\\[]")
  end()
  key("brace_close")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[}]")
  end()
  key("brace_open")
  map()
   key("parser")
    val("token")
   key("regex")
    val("[{]")
  end()
  key("comma")
  map()
   key("parser")
    val("token")
   key("match")
    val(",")
  end()
  key("string")
  map()
   key("parser")
    val("token")
   key("node")
    val("true")
   key("regex")
    val("'\(\([\^']|\\\\'\)*\)'")
   key("replace")
    val("1")
  end()
  key("number")
  map()
   key("parser")
    val("token")
   key("node")
    val("true")
   key("regex")
    val("\([1-9][0-9]*\)")
  end()
  key("white_space")
  map()
   key("parser")
    val("token")
   key("ignore_token")
    val("true")
   key("regex")
    val("[\r\n\t\ ]+")
  end()
 end()
end()
ans(res)
return_ref(res)

endfunction()

# File: source/ast/expr/expr_eval_call.cmake

function(expr_eval_call)
  map_tryget(${ast}  children) 
  ans(argument_asts)
  set(arguments)
  foreach(argument_ast ${argument_asts})
    ast_eval(${argument_ast} ${context})
    ans(argument)
    set(arguments "${arguments}\"${argument}\" " )
  endforeach()
  map_get(${context}  left)
  ans(invokation_target)
  set(invokation "${invokation_target}"("${arguments}"))
  call("${invokation}")
  return_ans()
endfunction()

# File: source/ast/expr/expr_eval_cmake_identifier.cmake

function(expr_eval_cmake_identifier)
  #message("cmake_identifier")
  #address_print(${ast})
  map_get(${ast}  children)
  ans(identifier)
  map_get(${identifier}  data)
  ans(identifier)

  if(NOT "${identifier}" AND COMMAND "${identifier}")
    
  else()
    set(identifier "${${identifier}}")
  endif()
#  message("returning ${identifier}")
  return_ref(identifier)
endfunction()

# File: source/ast/expr/expr_eval_identifier.cmake

function(expr_eval_identifier)# ast scope
  message("identifier")
  address_print(${ast})
endfunction()

# File: source/ast/expr/expr_eval_rvalues.cmake

function(expr_eval_expression)
#  message("evaluating expression")
  map_get(${ast}  children)
  ans(children)
    map_new()
    ans(new_context)
  map_set(${new_context} parent_context ${context})
  map_tryget(${context}  scope)
  ans(scope)
  map_set(${new_context} scope ${scope})

  foreach(rvalue_ast ${children})
    ast_eval(${rvalue_ast} ${new_context})
    ans(rvalue)
    map_set(${new_context} left ${rvalue})
    map_set(${new_context} left_ast ${rvalue_ast})
  endforeach()


  map_tryget(${new_context}  left)
  ans(left)
  return_ref(left)
endfunction()

# File: source/ast/expr/expr_eval_string.cmake

function(expr_eval_string) # scope, ast
  map_tryget(${ast}  data)
  ans(data)
  return_ref(data)  
endfunction()

# File: source/ast/expr_compile.cmake

function(expr_compile str)
  map_new()
  ans(expression_cache)
  address_set(__expression_cache ${expression_cache})
  function(expr_compile str)
    set(ast)
    address_get(__expression_cache )
    ans(expression_cache)
    map_tryget(${expression_cache}  "${str}")
    ans(symbol)
    if(NOT symbol)
      # get ast
      language("oocmake")
      ans(language)
      if(NOT language)
        cmakepp_config(base_dir)
        ans(base_dir)
        language("${base_dir}/resources/expr.json")
        ans(language)
      endif()
      #message("compiling ast for \"${str}\"")
      ast("${str}" oocmake "")
      ans(ast)
      #message("ast created")
      # compile to cmake
      map_new()
      ans(context)
      map_new()
      ans(scope)
      map_set(${context} scope ${scope})    
      ast_eval(${ast} ${context} ${language})
      ans(symbol)
      map_tryget(${context}  code)
      ans(code)
      if(code)
       # message("${code}")
        set_ans("")
        eval("${code}")
      endif()
      map_set(${expression_cache} "${str}" ${symbol})
    endif()
    #eval("${symbol}")
    #return_ans()
    return_ref(symbol)
  endfunction()
  expr_compile("${str}")
  return_ans()
endfunction()

# File: source/ast/expr_import.cmake

function(expr_import str function_name)
  expr_compile("${str}")
  ans(symbol)
  set_ans("")
  eval("
function(${function_name})
  is_map(\"${global}\" )
  ans(ismap)
  if(NOT ismap)
    map_new()
    ans(global)
  endif()
  ${symbol}
  ans(res)
  if(NOT ismap)
    map_promote(${global})
  endif()
  return_ref(res)
endfunction()")
  return_ans()
endfunction()

# File: source/ast/json/ast_json_eval_array.cmake


  function(ast_json_eval_array )#ast scope
    map_get(${ast}  children)
    ans(values)
    set(res)
    foreach(value ${values})
      ast_eval(${value} ${context})
      ans(evaluated_value)
      list(APPEND res "${evaluated_value}")
    endforeach()
    return_ref(res)
  endfunction()

# File: source/ast/json/ast_json_eval_boolean.cmake


  function(ast_json_eval_boolean )#ast scope
    map_get(${ast}  data)
    ans(data)
    return_ref(data)
  endfunction()

# File: source/ast/json/ast_json_eval_key_value.cmake


  function(ast_json_eval_key_value )#ast scope
    map_get(${ast}  children)
    ans(value)
    list_pop_front( value)
    ans(key)
    ast_eval(${key} ${context})
    ans(key)
    ast_eval(${value} ${context})
    ans(value)

    #message("keyvalue ${key}:${value}")
    map_set(${context} ${key} ${value})
  endfunction()

# File: source/ast/json/ast_json_eval_null.cmake


  function(ast_json_eval_null )#ast scope
    map_get(${ast}  data)
    ans(data)
    creturn()
  endfunction()

# File: source/ast/json/ast_json_eval_number.cmake


  function(ast_json_eval_number )#ast scope
    map_get(${ast}  data)
    ans(data)
    return_ref(data)
  endfunction()

# File: source/ast/json/ast_json_eval_object.cmake


  function(ast_json_eval_object )#ast scope
    map_new()
    ans(map)
    map_get(${ast}  children)
    ans(keyvalues)
    foreach(keyvalue ${keyvalues})
      ast_eval(${keyvalue} ${map})
    endforeach()
    creturn(${map})
  endfunction()

# File: source/ast/json/ast_json_eval_string.cmake


  function(ast_json_eval_string )#ast scope
    map_get(${ast}  data)
    ans(data)
    return_ref(data)
  endfunction()

# File: source/ast/lang.cmake


  function(lang target context)    
    #message("target ${target}")
    obj_get(${context} phases)
    ans(phases)

   

    # get target value from
    obj_has(${context} "${target}")
    ans(has_target)
    if(NOT has_target)
      message(FATAL_ERROR "missing target '${target}'")        
    endif()
    obj_get(${context} "${target}")
    ans(current_target)

    if("${current_target}_" STREQUAL "_")
        creturn()
    endif()

    # check if phase
    list_contains(phases "${current_target}")
    ans(isphase)    
    # if not a phase just return value
    if(NOT isphase)
      return_ref("current_target")
    endif()


    # target is phase 
    map_tryget("${current_target}" name)
    ans(name)


    # get inputs for current target
    obj_get("${current_target}" "input")
    ans(required_inputs)

    # setup required imports
    map_new()
    ans(inputs)
    foreach(input ${required_inputs})
        #message_indent_push()
        #message("getting ${input} ${required_inputs}")

        lang("${input}" ${context})
        ans(res)
        #message("got ${res} for ${input}")
        #message_indent_pop()
        map_set(${inputs} "${input}" "${res}")
    endforeach()

    # handle function call
    map_tryget("${current_target}" function)
    ans(func)
    if("${func}" MATCHES "(.*)\\(([^\\)]*)\\)$" )
        set(func "${CMAKE_MATCH_1}")
        set(arg_assignments "${CMAKE_MATCH_2}")
        string(REPLACE " " ";" arg_assignments "${arg_assignments}")
    else()
        message(FATAL_ERROR "failed to parse targets function")
    endif()

    # curry function to specified arguments
    curry3(() => "${func}"(${arg_assignments}))
    ans(func)

    # compile argument string

    map_keys(${inputs})
    ans(keys)
    set(arguments_string)
    foreach(key ${keys})
      map_tryget(${inputs} "${key}")
      ans(val)
      cmake_string_escape("${val}")
      ans(val)
      #message("key ${key} val ${val}")
      #string(REPLACE "\\" "\\\\"  val "${val}")
      #string(REPLACE "\"" "\\\"" val "${val}")
      set(arguments_string "${arguments_string} \"${val}\"")
    endforeach()
    # call curried function - note that context is available to be modified
    set(func_call "${func}(${arguments_string})")
 
    #message("lang: target '${target}'  func call ${func_call}")
   set_ans("")
    eval("${func_call}")
    ans(res)    
   # message("res '${res}'")
    obj_set(${context} "${target}" "${res}")

    # set single output to return value
    map_tryget(${current_target} output)
    ans(outputs)
    list(LENGTH outputs len)
    if(${len} EQUAL 1)
      set(${context} "${outputs}" "${res}")
    endif()

    map_tryget(${context} "${target}")
    ans(res)

    return_ref(res)
  endfunction()

# File: source/ast/lang2.cmake

# executes the language file, input can be given by a key value list
  function(lang2 target language)
    map_from_keyvaluelist("" ${ARGN})
    ans(ctx)
    language("${language}")
    ans(language)
    
    obj_setprototype("${ctx}" "${language}")
    lang("${target}" "${ctx}")
    ans(res)

    
    return_ref(res)
  endfunction()

# File: source/ast/language.cmake

function(language name)
  map_new()
  ans(language_map)
  address_set(language_map "${language_map}")


function(language name)
  ## get cached language
  address_get(language_map)
  ans(language_map)

  is_map("${name}")
  ans(ismp)
  if(ismp)
    map_tryget(${name}  initialized)
    ans(initialized)
    if(NOT initialized)
      language_initialize(${name})
    endif()
    map_tryget(${name} name)
    ans(lang_name)
    map_tryget(${language_map} ${lang_name})
    ans(existing_lang)
    if(NOT existing_lang)
      map_set(${language_map} ${lang_name} ${name})
    endif()
    return_ref(name)
  endif()

  map_tryget(${language_map}  "${name}")
  ans(language)


  if(NOT language)
    language_load(${name})
    ans(language)

    if(NOT language)
      creturn()
    endif()
    map_set(${language_map} "${name}" ${language})
    
    map_get(${language}  name)
    ans(name)
    map_set(${language_map} "${name}" ${language})
    set_ans("")
    eval("function(eval_${name} str)
    language(\"${name}\")
    ans(lang)
    ast(\"\${str}\" \"${name}\" \"\")
    ans(ast)
    map_new()
    ans(context)
      #message(\"evaling '\${ast}' with lang '\${lang}' context is \${context} \")
    ast_eval(\${ast} \${context} \${lang})
    ans(res)
    return_ref(res)
    endfunction()")
  endif()
  return_ref(language)
endfunction()

language("${name}" ${ARGN})
return_ans()

endfunction()

# File: source/ast/language_initialize.cmake


function(language_initialize language)
  # sets up the language object
    
  map_tryget(${language}  initialized)
  ans(initialized)
  if(initialized)
    creturn(${language})
  endif()


  # setup token definitions

  # setup definition names
  map_get(${language}  definitions)
  ans(definitions)
  map_keys(${definitions})
  ans(keys)
  foreach(key ${keys})
    map_get(${definitions}  ${key})
    ans(definition)
    map_set(${definition} name ${key} )
  endforeach()  

  #
  token_definitions(${language})
  ans(token_definitions)
  map_set(${language} token_definitions ${token_definitions})

  map_set(${language} initialized true)


  # extract phases
  map_tryget(${language} phases)
  ans(phases)
#  is_address("${phases}")
#  ans(isref)
#  if(isref)
#    address_get(${phases})
#    ans(phases)
#  endif()
  map_set(${language} phases "${phases}")


  # setup self reference
  map_set(${language} global ${language})
  

  # setup outputs
  foreach(phase ${phases})
    map_tryget(${phase} name)
    ans(name)
    map_set("${language}" "${name}" "${phase}")

    map_tryget("${phase}" output)
    ans(outputs)
    if(outputs)
 #     is_address("${outputs}")
 #     ans(isref)
#      if(isref)
 #       address_get(${outputs})
  #      ans(outputs)
   #   endif()
      map_set("${phase}" output "${outputs}")

      foreach(output ${outputs})
        map_set(${language} "${output}" "${phase}")
      endforeach()
    endif()
  endforeach()



  # setup inputs
  foreach(phase ${phases})
    map_tryget("${phase}" input)
    ans(inputs)
    if(inputs)
#      is_address("${inputs}")
 #     ans(isref)
  #    if(isref)
   #     address_get(${inputs})
    #    ans(inputs)
    # endif()
      map_set("${phase}" input "${inputs}")
     # message("inputs for phase ${phase} ${inputs}")

      foreach(input ${inputs})
        map_tryget(${language} "${input}")
        ans(val)
        if(NOT val)
          map_set(${language} "${input}" "missing")
        
         # message("missing input: ${input}")
        endif()

      endforeach()
    endif()
  endforeach()


endfunction()

# File: source/ast/language_load.cmake

function(language_load definition_file)
  if(NOT EXISTS "${definition_file}")
    creturn()
  endif()
  json_read("${definition_file}")
  ans(language)
  string(MD5 hash "${data}")
  map_set(${language} md5 "${hash}")
 # address_print(${language})
  if(NOT language)
    creturn()
  endif()
  language_initialize(${language})

  return_ref(language)
endfunction()


# File: source/ast/make_symbol.cmake


function(make_symbol)
  address_get(symbol_count)
  ans(i)
  if(NOT i)
    function(make_symbol)
      address_get(symbol_count )
      ans(i)
      math(EXPR i "${i} + 1")
      address_set(symbol_count "${i}")
      creturn("symbol_${i}_${symbol_cache_key}")
    endfunction()
    address_set(symbol_count 1)
    creturn(symbol_1)
  endif()
  message(FATAL_ERROR "make_symbol")
 endfunction()

# File: source/ast/script.cmake

function(script str)


  map_new()
  ans(expression_cache)
  map_set(global expression_cache ${expression_cache})
  function(script str)
    language("oocmake")
    ans(lang)
    if(NOT lang)
      #cmakepp_config(base_dir)
      #ans(base_dir)

      #language("${base_dir}/resources/expr.json")
      expr_definition()
      ans(lang)
      language("${lang}")
      ans(lang)

    endif()
    map_tryget("${lang}" md5)
    ans(language_hash)
    string(MD5 script_language_hash "${str}${language_hash}")  
    cmakepp_config(temp_dir)
    ans(temp_dir)
    set(obj_file "${temp_dir}/expressions/expr_${script_language_hash}.cmake")
    map_tryget(global expression_cache)
    ans(expression_cache)

    map_tryget(${expression_cache} "${script_language_hash}")
    ans(symbol)
    if(symbol)

    elseif(EXISTS "${obj_file}")
      include("${obj_file}")
      ans(symbol)
      map_set(${expression_cache} "${script_language_hash}" "${symbol}")
    else()
#      echo_append("compiling expression to ${obj_file} ...")
      map_new()
      ans(context)

      map_new(scope)
      ans(scope)

      map_set(${context} scope "${scope}")
      map_set(${context} cache_key "${script_language_hash}")
      set(symbol_cache_key "${script_language_hash}")
      ast("${str}" oocmake "")
      ans(ast)

      ast_eval(${ast} ${context} ${lang})
      ans(symbol)
      string(REPLACE "\"" "\\\"" escaped "${symbol}")
      string(REPLACE "$" "\\$" escaped "${escaped}")
      map_tryget(${context} code)
      ans(code)
 #     message("done")
      file(WRITE "${obj_file}" "${code}\nset(__ans \"${escaped}\")")
      if(code)
        set_ans("")
        eval("${code}")
      endif()

    endif()

  is_map("${global}" )
    ans(ismap)
    if(NOT ismap)
      map_new()
      ans(global)
    endif()
    set_ans("")
    eval("${symbol}")
    ans(res)

    if(NOT ismap)

      map_promote(${global})
    endif()
    return_ref(res)
  endfunction()
  script("${str}")
  return_ans()
endfunction()

# File: source/ast/token_definitions.cmake

# returns the token definitions of a language 
function(token_definitions language)
  map_get(${language}  definitions)
  ans(definitions)
  map_keys(${definitions} )
  ans(keys)
  set(token_definitions)
  foreach(key ${keys})
    map_get(${definitions}  ${key})
    ans(definition)
    map_tryget(${definition}  parser)
    ans(parser)
    if("${parser}" STREQUAL "token")
      map_set(${definition} name "${key}")
      map_tryget(${definition}  regex)
      ans(regex)
      if(regex)
        map_set(${token_definition} regex "${regex}")
      else()
        map_tryget(${definition}  match)
        ans(match)
        string_regex_escape("${match}")
        ans(match)
        map_set(${definition} regex "${match}")
      endif()
      list(APPEND token_definitions ${definition})
    endif()
  endforeach()
  return_ref(token_definitions)
endfunction()

# File: source/ast/token_new.cmake

  function(token_new definition data)
    map_tryget(${definition}  ignore_token)
    ans(ignore_token)
    if(ignore_token)
      creturn()
    endif()
    map_new()
    ans(token)
    map_set(${token} definition ${definition})
    map_set(${token} data "${data}")
    return_ref(token)
  endfunction()

# File: source/ast/token_stream_commit.cmake


  function(token_stream_commit stream)
    map_get(${stream}  stack)
    ans(stack)
    stack_pop(${stack})
  endfunction()

# File: source/ast/token_stream_isempty.cmake


  function(token_stream_isempty stream)
    map_tryget(${stream}  current)
    ans(current)
    if(current)
      creturn(false)
    endif()
    creturn(true)

  endfunction()

# File: source/ast/token_stream_move_next.cmake


  function(token_stream_move_next stream)
    map_get(${stream}  current)
    ans(current)
    map_tryget(${current}  next)
    ans(next)
    map_set(${stream} current ${next})
   # message(FORMAT "moved from {current.data} to {next.data}")
  endfunction()

# File: source/ast/token_stream_new.cmake


  function(token_stream_new language str)
    map_get(${language}  token_definitions)
    ans(token_definitions)
   # messagE("new token strean ${token_definitions}")

    #address_print(${language})

    tokens_parse("${token_definitions}" "${str}")
    ans(tokens)
    map_new()
    ans(stream)
    map_set(${stream} current ${tokens})
    stack_new()
    ans(stack)
    map_set(${stream} stack ${stack})
    map_set(${stream} first ${tokens})
    return_ref(stream)
  endfunction()


# File: source/ast/token_stream_pop.cmake


  function(token_stream_pop stream)
    map_get(${stream}  stack)
    ans(stack)
    stack_pop(${stack})
    ans(current)
    map_set(${stream} current ${current})
  #  message(FORMAT "popped to {current.data}")
  endfunction()

# File: source/ast/token_stream_push.cmake


  function(token_stream_push stream)
    map_get(${stream}  stack)
    ans(stack)
    map_tryget(${stream}  current)
    ans(current)
    stack_push(${stack} ${current})

   # message("pushed")
  endfunction()

# File: source/ast/token_stream_take.cmake


  function(token_stream_take stream token_definition)
   # message(FORMAT "trying to take {token_def_or_name.name}")
    map_tryget(${stream}  current)
    ans(current)
    if(NOT current)
      creturn()
    endif()
#    message(FORMAT "current token '{current.data}'  is a {current.definition.name}, expected {definition.name}")
    
    map_tryget(${current}  definition)
    ans(definition)
    
    if(${definition} STREQUAL ${token_definition})
   
      map_tryget(${current}  next)
      ans(next)
      map_set_hidden(${stream} current ${next})
      creturn(${current})
    endif()
    creturn()
  endfunction()

# File: source/ast/tokens_parse.cmake

# parses str into a linked list of tokens 
# using token_definitions
function(tokens_parse token_definitions str)
  map_new()
  ans(first_token)
  set(last_token ${first_token})
  while(true) 
    # recursion anker
    string_isempty( "${str}")
    ans(isempty)
    if(isempty)
      map_tryget(${first_token}  next)
      ans(first_token)
      creturn(${first_token})
    endif()

    set(token)
    set(ok)
    foreach(token_definition ${token_definitions})
      map_tryget(${token_definition}  regex)
      ans(regex)
    #  message("trying ${regex} with '${str}'")
      #set(match)
      string(REGEX MATCH "^(${regex})" match "${str}")
      list(LENGTH match len)
      if("${len}" GREATER 0)
        map_tryget(${token_definition} except)
        ans(except)
        list(LENGTH except hasExcept)
        if(NOT hasExcept OR NOT "_${match}" MATCHES "_(${except})")

          #message(FORMAT "matched {token_definition.name}  match: '${match}' ")
          #message("stream ${str}")     
          string(LENGTH "${match}" len)
          string(SUBSTRING "${str}" "${len}" -1 str)
          token_new(${token_definition} "${match}")
          ans(token)
     #     message(FORMAT "token {token_definition.regex} matches ${match}")
          set(ok true)
          break()
        endif()
      endif()
    endforeach()

    if(NOT ok)
#      message("failed - not a token  @ ...${str}")
      creturn()
    endif()

    if(token)
      if(last_token)
        map_set(${last_token} next ${token})
      endif()
      set(last_token ${token})
    endif()
  endwhile()

endfunction()

# File: source/cache/cache_clear.cmake



  function(cache_clear cache_key)
    memory_cache_clear("${cache_key}")
    file_cache_clear("${cache_key}")

  endfunction()

# File: source/cache/cache_exists.cmake



  function(cache_exists cache_key)
    memory_cache_exists("${cache_key}")
    ans(res)
    if(res)
      return_ref(res)
    endif()
    file_cache_exists("${cache_key}")
    ans(res)
    return_ref(res)
  endfunction()


# File: source/cache/cache_get.cmake


  function(cache_get cache_key)
    memory_cache_get("${cache_key}")
    ans(res)
    if(res)
      return_ref(res)
    endif()
    file_cache_get("${cache_key}")
    ans(res)
    if(res)
      memory_cache_update("${cache_key}" "${res}")
      return_ref(res)
    endif()
  endfunction()

# File: source/cache/cache_return_hit.cmake


macro(cache_return_hit cache_key)
  cache_get("${cache_key}")
  ans(__cache_return)
  if(__cache_return)
    return_ref(__cache_return)
  endif()
endmacro()



# File: source/cache/cache_update.cmake


  function(cache_update cache_key value)
    memory_cache_update("${cache_key}" "${value}" ${ARGN})
    file_cache_update("${cache_key}" "${value}" ${ARGN})
  endfunction()

# File: source/cache/dir_cache.cmake



  function(cached retrieve refresh compute_key)
    set(args ${ARGN})
    list_extract_flag(args --refresh)
    ans(refresh_cache)

    if(compute_key STREQUAL "")
      string_combine("_" ${args})
      ans(cache_key)
      string(MD5 "${cache_key}" cache_key)
    else()
      call("${compute_key}"(${args}))
      ans(cache_key)
    endif()
    
    cmakepp_config(temp_dir)
    ans(temp_dir)

    set(cache_dir "${temp_dir}/dir_cache/${cache_key}")
    if(EXISTS "${cache_dir}" NOT refresh_cache)
      call("${retrieve}"(args))
      return_ans()
    endif()

    pushd("${cache_dir}" --create)
    call("${refresh}"(args))
    ans(result)
    popd()

    if(NOT result)
      rm("${cache_dir}")
      creturn()
    endif()

    call("${retrieve}"(args))
    ans(result)

    return_ref(result)
  endfunction()

# File: source/cache/file_cache_clear.cmake



function(file_cache_clear cache_key)
  file_cache_key("${cache_key}")
  ans(path)
  if(EXISTS "${path}")
    file(REMOVE "${path}")
  endif()
  creturn()
endfunction()

# File: source/cache/file_cache_clear_all.cmake


function(file_cache_clear_all)
  cmakepp_config(temp_dir)
  ans(temp_dir)
  file(REMOVE_RECURSE "${temp_dir}/file_cache")
endfunction()

# File: source/cache/file_cache_exists.cmake



function(file_cache_exists cache_key)
  file_cache_key("${cache_key}")
  ans(path)
  if(EXISTS "${path}")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/cache/file_cache_get.cmake



function(file_cache_get cache_key)
  file_cache_key("${cache_key}")
  ans(path)
  if(EXISTS "${path}")
    qm_deserialize_file("${path}")
    return_ans()
  endif()
  creturn()
endfunction()

# File: source/cache/file_cache_key.cmake


function(file_cache_key cache_key)
  is_address("${cache_key}")
  ans(isref)
  if(isref)
    json("${cache_key}")
    ans(cache_key)
  endif()
  checksum_string("${cache_key}")
  ans(key)
  cmakepp_config(temp_dir)
  ans(temp_dir)
  set(file "${temp_dir}/file_cache/_${key}.cmake")
  return_ref(file)
endfunction()

# File: source/cache/file_cache_return_hit.cmake



macro(file_cache_return_hit cache_key)
  file_cache_get("${cache_key}")
  ans(__cache_return)
  if(__cache_return)
    return_ref(__cache_return)
  endif()

endmacro()

# File: source/cache/file_cache_update.cmake



function(file_cache_update cache_key)
  file_cache_key("${cache_key}")
  ans(path)
  qm_serialize("${ARGN}")
  ans(ser)
  file(WRITE "${path}" "${ser}")
  creturn()
endfunction()


# File: source/cache/memory_cache_clear.cmake


function(memory_cache_clear cache_key)
  memory_cache_key("${cache_key}")
  ans(key)
  map_set_hidden(memory_cache_entries "${key}")
  creturn()
endfunction()

# File: source/cache/memory_cache_exists.cmake

function(memory_cache_exists cache_key)
  memory_cache_key("${cache_key}")
  ans(key)
  map_tryget(memory_cache_entries "${key}")
  ans(entry)
  if(entry)
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/cache/memory_cache_get.cmake



  function(memory_cache_get cache_key)
    set(args ${ARGN})
    list_extract_flag(args --const)
    ans(isConst)

    memory_cache_key("${cache_key}")
    ans(key)
    map_tryget(memory_cache_entries "${key}")
    ans(value)
    if(NOT isConst)
      map_clone_deep("${value}")
      ans(value)
    endif()
#    
    return_ref(value)
  endfunction()


  

# File: source/cache/memory_cache_key.cmake


  function(memory_cache_key cache_key)
    is_address("${cache_key}")
    ans(isref)
    if(isref)
      json("${cache_key}")
      ans(cache_key)
    endif()
 #  message("ck ${cache_key}")
    return_ref(cache_key)
  endfunction()

# File: source/cache/memory_cache_return_hit.cmake


macro(memory_cache_return_hit cache_key)
  memory_cache_get("${cache_key}")
  ans(__cache_return)
  if(__cache_return)
    return_ref(__cache_return)
  endif()
endmacro()

# File: source/cache/memory_cache_update.cmake



  function(memory_cache_update cache_key value)
    set(args ${ARGN})
    list_extract_flag(args --const)
    ans(isConst)
    if(NOT isConst)
        map_clone_deep("${value}")
        ans(value)
    endif()

    memory_cache_key("${cache_key}")
    ans(key)
    
    map_set_hidden(memory_cache_entries "${key}" "${value}")
  endfunction()

# File: source/cache/string_cache_get.cmake

function(string_cache_get cache_location key)
  string_cache_location("${cache_location}" "${key}")
  ans(location)
  if(NOT EXISTS "${location}")
    creturn()
  endif()
  fread("${location}/value.txt")
  return_ans()
endfunction()


# File: source/cache/string_cache_hit.cmake


function(string_cache_hit cache_location key)
  string_cache_location("${cache_location}" "${key}")
  ans(location)
  return_truth(EXISTS "${location}")
endfunction()

# File: source/cache/string_cache_location.cmake


function(string_cache_location cache_location key)
  cmakepp_config(temp_dir)
  ans(cache_dir)
  path_qualify_from("${cache_dir}" "${cache_location}/${key}")
  ans(location)
  return_ref(location)
endfunction()

# File: source/cache/string_cache_return_hit.cmake


macro(string_cache_return_hit cache_location key)
  string_cache_hit("${cache_location}" "${key}")
  ans(hit)
  if( hit)
    string_cache_get("${cache_location}" "${key}")
    return_ans()
  endif()
endmacro()  


# File: source/cache/string_cache_update.cmake


function(string_cache_update cache_location key value)
  string_cache_location("${cache_location}" "${key}")
  ans(location)
  if(NOT EXISTS "${location}")
    fwrite("${location}/value.txt" "${value}")
    creturn(true)
  else()
    fwrite("${location}/value.txt" "${value}")
    creturn(false)
  endif()
endfunction()


# File: source/checksum/checksum_dir.cmake

## `(<direcotry> [--algorthm <checksum algorithm> = "MD5"])-><checksum>`
##
## calculates the checksum for the specified directory 
## just like checksum_layout however also factors in the file's contents
## 
function(checksum_dir dir)
  set(args ${ARGN})
  list_extract_labelled_keyvalue(args --algorithm)
  ans(algorithm)

  path_qualify(dir)
  file(GLOB_RECURSE files RELATIVE "${dir}" "${dir}/**")
  if(args)
    list(REMOVE_ITEM files ${ARGN})
  endif()
  checksum_files("${dir}" ${files} ${algorithm})
  return_ans()
endfunction()




# File: source/checksum/checksum_file.cmake

## `(<file> [--algorithm <checksum algorithm> = "MD5"])-><checksum>`
##
## calculates the checksum for the specified file delegates the
## call to `CMake`'s file(<algorithm>) function
## 
function(checksum_file file)

  path_qualify(file)

  set(args ${ARGN})
  list_extract_labelled_value(args --algorithm)
  ans(checksum_alg)
  if(NOT checksum_alg)
    set(checksum_alg MD5)
  endif()
  file(${checksum_alg} "${file}" checksum)
  return_ref(checksum)
endfunction()




# File: source/checksum/checksum_files.cmake

## `(<base dir> <file...>)-><checksum>`
##
## create a checksum from specified files relative to <dir>
## the checksum is influenced by the files relative paths 
## and the file content 
## 
function(checksum_files dir)
  set(args ${ARGN})
  list_extract_labelled_keyvalue(args --algorithm)
  ans(algorithm)

  list(LENGTH args len)
  if(len)
    list(REMOVE_DUPLICATES args)
    list(SORT args)
  endif()
  
  set(checksums)
  foreach(file ${ARGN})
    if(EXISTS "${dir}/${file}")
      if(NOT IS_DIRECTORY "${dir}/${file}")
        checksum_file("${dir}/${file}" ${algorithm})
        ans(file_checksum)
        # create checksum from file checsum and file name
        checksum_string("${file_checksum}.${file}" ${algorithm})
        ans(combined_checksum)
        list(APPEND checksums "${combined_checksum}")
      endif()
    endif()
  endforeach()

  checksum_string("${checksums}" ${checksum_alg})
  ans(checksum_dir)
  return_ref(checksum_dir)
endfunction()

# File: source/checksum/checksum_glob_ignore.cmake

## `(<glob ignore expressions...> [--algorithm <hash algorithm> = "MD5"])-><checksum>`
## 
## calculates the checksum for the specified glob ignore expressIONS
## uses checksum_files internally. the checksum is unique to file content
## and relative file structure
## 
function(checksum_glob_ignore)
    set(args ${ARGN})
    list_extract_labelled_keyvalue(args --algorithm)
    ans(algorithm)
    glob_ignore(${args})
    ans(files)


    pwd()
    ans(pwd)
    set(normalized_files)
    foreach(file ${files})
        path_qualify(file)
        path_relative("${pwd}" "${file}")
        ans(file)
        list(APPEND normalized_files ${file})      
    endforeach()



    checksum_files("${pwd}" ${normalized_files})
    return_ans()
endfunction()

# File: source/checksum/checksum_layout.cmake

## `(<directory> [--algorithm <hash algorithm> "MD5"])-><checksum>`
## 
## this method generates the checksum for the specified directory
## it is done by taking every file's relative path into consideration
## and generating the hash.  The file's content does not influence the hash
## 
function(checksum_layout dir)
    path_qualify(dir)

    set(args ${ARGN})

    list_extract_labelled_keyvalue(args --algorithm)
    ans(algorithm)

    file(GLOB_RECURSE files RELATIVE "${dir}" "${dir}/**")

    if(files)
        ## todo sort. normalize paths, remove directories
        string(REPLACE "//" "/" files "${files}")
        list(SORT files)
    endif()
    
    checksum_string("${files}" ${algorithm})
    ans(checksum_dir)

    return_ref(checksum_dir)
endfunction()



# File: source/checksum/checksum_object.cmake

## `(<any> [--algorithm <hash algorithm> = "MD5"])-><checksum>`
##
## this function takes any value and generates its hash
## the difference to string hash is that it serializes the specified object 
## which lets you create the hash for the whoile object graph.  
## 
function(checksum_object obj)
  json("${obj}")
  ans(json)
  checksum_string("${json}" ${ARGN})
  return_ans()
endfunction()

# File: source/checksum/checksum_string.cmake

## `(<string> [--algorithm <hash algorithm> = MD5])-><checksum>`
## `<hash algorithm> ::= "MD5"|"SHA1"|"SHA224"|"SHA256"|"SHA384"|"SHA512"`
##
## this function takes any string and computes the hash value of it using the 
## hash algorithm specified (which defaults to  MD5)
## returns the checksum
## 
function(checksum_string str)
  set(args ${ARGN})
  list_extract_labelled_value(args --algorithm)
  ans(algorithm)
  if(NOT algorithm)
    set(algorithm MD5)
  endif()
  string("${algorithm}"  checksum "${str}" )
  return_ref(checksum)
endfunction()

# File: source/checksum/content_dir_check.cmake


  function(content_dir_check dir )
    set(file_name ${ARGN})
    if(NOT file_name)
      set(file_name "cache-key.cmakepp")
    endif()

    path("${dir}/${file_name}")
    ans(cache_key_path)

    if(NOT EXISTS "${cache_key_path}")
      creturn(false)
    endif()

    fread("${cache_key_path}")
    ans(expected_checksum)
    pushd("${dir}")
    checksum_glob_ignore(** "!${file_name}" --recurse)
    ans(actual_checksum)
    popd()

    if(NOT "${expected_checksum}_" STREQUAL "${actual_checksum}_")
      creturn(false)
    endif()


    creturn(true)
  endfunction()
    

# File: source/checksum/content_dir_update.cmake



  function(content_dir_update dir)
    set(file_name "${ARGN}")
    if(NOT file_name)
      set(file_name "cache-key.cmakepp")
    endif()

    path("${dir}/${file_name}")
    ans(cache_key_path)

    pushd("${dir}")
    checksum_glob_ignore(** "!${file_name}" --recurse)
    ans(actual_checksum)
    popd()

    fwrite("${cache_key_path}" "${actual_checksum}")



    return_ref(actual_checksum)
  endfunction()


# File: source/classes/Object.cmake

function(Object)
	#formats the current object 
	proto_declarefunction(to_string)

	function(${to_string} )
		set(res)
#		debug_message("to_string object ${this}")
		obj_keys(${this} keys)

		foreach(key ${keys})
			obj_get(${this}  ${key})				
			ans(value)
			map_has(${this}  ${key})
			ans(is_own)	
			if(value)
				is_function(function_found ${value})
				is_object(object_found ${value})
			endif()
			
			
			if(function_found)
				set(value "[function]")
			elseif(object_found)
				get_filename_component(fn ${value} NAME_WE)
				obj_gettype(${value} )
				ans(type)
				if(NOT type)
					set(type "")
				endif()
				set(value "[object ${type}:${fn}]")
			else()
				set(value "\"${value}\"")
			endif()
			if(is_own)
				set(is_own "*")
			else()
				set(is_own " ")
			endif()

			set(nextValue "${is_own}${key}: ${value}")

			if(res)
				set(res "${res}\n ${nextValue}, ")	
			else()
				set(res " ${nextValue}, ")
			endif()
		endforeach()

		set(res "{\n${res}\n}")
		return_ref(res)
	endfunction()

	# prints the current object to the console
	proto_declarefunction(print)
	function(${print})
		#debug_message("printing object ${this}")
		obj_member_call(${this} "to_string" str )
		message("${str}")
	endfunction()
endfunction()




# File: source/cmake/ast/cmake_ast.cmake

## `(<ast: <cmake code> |<cmake ast>>)-><cmake ast>`
##
## tries to parse the cmake code to an ast or returns the existign ast
function(cmake_ast ast)
  is_address("${ast}")
  ans(isref)
  if(NOT isref)
    cmake_ast_parse("${ast}")
    ans(ast)
  endif()
  return_ref(ast)
endfunction()



# File: source/cmake/ast/cmake_ast_function_parse.cmake

function(cmake_ast_function_parse target end)
  map_tryget(${end} value)
  ans(value)
  
  if(NOT "${value}" MATCHES "^(endfunction)|(endmacro)$")
    creturn()
  endif()
  map_tryget(${end} invocation_nesting_begin)
  ans(begin)

  map_tryget(${begin} value)
  ans(command_type)


  ## get name token and name
  cmake_token_range_find_next_by_type(${begin} "(unquoted_argument)|(quoated_argument)")
  ans(name_token)
  map_tryget(${name_token} literal_value)
  ans(name)

  ## next after name is the beginning of the signature
  map_tryget(${name_token} next)
  ans(signature_begin)

  ## next->end is the closing parentheses
  map_tryget(${begin} next)
  ans(parens)
  map_tryget(${parens} end)
  ans(signature_end) ## the closing paren

  ## get the beginning and end of the body
  ## body begins directly after signature
  map_tryget(${signature_end} next)
  ans(body_begin)

  ## body ends directly before endfunction/endmacro
  set(body_end ${end})
  

  ## set the extracted vars
  map_set(${begin} command_type "${command_type}")  
  map_set(${begin} invocation_type command_definition)
  map_set(${begin} name_token ${name_token})
  map_set(${begin} name "${name}")
  map_set(${begin} signature_begin ${signature_begin})
  map_set(${begin} signature_end ${signature_end})
  map_set(${begin} body_begin ${body_begin}) 
  map_set(${begin} body_end ${body_end})

  ## 
  map_append(${target} command_definitions ${begin})
  map_set(${target} "command-${name}" ${begin})
  return_ref(begin)

endfunction()


# File: source/cmake/ast/cmake_ast_nesting_pair_map.cmake

## `()->{ <<identifier open>:<identifier close>...>... }`
##
## returns a map which contains all nesting pairs in cmake
function(cmake_ast_nesting_pairs)
  map_new()
  ans(nesting_start_end_pairs)
  map_set(${nesting_start_end_pairs} function endfunction)
  map_set(${nesting_start_end_pairs} while endwhile)
  map_set(${nesting_start_end_pairs} if elseif else endif)
  map_set(${nesting_start_end_pairs} elseif elseif else endif)
  map_set(${nesting_start_end_pairs} else endif)
  map_set(${nesting_start_end_pairs} macro endmacro)
  map_set(${nesting_start_end_pairs} foreach endforeach)
 
 return_ref(nesting_start_end_pairs)
endfunction()

# File: source/cmake/ast/cmake_ast_parse.cmake

## `(<code:<cmake code>|<cmake token...>>)-><cmake ast>`
##
## generates the an ast for the cmake code 
function(cmake_ast_parse code)
  cmake_ast_nesting_pairs()
  ans(nesting_start_end_pairs)
  
  map_values(${nesting_start_end_pairs})
  ans(endings)
  map_keys(${nesting_start_end_pairs})
  ans(openings)
  list_remove_duplicates(endings)

  cmake_tokens("${code}")
  ans(tokens)

  ans_extract(current_invocation)

  map_new()
  ans(ast)

  map_set(${ast} tokens ${tokens})

  ## push the first nesting on the nestings stack
  set(nestings "${ast}")
  set(current_nesting ${ast})

  while(true)
    cmake_token_range_find_next_by_type("${current_invocation}" command_invocation)
    ans(current_invocation)
    if(NOT current_invocation)
      break()
    endif()
    
    
    map_append(${current_nesting} command_invocations ${current_invocation})
    map_tryget(${current_invocation} value)
    ans(invocation_value)

    list_contains(openings ${invocation_value})
    ans(is_opening)
    list_contains(endings ${invocation_value})
    ans(is_closing)

    ## handles the closing of an invocation nesting
    if(is_closing)
      set(begin "${current_nesting}")
      set(end "${current_invocation}")

      ## pop the top nesting
      list(REMOVE_AT nestings 0)
      list(GET nestings 0 current_nesting)

      if("${begin}" STREQUAL "${root_nesting}")  
        message(FORMAT "unbalanced code nesting for {current_invocation.value} @{current_invocation.line}:{current_invocation.column}")
        error( "unbalanced code nesting for {current_invocation.value} @{current_invocation.line}:{current_invocation.column}")
        creturn()
      endif()


      map_tryget(${begin} value)
      ans(begin_value)
      set(end_value ${invocation_value})

      map_tryget(${nesting_start_end_pairs} ${begin_value})
      ans(current_closings)
      
      list_contains(current_closings ${end_value})
      ans(correct_closing)
      if(NOT correct_closing)
        message(FORMAT "invalid closing for opening '{current_nesting.value}' @{current_nesting.line}:{current_nesting.column}: '{current_invocation.value}' @{current_invocation.line}:{current_invocation.column}")
        error("invalid closing for {current_invocation.value} @{current_invocation.line}:{current_invocation.column}")
        creturn()
      endif()
            
      map_set(${begin} invocation_nesting_end ${end})
      map_set(${end} invocation_nesting_begin ${begin})
    endif()
    list(LENGTH nestings nesting_depth)
    math(EXPR nesting_depth "${nesting_depth} - 1")
    map_set(${current_invocation} invocation_nesting_depth ${nesting_depth})
    cmake_ast_function_parse("${current_nesting}" "${current_invocation}")
    cmake_ast_variable_parse("${current_nesting}" "${current_invocation}")
    map_append(${current_nesting} children ${current_invocation})

    ## handles the opening of an invocation nesting
    if(is_opening)
      ## push the the current_invocation nesting
      list(INSERT nestings 0 ${current_invocation})
      set(current_nesting ${current_invocation})
    endif()

    map_tryget(${current_invocation} next)
    ans(current_invocation)
  endwhile()

  return_ref(ast)
endfunction()

# File: source/cmake/ast/cmake_ast_serialize.cmake


  function(cmake_ast_serialize ast)
    cmake_ast("${ast}")
    ans(ast)
    assign(start = ast.tokens[0])
    assign(end = ast.tokens[$])
    cmake_token_range_serialize("${start};${end}")
    return_ans()
  endfunction()


# File: source/cmake/ast/cmake_ast_variable_parse.cmake



function(cmake_ast_variable_parse target invocation_token)
  map_tryget(${invocation_token} value)
  ans(value)
  if(NOT "${value}" STREQUAL "set")
    creturn()
  endif()
  ## get first name token inside invocation_token
  cmake_token_range_find_next_by_type(${invocation_token} "(unquoted_argument)|(quoated_argument)")
  ans(name_token)

  ## get the value of the name token
  map_tryget(${name_token} literal_value)
  ans(name)

  ## get the beginning of values 
  ## the first token after name 
  map_tryget(${name_token} next)
  ans(values_begin)
  ## get the ending of values
  ## the ) 
  cmake_token_range_find_next_by_type(${invocation_token} "(nesting)")
  ans(nesting)
  map_tryget(${nesting} end)
  ans(values_end)
  
  ## set the values
  map_set(${invocation_token} invocation_type variable)
  map_set(${invocation_token} name_token ${name_token})
  map_set(${invocation_token} name ${name})
  map_set(${invocation_token} values_begin ${values_begin})
  map_set(${invocation_token} values_end ${values_end})


  ## add the the variables to the target map
  map_append(${target} variables ${invocation_token})
  map_set(${target} "variable-${name}" ${invocation_token})
endfunction()

# File: source/cmake/cmake_arguments_quote_if_necessary.cmake

## `(<any>...)-><cmake escaped>...`
##
## quotes all arguments which need quoting ## todo allpw encoded lists
function(cmake_arguments_quote_if_necessary)
  regex_cmake()
  set(result)
  foreach(arg ${ARGN})
    if("_${arg}" MATCHES "_${regex_cmake_value_needs_quotes}")
      string(REGEX REPLACE 
        "${regex_cmake_value_quote_escape_chars}" 
        "\\\\\\0" #prepends a '\' before each matched cahr 
        arg "${arg}"
        )
    endif()
    set(arg "\"${arg}\"")

    list(APPEND result "${arg}")
    
  endforeach()
  return_ref(result)
endfunction()


# File: source/cmake/cmakelists/cmakelists_cli.cmake

## `([-v])-><any...>`
##
## the comand line interface to cmakelists.  tries to find the CMakelists.txt in current or parent directories
## if init is specified a new cmakelists file is created in the current directory
## *flags*:
##  * 
## *commands*:
##  * `init` saves an initial cmake file at the current location
##  * `target <target name> <target command> | "add" <target name>` target commands:
##    * `add` adds the specified target to the end of the cmakelists file
##    * `sources "append"|"set"|"remove" <glob expression>...` adds appends,sets, removes the source files specified by glob expressions to the specified target
##    * `includes "append"|"set"|"remove" <path>....` adds the specified directories to the target_include_directories of the specified target
##    * `links "append"|"set"|"remove" <target name>...` adds the specified target names to the target_link_libraries of the specified target
##    * `type <target type>` sets the type of the specified target to the specified target type
##    * `rename <target name>` renames the specified target 
## 
## `<target type> ::= "library"|"executable"|"custom_target"|"test"`  
function(cmakelists_cli)
  set(args ${ARGN})
  list_pop_front(args)
  ans(command)

  list_extract_flags(args -v)
  ans(verbose)

  set(handler)
  if(verbose)
    event_addhandler(on_log_message "[](entry) message(FORMAT '{entry.function}: {entry.message}') ")
  endif()
  cmakelists_open("")
  ans(cmakelists)

  if(NOT cmakelists AND "${command}" STREQUAL "init")
    path_parent_dir_name(CMakeLists.txt)
    ans(project_name)
    cmakelists_new("cmake_minimum_required(VERSION ${CMAKE_VERSION})\n\nproject(${project_name})\n\n")
    ans(cmakelists)
  elseif(NOT cmakelists)
    error("no CMakeLists.txt file found in current or parent directories" --function cmakelists_cli)
    creturn()
  elseif("${command}" STREQUAL "init")
    cmakelists_new("cmake_minimum_required(VERSION ${CMAKE_VERSION})")
    ans(cmakelists)
  endif()

  
  set(save false)
  if("${command}" STREQUAL "init")
    set(save true)
  elseif("${command}" STREQUAL "target")
    list_pop_front(args)
    ans(target_name)

    list_pop_front(args)
    ans(command)

    if("${target_name}" STREQUAL "add")
      set(target_name "${command}")
      set(command add)
    endif()

    if(NOT command)
      cmakelists_targets(${cmakelists} ${target_name})
      ans(result)
    elseif("${command}" STREQUAL "rename")
      list_pop_front(args)
      ans(name)
      cmakelists_target(${cmakelists} "${target_name}")
      ans(target)
      if(NOT target)
          message(FATAL_ERROR FORMAT "no single target found for ${target_name} in {cmakelists.path}")
      endif()
      map_set(${target} target_name "${name}")
      cmakelists_target_update("${cmakelists}" "${target}")
      set(save true)
      set(result ${target})

    elseif("${command}" STREQUAL "type")
      list_pop_front(args)
      ans(type)
      cmakelists_target(${cmakelists} "${target_name}")
      ans(target)
      if(NOT target)
          message(FATAL_ERROR "no single target found for ${target_name}")
      endif()
      map_set(${target} target_type "${type}")
      cmakelists_target_update("${cmakelists}" "${target}")
      set(save true)
      set(result ${target})

    elseif("${command}" STREQUAL add)
      list_extract(args target_type)
      set(save true)
      if(NOT target_type)
          set(target_type library)
      endif()
      map_capture_new(target_name target_type)
      ans(result)
      cmakelists_target_update(${cmakelists} ${result})
    elseif("${command}" STREQUAL "includes")
      cmakelists_target(${cmakelists} "${target_name}")
      ans(target)
      if(NOT target)
          message(FATAL_ERROR "no single target found for ${target_name}")
      endif()

      list_pop_front(args)
      ans(command)

      map_tryget(${target} target_include_directories)
      ans(result)
      if(command)
          set(flag "--${command}")
          set(before ${result})
          cmakelists_paths("${cmakelists}" ${args})
          ans(args)
          list_modify(result ${flag} --remove-duplicates --sort ${args})
          set(save true) 
          map_set(${target} target_include_directories PUBLIC ${result})
          cmakelists_target_update(${cmakelists} ${target})
      endif()
    elseif("${command}" STREQUAL "links")
      cmakelists_target(${cmakelists} "${target_name}")
      ans(target)
      if(NOT target)
          message(FATAL_ERROR "no single target found for ${target_name}")
      endif()

      list_pop_front(args)
      ans(command)

      map_tryget(${target} target_link_libraries)
      ans(result)
      if(command)
          set(flag "--${command}")
          set(before ${result})
          list_modify(result ${flag} --remove-duplicates ${args})

          set(save true)
          map_set(${target} target_link_libraries ${result})
          cmakelists_target_update(${cmakelists} ${target})
                          
      endif()
    elseif("${command}" STREQUAL "sources")

      cmakelists_target(${cmakelists} "${target_name}")
      ans(target)
      if(NOT target)
          message(FATAL_ERROR "no single target found for ${target_name}")
      endif()

      list_pop_front(args )
      ans(command)

      map_tryget(${target} target_source_files)
      ans(result)
      if(command)
          set(flag "--${command}")
          set(before ${result})
          cmakelists_paths(${cmakelists} ${args} --glob)
          ans(args)
          list_modify(result ${flag} --remove-duplicates ${args})

          set(save true)
          map_set(${target} target_source_files ${result})
          cmakelists_target_update(${cmakelists} ${target})
                          
      endif()

    endif()

  endif()

  if(save)

    cmakelists_close(${cmakelists})
  endif()
  return_ref(result)
endfunction()




function(cmakelists_target_modify cmakelists target target_property)
  set(args ${ARGN})
  cmakelists_target("${cmakelists}" "${target}")
  ans(target)
  if(NOT target)
    creturn()
  endif()
  
  list_pop_front(args)
  ans(command)

  map_tryget(${target} "${target_property}")
  ans(result)
  
  if(command)
    set(flag "--${command}")
    list_modify(result ${flag} --remove-duplicates ${args})
    print_vars(result command args target.target_name target_property)
    map_set(${target} "${target_property}" ${result})
    cmakelists_target_update(${cmakelists} ${target})
  endif()        
  return_ref(result)
endfunction()

# File: source/cmake/cmakelists/cmakelists_close.cmake

## `(<cmakelists>)-> <bool>`
##
## closes the specified cmakelists file.  This causes it to be written to its path
## returns true on success
function(cmakelists_close cmakelists) 
  map_tryget(${cmakelists} path)
  ans(cmakelists_path)
  cmakelists_serialize("${cmakelists}")
  ans(content)
  fwrite("${cmakelists_path}" "${content}")
  creturn(true)
endfunction()

# File: source/cmake/cmakelists/cmakelists_new.cmake

  function(cmakelists_new source)
    set(cmakelists_path "${ARGN}")
    if(NOT cmakelists_path)
        set(cmakelists_path .)
    endif()
    if(NOT "${cmakelists_path}" MATCHES "CMakeLists\\.txt$")
        set(cmakelists_path "${cmakelists_path}/CMakeLists.txt")
    endif()
    path_qualify(cmakelists_path)

    map_new()
    ans(cmakelists)

    cmake_token_range("${source}")

    ans_extract(begin end)    
    map_set(${cmakelists} begin ${begin})
    map_set(${cmakelists} end ${end} )
    map_set(${cmakelists} range ${begin} ${end})
    map_set(${cmakelists} path "${cmakelists_path}")

    return_ref(cmakelists)
  endfunction()


# File: source/cmake/cmakelists/cmakelists_open.cmake

## `([<path>])-><cmakelists>|<null>`
##
## opens a the closests cmakelists file (anchor file) found in current or parent directory
## returns nothing if no cmakelists file is found. 
function(cmakelists_open)
  file_find_anchor("CMakeLists.txt" ${ARGN})
  ans(cmakelists_path)
  if(NOT cmakelists_path)
    creturn()
  else()
    fread("${cmakelists_path}")
    ans(content)
  endif()
  cmakelists_new("${content}" "${cmakelists_path}")
  return_ans()
endfunction()

# File: source/cmake/cmakelists/cmakelists_paths.cmake

## `(<cmakelists> <file>... [--glob] )-> <relative path>...`
##
## qualifies the paths relative to the cmakelists directory 
## if `--glob` is specified then the `<file>...` will be treated
## as glob expressions
function(cmakelists_paths cmakelists)
  set(args ${ARGN})
  list_extract_flag(args --glob)
  ans(glob)

  map_tryget(${cmakelists} path)
  ans(cmakelists_path)
  path_parent_dir("${cmakelists_path}")
  ans(cmakelists_dir)
  set(files)

  if(glob)
    glob(${args})
    ans(args)
  else()
    paths(${args})
    ans(args)
  endif()
  foreach(file ${args})
    path_relative("${cmakelists_dir}" "${file}")
    ans_append(files)
  endforeach()
  return_ref(files)

endfunction()


# File: source/cmake/cmakelists/cmakelists_serialize.cmake

## `(<cmakelists>)-> <cmake code>`
##
## serializes the specified cmakelists into its textual representation.
function(cmakelists_serialize cmakelists)
  map_tryget(${cmakelists} begin)
  ans(begin)
  cmake_token_range_serialize("${begin}")
  ans(content)
  return_ref(content)
endfunction()


# File: source/cmake/cmakelists/cmakelists_target.cmake

## `(<cmakelists> <target:<target name regex>|<cmake target>)-><cmake target> v {target_invocations: <target invocations>}`
##
## tries to find the single target identified by the regex and returns it. 
## 
## ```
## <target> ::= {
##    target_name: <string>
##    target_type: "library"|"executable"|"test"|"custom_target"|...
##    target_source_files
##    target_include_directories
##    target_link_libraries
##    target_compile_definitions
##    target_compile_options
## }
## ```
function(cmakelists_target cmakelists target)
  is_address("${target}")
  ans(is_ref)
  if(is_ref)
    creturn(${target})
  endif()
  set(target_name ${target})
  cmakelists_targets("${cmakelists}" "${target_name}")
  ans(targets)
  map_values(${targets})
  ans(target)
  list(LENGTH target count)
  if(NOT "${count}" EQUAL 1)
    error("could not find single target (found {count})")
    creturn()
  endif()
  return_ref(target)
endfunction()


# File: source/cmake/cmakelists/cmakelists_target_update.cmake

## `(<cmakelists> <cmake target>)-><bool>`
## 
## updates the cmakelists tokens to reflect changes in the target
## @todo extrac functions
## 
function(cmakelists_target_update cmakelists target)
  cmakelists_target("${cmakelists}" "${target}")
  ans(target)
  if(NOT target)
    creturn(false)
  endif()

  map_tryget(${target} target_invocations)
  ans(target_invocations)

  map_tryget(${target} target_name)
  ans(target_name)
  if(NOT target_name)
    error("target name not specified" --function cmakelists_target_update)
    creturn(false)
  endif()
  
  map_tryget(${target} target_type)
  ans(target_type)

  ## target does not exist. create
  if(NOT target_invocations)
    log("adding target ${target_name} (${target_type}) to end of cmakelists file" --trace --function cmakelists_target_update)
    ## find insertion point
    map_tryget(${cmakelists} range)
    ans_extract(begin end)

    cmake_token_range_insert("${end}" "\nadd_${target_type}(${target_name})\n")
    cmakelists_target("${cmakelists}" "${target_name}")
    ans(new_target)


    map_defaults("${target}" "${new_target}")
    map_tryget(${new_target} target_invocations)
    ans(target_invocations)
    map_set_hidden(${target} target_invocations ${target_invocations})
    
  endif()

  ## sets the target type  
  map_tryget(${target_invocations} target_source_files)
  ans(target_definition_invocation)
  map_tryget(${target_definition_invocation} invocation_token)
  ans(target_definition_invocation_token)
  map_set("${target_definition_invocation_token}" value "add_${target_type}")


  map_tryget(${target_definition_invocation_token} column)
  ans(insertion_column)
  string_repeat(" " ${insertion_column})
  ans(indentation)



  foreach(current_property 
    target_source_files 
    target_link_libraries 
    target_include_directories 
    target_compile_options
    target_compile_definitions
    )


    map_tryget(${target} "${current_property}")
    ans(values)
    map_tryget(${target_invocations} "${current_property}")
    ans(invocation)
    list(LENGTH values has_values)
    if(has_values)
      if(NOT invocation)
        log("adding ${current_property} for ${target_name}" --trace --function cmakelists_target_update)
        map_tryget(${target_definition_invocation} arguments_end_token)
        ans(insertion_point)
        cmake_token_range_filter("${insertion_point}" type MATCHES "(new_line)|(eof)")
        ans_extract(insertion_point)         
        cmake_token_range_insert("${insertion_point}" "\n${indentation}${current_property}()")
        ans_extract(invocation_token)
        cmake_token_range_filter("${invocation_token}" type STREQUAL "command_invocation")
        ans_extract(invocation_token)
        map_set("${invocation_token}" "column" ${insertion_column})
      else()
        log("updating ${current_property} for ${target_name} to '${values}'" --trace --function cmakelists_target_update)
        map_tryget(${invocation} invocation_token)
        ans(invocation_token)
      endif()
      cmake_invocation_token_set_arguments("${invocation_token}" "${target_name}" ${values})

    elseif(invocation AND NOT "${current_property}"  STREQUAL "target_source_files")
      log("removing ${current_property} for ${target_name}" --trace --function cmakelists_target_update)
      ## remove invocation
      map_remove("${target_invocations}" "${current_property}")
      cmake_invocation_remove("${invocation}")
    endif()

  endforeach()    
  creturn(true)
endfunction()

# File: source/cmake/cmakelists/cmakelists_targets.cmake

## `(target_name:<regex>)-><cmake target>`
##
## returns all targets whose name match the specified regular expression
function(cmakelists_targets cmakelists target_name )
  map_tryget(${cmakelists} range)
  ans(range)
  cmake_token_range_targets_filter("${range}" "${target_name}")
  return_ans()
endfunction()

# File: source/cmake/cmakelists/cmakelists_variable.cmake

## `(<cmakelists> <variable path>)-><any>...`
## 
## see list_modify
## modifies a variable returns the value of the variable
function(cmakelists_variable cmakelists variable_path)
  map_tryget(${cmakelists} begin)
  ans(range)
  cmake_token_range_variable_navigate("${range}" "${variable_path}" ${ARGN})
  return_ans()
endfunction()

# File: source/cmake/cmakelists/cml.cmake

## `(...)->...`
## 
## wrapper for cmakelists_cli
function(cml)
  set(args ${ARGN})
  cmakelists_cli(${args})
  ans(res)
  return_ref(res)
endfunction()


# File: source/cmake/environment/cmake_build_environment.cmake


 parameter_definition(cmake_build_environment)
function(cmake_build_environment)
  arguments_extract_defined_values(0 ${ARGC} cmake_build_environment)    
  ans(args)
  if(args AND NOT "${CMAKE_GENERATOR}" STREQUAL "${args}")
    cmake_configure_script("cmake_build_environment()" -G ${args})
    ans(res)
    creturn(${res})
  endif()

  cmake_check_configure_mode()
  cmake_compiler(CXX)
  ans(cxx)
  cmake_compiler(C)
  ans(c)


  map_capture_new(cxx c)
  ans(compilers)


  map_new()
  ans(env)

  cmake_system()
  ans(sys)


  # if(CMAKE_CROSSCOMPILING)
  #   map_set(${env} is_crosscompiling "true")
  # else()
  #   map_set(${env} is_crosscompiling "false")
  # endif()



  set(architecture "${CMAKE_SIZEOF_VOID_P}")
  math(EXPR architecture "${architecture} * 8")




  set(cfg "${CMAKE_BUILD_TYPE}")
  if(NOT cfg)
    set(cfg release)
  endif()

  if(DEFINED BUILD_SHARED_LIBS)
    
    if(BUILD_SHARED_LIBS)
      set(lnk shared)
    else()    
      set(lnk static)
    endif()
  else()
    set(lnk shared)
  endif()

  
  map_set(${env} generator ${CMAKE_GENERATOR})
  map_set(${env} config "${cfg}")
  map_set(${env} linkage "${lnk}")
  map_set(${env} architecture "${architecture}")
  map_set(${env} system "${sys}")
  map_set(${env} compilers ${compilers})



  creturn(${env})
endfunction()

# File: source/cmake/environment/cmake_capabilities.cmake



function(cmake_capabilities)
  cmake(-E capabilities)
  ans(res)
  json_deserialize("${res}")
  ans(res)
  return_ref(res)
endfunction()

# File: source/cmake/environment/cmake_check_configure_mode.cmake

## causes an error if cmake is not in configure mode
function(cmake_check_configure_mode)
  cmake_is_configure_mode()
  ans(isConfigMode)
  if(NOT isConfigMode)
    message(FATAL_ERROR "cmake needs to be in config mode! - aborting execution")
  endif()
  creturn()
endfunction()


# File: source/cmake/environment/cmake_check_script_mode.cmake


## causes an error if cmake is not in script mode
function(cmake_check_script_mode)
  cmake_is_script_mode()
  ans(isScriptMode)
  if(NOT isScriptMode)
    message(FATAL_ERROR "cmake needs to be in script mode! - aborting execution")
  endif()
  creturn()
endfunction()



# File: source/cmake/environment/cmake_compiler.cmake

## 
## 
function(cmake_compiler language)
  set(id "${CMAKE_${language}_COMPILER_ID}")
  string_tolower("${id}")
  ans(id)
  #set(path "${CMAKE_${language}_COMPILER}")
  # path should not be returned as it is absolute
  set(version "${CMAKE_${language}_COMPILER_VERSION}")    
  ## should not be used
 ## set(flags "${CMAKE_${language}_FLAGS}")
  set(abi "${CMAKE_${language}_ABI}")
  set(target "${CMAKE_${language}_TARGET}")
  set(launcher "${CMAKE_${language}_LAUNCHER}")
  map_capture_new(id version)
  return_ans()
endfunction()

# File: source/cmake/environment/cmake_configure_script.cmake


## executes a cmake script in configure mode
## parameters to script will be passed to cmake 

parameter_definition(
  cmake_configure_script 
  <--script:<string>>
  [--target-dir:<path>]
)
function(cmake_configure_script)
  arguments_extract_defined_values(0 ${ARGC} cmake_configure_script)
  ans(args)

  if(target_dir)
    pushd("${target_dir}" --create)
    ans(dir)
  else()
    pushtmp()
    ans(dir)
  endif()
  


  log("executing cmake configure script in '${dir}'")

  cmakepp_config(cmakepp_path)
  ans(cmakepp_path)

  path("output.qm")
  ans(output_file)

  set(cmakelists_content "
    cmake_minimum_required(VERSION 2.8.12)
    include(${cmakepp_path})
   
    set_ans()
    function(___execute_it)
      ${script}
      return_ans()
    endfunction()
    ___execute_it()
    ans(result)        
    cmake_write(\"${output_file}\" \"\${result}\")
  ")

  fwrite("CMakeLists.txt" "${cmakelists_content}") 


  pushd(build --create)
    cmake_lean(".." ${args})
    ans_extract(error)
    ans(stdout)
  popd()
  
  

  if(error)      
    error("error out: ${stdout}")
    set(res)
  else()
    cmake_read(${output_file})
    ans(res)  
  endif()

  if(passthru)
    message("${stdout}")
  endif()

  if(target_dir)
    popd()
  else()
    poptmp()  
  endif()


  return_ref(res)
endfunction()




# File: source/cmake/environment/cmake_environment.cmake

## `()-> <environment>`
##
## ```
## <environment descriptor> ::= {
##  host_name: <string> # Computer Name
##  processor: <string> # processor identification string
##  architecture: "32"|"64" # processor architecture
##  os:<operating system descriptor>
## }
## <operating system descriptor> ::= {
##  name: <string>
##  version: <string>
##  family: "Windows"|"Unix"|"MacOS"|...  
## }
## ```
## 
## returns the environment of cmake
## the results are cached (--update-cache if necesssary)
function(cmake_environment)
  function(_cmake_environment_inner)
  

    set(result)
    cmake_configure_script("map_capture_new(
      CMAKE_GENERATOR
      CMAKE_SIZEOF_VOID_P
      CMAKE_SYSTEM
      CMAKE_SYSTEM_NAME
      CMAKE_SYSTEM_PROCESSOR
      CMAKE_SYSTEM_VERSION
      CMAKE_HOST_SYSTEM
      CMAKE_HOST_SYSTEM_NAME
      CMAKE_HOST_SYSTEM_PROCESSOR
      CMAKE_HOST_SYSTEM_VERSION
      CMAKE_C_COMPILER_ID
      CMAKE_C_COMPILER_VERSION
      CMAKE_CXX_COMPILER_ID
      CMAKE_CXX_COMPILER_VERSION
      )")
    ans(res)
    
    site_name(host_name)
    assign(!result.host_name = host_name)     
    assign(!result.architecture = res.CMAKE_HOST_SYSTEM_PROCESSOR) 
    assign(!result.cmake.default_generator = res.CMAKE_GENERATOR)
    assign(!result.cmake.default_compiler_id = res.CMAKE_CXX_COMPILER_ID)
    assign(!result.cmake.default_compiler_version = res.CMAKE_CXX_COMPILER_VERSION)
  #  map_tryget(${res} CMAKE_SIZEOF_VOID_P)
   # ans(byte_size_voidp)
   # math(EXPR architecture "${byte_size_voidp} * 8")
   # assign(!result.architecture = architecture)
    
    assign(!result.os.name = res.CMAKE_HOST_SYSTEM_NAME)   
    assign(!result.os.version = res.CMAKE_HOST_SYSTEM_VERSION) 
    if(CMAKE_HOST_WIN32)
      assign(!result.os.family = 'Windows')   
    elseif(MAC)
      assign(!result.os.family = 'MacOS')   
    elseif(UNIX)
      assign(!result.os.family = 'Unix')  
    endif()
    return_ref(result)
  endfunction()
  
  define_cache_function(_cmake_environment_inner => cmake_environment
    --generate-key "[]()checksum_string({{CMAKE_COMMAND}})"
   # --refresh
  )
  cmake_environment(${ARGN})
  return_ans()
endfunction()



# File: source/cmake/environment/cmake_generator_list.cmake

## `()-> <string..>`
##
## returns a list of available generators on current system
function(cmake_generator_list)
  cmake_lean(--help)
  ans(help_text)
  list_pop_front(help_text)
  ans(error)
  if(error)
    message(FATAL_ERROR "could not execute cmake")
  endif()
  if("${help_text}" MATCHES "\nGenerators\n\n[^\n]*\n(.*)")
    set(generators_text "${CMAKE_MATCH_1}")
  endif()


  string(REGEX MATCHALL "(^|\n)  [^ \t][^=]*=" generators "${generators_text}")
  set(result)
  foreach(generator ${generators})
    if("${generator}" MATCHES "  ([^ ].*[^ \n])[ ]*=")
      set(generator "${CMAKE_MATCH_1}")
      list(APPEND result "${generator}")
    endif()

  endforeach()

  map_set(global cmake_generators "${result}")
  function(cmake_generators)
    map_tryget(global cmake_generators)
    return_ans()
  endfunction()

  cmake_generators()
  return_ans()
endfunction()

# File: source/cmake/environment/cmake_host_system.cmake



function(cmake_host_system)
 
  cmake_is_configure_mode()
  ans(is_config_mode)
  if(NOT is_config_mode)
    cmake_configure_script("cmake_host_system()")
    return_ans()
  endif()


  map_new()
  ans(sys)

  map_set(${sys} id "${CMAKE_HOST_SYSTEM}")
  map_set(${sys} name "${CMAKE_HOST_SYSTEM_NAME}")
  map_set(${sys} version "${CMAKE_HOST_SYSTEM_VERSION}")
  map_set(${sys} processor "${CMAKE_HOST_SYSTEM_PROCESSOR}")


  creturn(${sys})
endfunction()

# File: source/cmake/environment/cmake_is_configure_mode.cmake


function(cmake_is_configure_mode)
  cmake_is_script_mode()
  ans(res)
  if(res)
    creturn(false)
  else()
    creturn(true)
  endif()
endfunction()



# File: source/cmake/environment/cmake_is_script_mode.cmake

function(cmake_is_script_mode)
  if(CMAKE_SCRIPT_MODE_FILE)
    creturn(true)
  else()    
    creturn(false)
  endif()
endfunction()


# File: source/cmake/environment/cmake_processor_count.cmake

function(environment_processor_count)
  # from http://www.cmake.org/pipermail/cmake/2010-October/040122.html
  if(NOT DEFINED processor_count)
    # Unknown:
    set(processor_count 0)

    # Linux:
    set(cpuinfo_file "/proc/cpuinfo")
    if(EXISTS "${cpuinfo_file}")
      file(STRINGS "${cpuinfo_file}" procs REGEX "^processor.: [0-9]+$")
      list(LENGTH procs processor_count)
    endif()

    # Mac:
    if(APPLE)
      find_program(cmd_sys_pro "system_profiler")
      if(cmd_sys_pro)
        execute_process(COMMAND ${cmd_sys_pro} OUTPUT_VARIABLE info)
        string(REGEX REPLACE "^.*Total Number Of Cores: ([0-9]+).*$" "\\1" processor_count "${info}")
      endif()
    endif()

    # Windows:
    if(CMAKE_HOST_WIN32)
      set(processor_count "$ENV{NUMBER_OF_PROCESSORS}")
    endif()
  endif()

  eval("
  function(environment_processor_count)
    set(__ans ${processor_count} PARENT_SCOPE)
  endfunction()
  ")
  environment_processor_count()
  return_ans()
endfunction()

# File: source/cmake/environment/cmake_system.cmake




function(cmake_system)
  cmake_check_configure_mode()

  map_new()
  ans(sys)

  map_set(${sys} id "${CMAKE_SYSTEM}")
  map_set(${sys} name "${CMAKE_SYSTEM_NAME}")
  map_set(${sys} version "${CMAKE_SYSTEM_VERSION}")
  map_set(${sys} processor "${CMAKE_SYSTEM_PROCESSOR}")


  creturn(${sys})
endfunction()

# File: source/cmake/environment/os_families.cmake

## returns all known host systems
  function(os_families)
    creturn(Windows Unix OSX)
  endfunction()

# File: source/cmake/generator/generator_cmake_add_library.cmake

function(test)

  fwrite("include/lib1.h" "")
  fwrite("include/lib2.h" "")
  fwrite("include/lib3.h" "")
  fwrite("include/lib4.h" "")
  fwrite("src/main.cpp" "")
  fwrite("src/impl1.cpp" "")
  fwrite("src/impl2.cpp" "")
  fwrite("src/impl3.cpp" "")
  fwrite("src/dir1/impl4.cpp" "")
  fwrite("src/dir2/impl5.cpp" "")

  
endfunction()


function(generator_cmake_source_group name)
  set(globs ${ARGN})
  glob_ignore(${globs} --relative)
  ans(files)


  set(template "## 


    ")

endfunction()


function(generator_cmake_add_library config)



endfunction()

# File: source/cmake/is_cmake_function.cmake



    function(is_cmake_function code) 
      if("${code}" MATCHES "function.*endfunction")
        creturn(true)
      endif()
      creturn(false)
    endfunction()

# File: source/cmake/old/cmake_function_parse.cmake


function(cmake_function_parse code)
  cmake_function_signature("${code}")
  ans(signature)
  map_set(${signature} code "${code}")
  return_ref()
endfunction()


# File: source/cmake/old/cmake_function_rename_first.cmake


    function(cmake_function_rename_first code new_name)
        cmake_function_signature("${code}")
        ans(sig)
        map_tryget(${sig} signature_code)
        ans(old_func)
        map_tryget(${sig} name)
        ans(old_name)
        string(REPLACE "${old_name}" "${new_name}" new_func "${old_func}")
        string(REPLACE "${old_func}" "${new_func}" code "${code}")
        return_ref(code)
    endfunction()


# File: source/cmake/old/cmake_function_signature.cmake


    function(cmake_function_signature code)
      regex_cmake()  
      string(REGEX MATCHALL "${regex_cmake_function_begin}" functions "${code}")
      list_pop_front(functions)
      ans(function)

      map_new()
      ans(res)
      if("${function}" MATCHES "${regex_cmake_function_signature}")
        map_set(${res} name "${${regex_cmake_function_signature.name}}")
        map_set(${res} args_string "${${regex_cmake_function_signature.args}}")
        map_set(${res} signature_code "${function}")
      endif()
      return_ref(res)
    endfunction()


# File: source/cmake/old/cmake_function_signatures.cmake


    function(cmake_function_signatures code)
      regex_cmake()
      string(REGEX MATCHALL "${regex_cmake_function_begin}" functions "${code}")
      return_ref(functions)
    endfunction()



# File: source/cmake/old/cmake_script_comment_header.cmake


function(cmake_script_comment_header content)
    set(args ${ARGN})
    list_extract_labelled_value(args --depth)
    ans(expected_depth)
    if ("${expected_depth}_" STREQUAL "_")
        set(expected_depth 1)
    endif ()
    string_repeat("#" "${expected_depth}")
    ans(expected_depth)
    cmake_script_parse("${content}" --comment-header --ignore-newlines)
    ans(lines)
    set(markdown)
    foreach (line ${lines})
        map_tryget(${line} type)
        ans(type)

        if ("${type}" STREQUAL "comment")
            map_tryget(${line} comment_depth)
            ans(depth)
            if ("${depth}" STREQUAL "${expected_depth}")
                map_tryget("${line}" comment)
                ans(comment)
                set(markdown "${markdown}${comment}\n")
            else ()
                break()
            endif ()
        endif ()
    endforeach ()

    return_ref(markdown)
endfunction()


# File: source/cmake/old/cmake_script_parse.cmake

##
##
function(cmake_script_parse content)
  set(args ${ARGN})
  list_extract_flag(args --comment-header)
  ans(return_comment_header)
  list_extract_flag(args --ignore-newlines)
  ans(ignore_newlines)
  list_extract_flag(args --first-function-header)
  ans(return_first_function_header)
  set(res)  
  set(non_empty_script_found false)

  while(true)
    set(empty false)
    string_take_whitespace(content)
    string_take_regex(content "[^\n]+")
    ans(line)
    string_take_regex(content "\n")
    list(LENGTH content len)
   
    if(NOT len)
      break()
    endif()
    map_new()
    ans(current)
    map_set(${current} line "${line}")
    if("${line}" MATCHES "^(#+)(.*)")
      map_set(${current} type "comment")
      map_set(${current} comment "${CMAKE_MATCH_2}")
      map_set(${current} comment_depth "${CMAKE_MATCH_1}")
    else()
      map_set(${current} type "script")
      string_take_whitespace(line)
      if("${line}_" STREQUAL "_" )
        map_set(${current} empty true)
        set(empty true)
      else()
        map_set(${current} empty false)
        set(non_empty_script_found true)
        set(empty false)

        if(return_comment_header)
          return_ref(res)
        endif()
      endif()
      map_set(${current} script "${line}")
      set(CMAKE_MATCH_3)
      if("${line}" MATCHES "^([^\\(]+)(\\(.*\\))(.*)")
        map_set(${current} function_name "${CMAKE_MATCH_1}")   
        map_set(${current} function_call "${CMAKE_MATCH_2}")
        set(function_name "${CMAKE_MATCH_1}")
        set(function_call "${CMAKE_MATCH_2}")
        string(REGEX REPLACE "\\((.*)\\)" "\\1" function_call "${function_call}")
          while(true)
            string_take_whitespace(function_call)
            if("${function_call}_" STREQUAL "_")
              break()
            endif()
            ans(arg)
            if("${arg}_" STREQUAL "_")
              string_take_regex(function_call "[^ ]+")
              ans(arg)
            endif()
            string_encode_semicolon("${arg}")
            ans(arg)
            map_append(${current} function_args "${arg}")
         
          endwhile()
        if("${CMAKE_MATCH_3}" MATCHES "^[ ]*#(.*)[ ]*$")
          map_set(${current} comment "${CMAKE_MATCH_1}")
        endif()
        if(return_first_function_header AND ( "${function_name}" STREQUAL "function" OR "${function_name}" STREQUAL "macro"))
          creturn(${current})
        endif()
      endif()
    endif()
    if(NOT (empty AND ignore_newlines))
      list(APPEND res ${current})
    endif()
  endwhile()
  return_ref(res)
endfunction()



# File: source/cmake/old/cmake_script_parse_file.cmake


function(cmake_script_parse_file path)
  fread("${path}")
  ans(content)
  cmake_script_parse("${content}" ${ARGN})
  return_ans()
endfunction()

# File: source/cmake/reflection/cmake_token_range_find_by_type.cmake

## `(<start:<token>> <end:<token>> [<limit:<uint>>])-><token>...` 
##
## returns the tokens which match type
## maximum tokens retunred is limit if specified
function(cmake_token_range_find_by_type start end type)
  set(limit ${ARGN})
  set(current ${start})
  set(count 0)
  set(result)
  while(current AND NOT "${current}" STREQUAL "${end}")
    if(limit AND NOT ${count} LESS "${limit}")
      return_ref(result)
    endif()
    map_tryget(${current} type)
    ans(current_type)

    if("${current_type}" MATCHES "${type}")
      list(APPEND result "${current}")
      math(EXPR count "${count} + 1")
    endif()
    map_tryget(${current} next)
    ans(current)
  endwhile()  
  return_ref(result)
endfunction()

# File: source/cmake/reflection/cmake_token_range_find_invocations.cmake

## `(<token range> <identifier:<regex>>  [<limmit>:<uint>])-><command invocation...>`
##
## returns all invocations which match the specified identifer regex
## only look between begin and end
function(cmake_token_range_find_invocations range identifier )
  set(args ${ARGN})
  list_extract(range begin end)

  set(limit ${args})
  set(current ${begin})
  set(result)
  set(count 0)
  while(current)
    if(limit AND NOT "${count}" LESS "${limit}")
      break()
    endif()
    if("${current}_" STREQUAL "${end}_")
      break()
    endif()

    map_tryget(${current} type)
    ans(type)
    if("${type}" STREQUAL "command_invocation")
      map_tryget(${current} value)
      ans(current_identifier)
      if("${current_identifier}" MATCHES "^${identifier}$")
        list(APPEND result ${current})
        math(EXPR count "${count} + 1")
      endif()
    endif()

    map_tryget(${current} next)
    ans(current)
  endwhile()
  return_ref(result)  
endfunction()

# File: source/cmake/reflection/cmake_token_range_find_next_by_type.cmake

## `(<start:<token>> <token type> [<value:<regex>>])-><token>`  
##
## returns the next token that has the specified token type
## or null
function(cmake_token_range_find_next_by_type range type)
  list_extract(range current end)
  set(regex ${ARGN})
  while(current AND NOT "${current}" STREQUAL "${end}")
    map_tryget(${current} type)
    ans(current_type)
    if("${current_type}" MATCHES "${type}")
      if(regex)
        map_tryget(${current} literal_value)
        ans(current_value)
        if("${current_value}" MATCHES "${regex}")
     #   print_vars(current_value regex match)
          return_ref(current)
        endif()
     #   print_vars(current_value regex nomatch)
      else()
        return_ref(current)
      endif()
    endif()
    map_tryget(${current} next)
    ans(current)
  endwhile()
endfunction()



# File: source/cmake/reflection/parsing/cmake_token_range.cmake

## `(<cmake token range>|<cmake token>...|<cmake code>)-><cmake token range>`
##
## coerces the input to become a token range 
## if the input already is a token range it is returned
## if the input is a list of tokens the token range will be extracted
## if the input is a string it is assumed to be cmake code and parsed to return a token range
function(cmake_token_range )    
  cmake_tokens("${ARGN}")
  rethrow()
  ans(range)
  list_pop_front(range)
  ans(begin)
  list_pop_back(range)
  ans(end)
  creturn(${begin} ${end})
endfunction()


# File: source/cmake/reflection/parsing/cmake_tokens.cmake

## `(<cmake code>|<cmake token>...)-><cmake token>...`
##
## coerces the input to a token list
function(cmake_tokens tokens)
  string_codes()

  if("${tokens}" MATCHES "^${ref_token}:")
    return_ref(tokens)
  endif()
  cmake_tokens_parse("${tokens}" --extended)
  rethrow()
  return_ans()
endfunction()

# File: source/cmake/reflection/parsing/cmake_tokens_parse.cmake

## `(<cmake code> [--extended])-><cmake token>...`
##
## this function parses cmake code and returns a list linked list of tokens 
##
## ```
## <token> ::= { 
##  type: "command_invocation"|"bracket_comment"|"line_comment"|"quoted_argument"|"unquoted_argument"|"nesting"|"nesting_end"|"file"
##  value: <string> the actual string as is in the source code 
##  [literal_value : <string>] # the value which actually is meant (e.g. "asd" -> asd  | # I am A comment -> ' I am A comment')
##  next: <token>
##  previous: <token>
## }
## <nesting token> ::= <token> v {
##   "begin"|"end": <nesting token>
## }
## <extended token> ::= (<token>|<nesting token>) v {
##  line:<uint> # the line in which the token is found
##  column: <uint> # the column in which the token starts
##  length: <uint> # the length of the token 
## }
## ```
function(cmake_tokens_parse code)
  set(args ${ARGN})
  list_extract_flag(args --extended)
  ans(extended)

  regex_cmake()

  set(line_counter 1)
  set(column_counter 1)
  set(nestings)
  set(previous)
  set(tokens)

  

  ## encode list to remove unwanted codes
  string_encode_list("${code}") # string replace \r ""?
  ans(code)
  string(REGEX MATCHALL "${regex_cmake_token}" literal_values "${code}")
  # this code checks for errors... however it is slow
  #string(REGEX REPLACE "${regex_cmake_token}" "" error "${code}")
  #if(error)
  #  throw("could not parse '{error}'" --function cmake_tokens_parse)
  #endif()
  
  while(true)
    list(LENGTH literal_values literals_left)
    if(NOT literals_left)
      break()
    endif()

    list(GET literal_values 0 literal)
    list(REMOVE_AT literal_values 0)

    map_new()
    ans(token)
    list(APPEND tokens ${token})

    set(literal_value "${literal}")
    if("${literal}_" STREQUAL "(_")
      set(type nesting)
      list(INSERT nestings 0 ${token})

    elseif("${literal}_" STREQUAL ")_")
      set(type nesting_end)
      if(NOT nestings)
        throw("unbalanced nesting expressions" --function cmake_tokens_parse)
      endif()
      list(GET nestings 0 begin)
      list(REMOVE_AT nestings 0)
      map_set(${begin} end ${token})
      map_set(${token} begin ${begin})

    elseif("${literal}_" MATCHES "^${regex_cmake_space}_$")
      set(type white_space)
    elseif("${literal}_" STREQUAL "${regex_cmake_newline}_")
      set(type new_line)
    else()
      ## all literals here need the decoded literal value
      string_decode_list("${literal}")
      ans(literal)
      if("${literal}_" MATCHES "^${regex_cmake_bracket_comment}_$")
        set(type bracket_comment)
        set(literal_value "${CMAKE_MATCH_1}")
      elseif("${literal}_" MATCHES "^${regex_cmake_line_comment}_$")
        set(type line_comment)
        set(literal_value "${CMAKE_MATCH_1}")
      elseif("${literal}_" MATCHES "^${regex_unquoted_argument}_$")
        set(type unquoted_argument)
        cmake_string_unescape("${literal}")
        ans(literal_value)
        set(literal_value "${literal_value}")
      
        if(NOT nestings AND "${literal}_" MATCHES "^${regex_cmake_identifier}_$")
          if("_${literal_values}" MATCHES "^_(${regex_cmake_space};)?${regex_cmake_nesting_start_char};")
            set(type command_invocation)
          endif()
        endif()
      elseif("${literal}_" MATCHES "^\"(.*)\"_$")
        set(type quoted_argument)
        cmake_string_unescape("${CMAKE_MATCH_1}")
        ans(literal_value)   
        set(literal_value "${literal_value}")
      else()
        throw("unknown token '{literal}'")
      endif()
    endif()

    map_set(${token} type "${type}")
    map_set(${token} value "${literal}")
    map_set(${token} literal_value "${literal_value}")
    
    if(extended) #these are computed values which make parsing slow
      if(nestings)
        list(GET nestings 0 current_nesting)
        map_append(${current_nesting} children ${token})
        map_set(${token} parent "${current_nesting}")
      endif()

      map_set_hidden(${token} previous ${previous})
      map_property_string_length("${token}" value)
      ans(length)
      map_set("${token}" length "${length}")
      map_set(${token} line ${line_counter})
      map_set(${token} column ${column_counter})
      math(EXPR  column_counter "${column_counter} + ${length}")
      if("${type}" STREQUAL "new_line")
        set(column_counter 0)
        math(EXPR line_counter "${line_counter} + 1")
      endif()
    endif()

    ## setup the linked list
    if(previous)
      map_set_hidden(${previous} next ${token})
    endif()
    set(previous ${token})
    list(APPEND tokens ${token})
  endwhile()
  cmake_token_eof()
  ans(eof)
  if(previous)
    map_set(${previous} next ${eof})
    map_set(${eof} previous ${previous})
  endif()

  list(APPEND tokens ${eof})
    
  return_ref(tokens)
endfunction() 



# File: source/cmake/reflection/serialization/cmake_token_range_serialize.cmake

## `(<start:<cmake token>> <end:<cmake token>>?)-><cmake code>`
## 
## generates the cmake code corresponding to the cmake token range
function(cmake_token_range_serialize range)
  cmake_token_range_to_list("${range}")
  ans(tokens)
  set(result)
  foreach(token ${tokens})
    map_tryget(${token} value)
    ans(value)
    set(result "${result}${value}")
  endforeach()

  return_ref(result)
endfunction()


# File: source/cmake/reflection/serialization/cmake_token_range_to_list.cmake

## `(<start:<cmake token>> [<end: <cmake token>])-><cmake token>...`
##
## returns all tokens for the specified range (or the end of the tokens)
function(cmake_token_range_to_list range)
  list_extract(range begin end)
  set(current ${begin})
  set(tokens)
  while(true)
    if(NOT current OR "${current}" STREQUAL "${end}")
      break()
    endif() 
    list(APPEND tokens ${current})
    map_tryget(${current} next)
    ans(current)
  endwhile()
  return_ref(tokens)
endfunction()

# File: source/cmake/reflection/targets/cmake_token_range_targets_filter.cmake


function(cmake_token_range_targets_filter range target_name)
  cmake_token_range("${range}")
  ans(range)
  cmake_invocation_filter_token_range("${range}" 
    invocation_identifier MATCHES "^(add_custom_target)|(add_test)|(add_library)|(add_executable)|(target_link_libraries)|(target_include_directories)|(target_compile_options)|(target_compile_definitions)$" 
    AND invocation_arguments MATCHES "^${target_name}(;|$)"
    )
  ans(target_invocations)
  map_new()
  ans(targets)

  set(target_definition_invocation)
  set(target_include_directories_invocation)
  set(target_link_libraries_invocation)
  set(target_compile_definitions_invocation)
  set(target_compile_options_invocation)
  foreach(target_invocation ${target_invocations})
    map_tryget(${target_invocation} invocation_arguments)
    ans_extract(target_name)
    ans(values)
    map_tryget(${targets} ${target_name})
    ans(target)
    if(NOT target)
      map_new()
      ans(target)
      map_new()
      ans(target_invocations)
      map_set_hidden(${target} target_invocations ${target_invocations})
      map_set(${targets} ${target_name} ${target})
      map_set(${target} target_name ${target_name})
    else()
      map_tryget(${target} target_invocations)
      ans(target_invocations)
    endif()

    map_tryget(${target_invocation} invocation_identifier)
    ans(invocation_identifier)

    if("${invocation_identifier}" MATCHES "^add_(.+)$")
      set(type target_source_files)
      map_set(${target} target_type ${CMAKE_MATCH_1})
    elseif("${invocation_identifier}" STREQUAL "target_link_libraries")
      set(type target_link_libraries)      
    elseif("${invocation_identifier}" STREQUAL "target_include_directories")
      set(type target_include_directories)      
    elseif("${invocation_identifier}" STREQUAL "target_compile_options")
      set(type target_compile_options)      
    elseif("${invocation_identifier}" STREQUAL "target_compile_definitions")
      set(type target_compile_definitions)      
    endif()
    map_set(${target} ${type} ${values})
    map_set(${target_invocations} "${type}" ${target_invocation} )
  endforeach()
  return_ref(targets)
endfunction()

# File: source/cmake/reflection/token_manipulation/cmake_token_advance.cmake

## `(<&<token>>)-><token>`
##
## advances the current token to the next token
macro(cmake_token_advance token_ref)
  map_tryget(${${token_ref}} next)
  ans(${token_ref})
endmacro()


# File: source/cmake/reflection/token_manipulation/cmake_token_go_back.cmake

## `(<&cmake token>)-><cmake token>`
## 
## the token ref contains the previous token after invocation
macro(cmake_token_go_back token_ref)
  map_tryget(${${token_ref}} previous)
  ans(${token_ref})
endmacro()



# File: source/cmake/reflection/token_manipulation/cmake_token_range_filter.cmake

## `(<cmake token range> <predicate> [--reverse] [--skip <uint>] [--take <uint>])-><cmake token>...`
##
## filters the specified token range for tokens matching the predicate (access to value and type)
## e.g. `cmake_token_range_filter("set(a b c d)" type MATCHES "^argument$" AND value MATCHES "[abd]" --reverse --skip 1 --take 1 )` 
## <% 
##   cmake_token_range_filter("set(a b c d)" type MATCHES "^argument$" AND value MATCHES "[abd]" --reverse --skip 1 --take 1 ) 
##   ans(res)
##   #template_out_json(${res})
## %>
## 
function(cmake_token_range_filter range )
  arguments_encoded_list(1 ${ARGC})
  ans(args)
  
  list_extract_flag(args --reverse)
  ans(reverse)
  
  cmake_token_range("${range}")
  if(reverse)
    ans_extract(end current)
  else()
    ans_extract(current end)
  endif()

  list_extract_labelled_value(args --skip)
  ans(skip)
  list_extract_labelled_value(args --take)
  ans(take)
  if("${take}_" STREQUAL "_")
    set(take -1)
  endif()
  set(predicate ${args})
  set(result)
  while(take AND current AND NOT "${current}" STREQUAL "${end}")
    map_tryget("${current}" literal_value)
    ans(value)
    map_tryget("${current}" type)
    ans(type)
    map_tryget("${current}" line)
    ans(line)

    eval_predicate(${predicate})
    ans(predicate_holds)

    #print_vars(reverse line value type predicate predicate_holds value type )
    #string(REPLACE "{type}" "${type}" current _predicate "${args}")
    #string(REPLACE "{value}" "${value}" current_predicate "${current_predicate}")
    if(predicate_holds)
    #print_vars(reverse line value type predicate predicate_holds value type )

      if(skip)
        math(EXPR skip "${skip} - 1")
      else()
        list(APPEND result ${current})
        if(${take} GREATER 0)
          math(EXPR take "${take} - 1")
        endif()
      endif()
    endif()
    if(reverse)
      cmake_token_go_back(current)
    else()
      cmake_token_advance(current)
    endif()
  endwhile()
  return_ref(result)
endfunction() 




# File: source/cmake/reflection/token_manipulation/cmake_token_range_filter_values.cmake

## `(...)->...` 
##
## convenience function
## same as cmake_token_range_filter however returns the token values
function(cmake_token_range_filter_values range)
  set(args ${ARGN})
  list_extract_flag(args --encode)
  ans(encode)## todo
  cmake_token_range_filter("${range}" ${args})
  ans(tokens)
  list_select_property(tokens literal_value)
  return_ans()
endfunction()


# File: source/cmake/reflection/token_manipulation/cmake_token_range_insert.cmake

## `(<where:<cmake token>> <cmake token range> )-><token range>`
##
## inserts the specified token range before <where>
function(cmake_token_range_insert where what)
  cmake_token_range("${what}")
  ans_extract(begin end)
  map_tryget("${where}" previous)
  ans(previous)

  if(previous)
    map_set_hidden(${previous} next ${begin})
    map_set_hidden(${begin} previous ${previous})  
  endif()
  map_set_hidden(${end} next ${where})
  map_set_hidden(${where} previous ${end}) 

  creturn(${begin} ${end})
endfunction()

# File: source/cmake/reflection/token_manipulation/cmake_token_range_remove.cmake

## `(<cmake token range>)-><void>`
##
## removes the specified token range from the linked list
function(cmake_token_range_remove range)
  list_extract(range begin end)
  map_tryget("${begin}" previous)
  ans(before)
  map_tryget("${end}" next)
  ans(after)
  map_set("${before}" next ${after})
  map_set("${after}" previous ${before})
  creturn()
endfunction()



# File: source/cmake/reflection/token_manipulation/cmake_token_range_replace.cmake

## `(<range:<cmake token range>> <replace_range:<cmake token range>>)-><cmake token range>`
## 
## replaces the specified range with the specified replace range
## returns the replace range
function(cmake_token_range_replace range replace_range)
  cmake_token_range("${range}")
  ans_extract(start end)
  cmake_token_range("${replace_range}")
  ans_extract(replace_start replace_end)
  map_tryget(${start} previous)
  ans(previous)
  map_set(${previous} next ${replace_start})
  map_set(${replace_start} previous ${previous})
  map_set(${end} previous ${replace_end})
  map_set(${replace_end} next ${end})
  creturn(${replace_start} ${replace_end})
endfunction()




# File: source/cmake/reflection/utilities/cmake_token_eof.cmake

  
function(cmake_token_eof)
  map_new()
  ans(token)
  map_set(${token} type eof)
  map_set(${token} value "")
  map_set(${token} literal_value "")
  return_ref(token)
endfunction()

# File: source/cmake/reflection/utilities/comment_section/cmake_token_range_comment_section_find.cmake

## `(<cmake token range> <section_name:<string>>)-><cmake token range>`
##
## finds the correct comment section or returns nothing 
function(cmake_token_range_comment_section_find range regex_section_name)

  set(regex_section_begin_specific "^[# ]*<section[ ]+name[ ]*=[ ]*\"${regex_section_name}\"[ ]*>[ #]*$")
  set(regex_section_begin_any "^[# ]*<section.*>[ #]*$")
  set(regex_section_end "^[# ]*<\\/[ ]*section[ ]*>[# ]*$")



  list_extract(range current end)


  cmake_token_range_find_next_by_type("${current};${end}" "^line_comment$" "${regex_section_begin_specific}")
  ans(current)

  if(NOT current)
    error("section ${section_name} not found")
    creturn()
  endif()

  set(section_begin_token ${current})

  cmake_token_advance(current)


  set(section_depth 1)
  set(section_end_token)

  while(current)

    cmake_token_range_find_next_by_type("${current};${end}" "^line_comment$" "(${regex_section_begin_any})|(${regex_section_end})")
    ans(current)

    map_tryget(${current} literal_value)
    ans(literal_value)

    if("${literal_value}" MATCHES "${regex_section_begin_any}")
      math(EXPR section_depth "${section_depth} + 1")
    else()
      math(EXPR section_depth "${section_depth} - 1")
    endif()

    if(NOT section_depth)
      set(section_end_token ${current})
      break()
    endif()

    map_tryget(${current} next)
    ans(current)

  endwhile()

  if(NOT section_end_token)
    error("unbalanced section close")
    creturn()
  endif()
  
  ## advance twice: comment->newline->begin of section
  cmake_token_advance(section_begin_token)
  cmake_token_advance(section_begin_token)

  creturn(${section_begin_token} ${section_end_token})
endfunction()

# File: source/cmake/reflection/utilities/comment_section/cmake_token_range_comment_section_find_all.cmake


  function(cmake_token_range_comment_section_find_all range regex_section_name)
    cmake_token_range("${range}")
    ans_extract(current end)

    set(sections)
    while(current)
      cmake_token_range_comment_section_find("${current};${end}" "${regex_section_name}")
      ans(section)
      ans_extract(section_begin section_end)

      if(NOT section)
        break()
      endif()
      list(APPEND sections ${section}) 

      map_tryget(${section_end} next)
      ans(current)
    endwhile()  

    return_ref(sections)

  endfunction()


# File: source/cmake/reflection/utilities/comment_section/cmake_token_range_comment_section_navigate.cmake


## navigates to the specified target sectopn returning its range
## sections are navigated by a simple navigation expression e.g. a.b.c
function(cmake_token_range_comment_section_navigate range path)
  cmake_token_range("${range}")
  ans(range)
  string(REGEX MATCHALL "[^\\.]+" section_identifiers "${path}" )
  foreach(section_identifier ${section_identifiers})
    cmake_token_range_comment_section_find("${range}" "${section_identifier}")
    ans(section)
    if(NOT section)
      error("could not find section '${section_identifier}'")
      creturn()
    endif() 
    set(range ${section})
  endforeach()

  return_ref(range)
endfunction()

# File: source/cmake/reflection/utilities/invocation/cmake_invocation_filter_token_range.cmake

## `(<cmake token range> <predicate> [--skip <uint>] [--take <uint>] [--reverse])-><cmake invocation>...`
##
## searches for invocations matching the predicate allowing to skip and take a certain amount of matches
## also allows reverse serach when specifying the corresponding flag.
##
## the predicate is the same as what one would write into an if clause allows access to the following variables:
## * invocation_identifier
## * invocation_arguments
## e.g. `invocation_identifier MATCHES "^add_.*$"` would return only invocations starting with add_
## also see `eval_predicate`
## ```
## <cmake invocation> ::= {
##    invocation_identifier: <string>      # the name of the invocation
##    invocation_arguments: <string>...    # the arguments of the invocation
##    invocation_token: <cmake token>      # the token representing the invocation
##    arguments_begin_token: <cmake token> # the begin of the arguments of the invocation (after the opening parenthesis)
##    arguments_end_token: <cmake token>   # the end of the arguments of the invocation (the closing parenthesis)
## }
## ```
##
function(cmake_invocation_filter_token_range range)
  arguments_encoded_list(1 ${ARGC})
  ans(args)

  list_extract_flag_name(args --reverse)
  ans(reverse)

  cmake_token_range("${range}")
  ans(range)
  list_extract(range begin end)
  set(current ${begin})
  list_extract_labelled_keyvalue(args --skip)
  ans(skip)
  list_extract_labelled_keyvalue(args --take)
  ans(take)
  if("${take}_" STREQUAL "_")
    set(take -1)
  endif()


  set(result)
  while(take AND current)
    cmake_token_range_filter("${current};${end}" type STREQUAL "command_invocation" --take 1 ${reverse})
    ans(invocation_token)
    if(NOT invocation_token)
      break()
    endif()
    if(reverse)
      set(end)
    endif()
    
    map_tryget("${invocation_token}" line)
    ans(line)
    cmake_token_range_filter("${invocation_token};${end}" type STREQUAL "nesting" --take 1)
    ans(arguments_begin_token)

    map_tryget(${arguments_begin_token} end)
    ans(arguments_end_token)
    map_tryget(${arguments_end_token} next)
    ans(arguments_after_end_token)

    cmake_token_range_filter_values("${invocation_token};${arguments_after_end_token}" 
      type MATCHES "(command_invocation)|(nesting)|(argument)")
    ans(invocation)



    ## get invocation_identifier and invocation_arguments
    set(invocation_arguments ${invocation})
    list_pop_front(invocation_arguments)
    ans(invocation_identifier)
    list_pop_front(invocation_arguments)
    list_pop_back(invocation_arguments)
    

    list(LENGTH args predicate_exists)
    if(predicate_exists)
      eval_predicate(${args})
      ans(predicate_holds)
    else()
      set(predicate_holds true)
    endif()
    #print_vars(invocation_identifier invocation_arguments predicate_holds)
    #print_vars(invocation_token.type invocation_token.value predicate_holds args)

    ## check if invocation matches the custom predicate
    ## skip and take the specific invocations
    if(predicate_holds)
      if(skip)
        math(EXPR skip "${skip} - 1")
      else()
        cmake_token_advance(arguments_begin_token)
        map_capture_new(
          invocation_identifier 
          invocation_arguments 
          invocation_token 
          arguments_begin_token 
          arguments_end_token
        )
        ans_append(result)
        if(${take} GREATER 0)
          math(EXPR take "${take} - 1")
        endif()
      endif() 
    endif() 

    if(reverse)
      map_tryget(${invocation_token} previous )
      ans(end)
    else()
      set(current ${arguments_after_end_token})
    endif()
  endwhile()
  return_ref(result)
endfunction()


# File: source/cmake/reflection/utilities/invocation/cmake_invocation_get_arguments_range.cmake

## `(<invocation:<command invocation>>)->[<start:<token>> <end:<token>>]`
## 
## returns the token range of the invocations arguments given an invocation token
function(cmake_invocation_get_arguments_range invocation)
  cmake_token_range_find_next_by_type("${invocation}" nesting)
  ans(arguments_begin)
  map_tryget(${arguments_begin} end)
  ans(arguments_end)
  map_tryget(${arguments_begin} next)
  ans(arguments_begin)
  creturn(${arguments_begin} ${arguments_end})
endfunction()


# File: source/cmake/reflection/utilities/invocation/cmake_invocation_remove.cmake

## `(<cmake invocation>)-><void>`
##
## removes the specified invocation from its context by removing the invocation token and the arguments from the linked list that they are part
function(cmake_invocation_remove invocation)
  map_tryget(${invocation} invocation_token)
  ans(begin)
  map_tryget(${invocation} arguments_end_token)
  ans(end)
  cmake_token_range_remove("${begin};${end}")
  creturn()
endfunction()



# File: source/cmake/reflection/utilities/invocation/cmake_invocation_set_arguments.cmake

## `(<command invocation token> <values: <any...>>)-><void>`
##
## replaces the arguments for the specified invocation by the
## specified values. The values are quoted if necessary
function(cmake_invocation_token_set_arguments invocation_token)
  cmake_invocation_get_arguments_range("${invocation_token}")
  ans_extract(begin end)

  cmake_arguments_quote_if_necessary(${ARGN})
  ans(arguments)

  list(LENGTH ARGN count)
  string(LENGTH "${ARGN}" len)
  

  if(${len} LESS 70 OR ${count} LESS 2)
    string_combine(" " ${arguments})
    ans(argument_string)
  else()
    map_tryget(${invocation_token} column)
    ans(column)
    string_repeat(" " "${column}")
    ans(last_indentation)
    math(EXPR column "${column} + 2")
    string_repeat(" " "${column}")
    ans(indentation)
    string_combine("\n${indentation}" ${arguments})
    ans(argument_string)
    set(argument_string "${argument_string}\n${last_indentation}")
  endif()

  cmake_token_range("${argument_string}")
  ans(argument_token_range)


  cmake_token_range_replace("${begin};${end}" "${argument_token_range}")
  creturn()
endfunction()

# File: source/cmake/reflection/utilities/variable/cmake_token_range_variable.cmake

function(cmake_token_range_variable range var_name)
  set(args ${ARGN})

  cmake_invocation_filter_token_range("${range}" 
    invocation_identifier STREQUAL "set" 
    AND invocation_arguments MATCHES "^${var_name}"  
    --take 1 
    )
  ans(invocation)

  
  if(NOT invocation)
    messagE(FATAL_ERROR "could not find 'set(${var_name} ...)'")
  endif()

  map_tryget(${invocation} invocation_token)
  ans(invocation_token)
  map_tryget(${invocation} invocation_arguments)
  ans(arguments)
  list_pop_front(arguments) ## remove var_name
  list_modify(arguments ${args})
  cmake_invocation_token_set_arguments(${invocation_token} ${var_name} ${arguments})
  return_ref(arguments)
endfunction()


# File: source/cmake/reflection/utilities/variable/cmake_token_range_variable_navigate.cmake

## navigates to and tries to change variable
function(cmake_token_range_variable_navigate range variable_path)
  cmake_token_range("${range}")
  ans(range)
  set(args ${ARGN}) 

  string(REGEX MATCH "[^\\.]+$" variable_name "${variable_path}")
  string(REGEX REPLACE "\\.?[^\\.]+$" "" section_path "${variable_path}" )
  cmake_token_range_comment_section_navigate("${range}" "${section_path}")
  ans(section)

  if(NOT section)
    creturn()
  endif()
  cmake_token_range_variable("${section}" "${variable_name}" ${args})
  return_ans()  
endfunction()

# File: source/cmake/targets/overrides/add_custom_target.cmake

macro(add_custom_target)
  _add_custom_target(${ARGN})


  event_emit(add_custom_target ${ARGN})
  event_emit(on_target_added custom ${ARGN})
  target_register(${ARGN})
endmacro()

# File: source/cmake/targets/overrides/add_dependencies.cmake


macro(add_dependencies)
  _add_dependencies(${ARGN})
  event_emit(add_dependencies ${ARGN})

endmacro()

# File: source/cmake/targets/overrides/add_executable.cmake


macro(add_executable)
  _add_executable(${ARGN})
  event_emit(add_executable ${ARGN})
  event_emit(on_target_added executable ${ARGN})
  target_register(${ARGN})
endmacro()

# File: source/cmake/targets/overrides/add_library.cmake

# overwrites add_library
# same function as cmakes original add_library
# emits the event add_library with all parameters of the add_library call
# emits the event on_target_added library with all parameters of the call added
# registers the target globally so it can be iterated via 
macro(add_library)
  _add_library(${ARGN})
  event_emit(add_library ${ARGN})

  event_emit(on_target_added library ${ARGN})
  target_register(${ARGN})


  
endmacro()


# File: source/cmake/targets/overrides/add_test.cmake


macro(add_test)
  _add_test(${ARGN})
  event_emit(add_test ${ARGN})
  event_emit(on_target_added test ${ARGN})
  target_register(${ARGN})

endmacro()

# File: source/cmake/targets/overrides/find_package.cmake

# wrapper for find_package using cps
#find_package(<package> [version] [EXACT] [QUIET]
#             [[REQUIRED|COMPONENTS] [components...]]
#             [NO_POLICY_SCOPE])
macro(find_package)
  set_ans("")
  event_emit(on_find_package ${ARGN})
  if(__ans)
    ## an event returns a cmake package map 
    ## which contains the correct variables
    ## also it contains a hidden field called find_package_return_value
    ## which is the return value for find_package

    scope_import_map("${__ans}")
    map_tryget("${__ans}" find_package_return_value)
  else()  
    _find_package(${ARGN})
    set_ans("")
  endif()
endmacro()

# File: source/cmake/targets/overrides/include_directories.cmake

macro(include_directories)
  _include_directories(${ARGN})
  event_emit(include_directories "${ARGN}")
endmacro()

# File: source/cmake/targets/overrides/install.cmake

# overwrites install command
#  emits event install and on_target_added(install ${ARGN)
# registers install target globally
macro(install)
  _install(${ARGN})
  event_emit(install ${ARGN})

  event_emit(on_target_added install install ${ARGN})
  target_register(install install ${ARGN})

endmacro()

# File: source/cmake/targets/overrides/project.cmake




# overwrites project so that it can be registered
macro(project)
  set(parent_project_name "${PROJECT_NAME}")
  _project(${ARGN})
  set(project_name "${PROJECT_NAME}") 
  project_register(${ARGN})
  event_emit("project" ${ARGN})
endmacro()




# function(project name)
#   set(parent_project_name "${PROJECT_NAME}")
#   _project("${name}" ${ARGN})
#   set(project_name "${PROJECT_NAME}") 
#   project_register("${name}" ${ARGN})
#   event_emit("project" "${name}" ${ARGN})

#   promote(
#     PROJECT_SOURCE_DIR
#     PROJECT_BINARY_DIR
#     PROJECT_VERSION
#     PROJECT_VERSION_MAJOR
#     PROJECT_VERSION_MINOR
#     PROJECT_VERSION_PATCH
#     PROJECT_VERSION_TWEAK
#     "${name}_SOURCE_DIR"
#     "${name}_BINARY_DIR"
#     "${name}_VERSION"
#     "${name}_VERSION_MAJOR"
#     "${name}_VERSION_MINOR"
#     "${name}_VERSION_PATCH"
#     "${name}_VERSION_TWEAK"
#     )

# endfunction()



# File: source/cmake/targets/overrides/target_compile_definitions.cmake


macro(target_compile_definitions)
  _target_compile_definitions(${ARGN})
  event_emit(target_compile_definitions ${ARGN})

endmacro()

# File: source/cmake/targets/overrides/target_compile_options.cmake


macro(target_compile_options)
  _target_compile_options(${ARGN})
  event_emit(target_compile_options ${ARGN})

endmacro()

# File: source/cmake/targets/overrides/target_include_directories.cmake

function(target_include_directories target)

if(NOT COMMAND _target_include_directories)
  cmake_parse_arguments("" "SYSTEM;BEFORE;PUBLIC;INTERFACE;PRIVATE" "" "" ${ARGN} )
  message(DEBUG "using fallback version of target_include_directories, consider upgrading to cmake >= 2.8.10")
  
  if(_SYSTEM OR _BEFORE OR _INTERFACE OR _PRIVATE)
    message(FATAL_ERROR "shim for target_include_directories does not support SYSTEM, PRIVATE, INTERFACE or BEFORE upgrade to cmake >= 2.8.10")
  endif()
    foreach(arg ${ARGN})
      if(TARGET "${arg}")
        get_property(includes TARGET ${arg} PROPERTY INCLUDE_DIRECTORIES)
        set_property(TARGET ${target} APPEND PROPERTY ${includes})
      else()
        message(FATAL_ERROR "shim version of target_include_directories only supports targets. upgrade cmake to >=2.8.10")
      endif()
    endforeach()
  creturn()
else()
  # default implementation
  _target_include_directories(${target} ${ARGN})
endif()
  event_emit(target_include_directories ${ARGN})
  
endfunction()

# File: source/cmake/targets/overrides/target_link_libraries.cmake

# overwrites target_link_libraries
# emits the event target_link_libraries
macro(target_link_libraries)
  _target_link_libraries(${ARGN})
  target_link_libraries_register(${ARGN})
  event_emit(target_link_libraries ${ARGN})
  
endmacro()

function(target_link_libraries_register target)
  
endfunction()

# File: source/cmake/targets/print_targets.cmake

# prints the list of known targets 
function(print_targets)
  target_list()
  ans(res)
  foreach(target ${res})
    message("${target}")
  endforeach()

endfunction()


function(print_project_tree)
  map_tryget(global project_map)
  ans(pmap)

  json_print(${pmap})
  creturn()

endfunction()


function(print_target target_name)
  target_get_properties(${target_name})
  ans(res)
  json_print(${res})
endfunction()

# File: source/cmake/targets/project_register.cmake

# 
function(project_register name)
  map_new()
  ans(pmap)
  map_set(global project_map ${pmap})
  function(project_register name)
    map_new()
    ans(cmake_current_project)
    map_set(${cmake_current_project} name "${name}")
    map_set(${cmake_current_project} directory "${CMAKE_CURRENT_LIST_DIR}")
    map_append(global projects ${cmake_current_project})
    map_append(global project_names ${name})
    map_tryget(global project_map)
    ans(pmap)
    map_set(${pmap} ${name} ${cmake_current_project})
  endfunction()
  project_register(${name} ${ARGN})
  return_ans()
endfunction()

# returns the project object identified by name
function(project_object)
  set(name ${ARGN})
  if(NOT name)
    # set to current project name
    set(name ${project_name})
    if(NOT name)
      set(name "${PROJECT_NAME}")
    endif()
  endif()
  
  map_tryget(global project_map)
  ans(res)
  if(NOT res)
    creturn()
  endif()
  map_tryget(${res} ${name})
  return_ans()
endfunction()

# returns the names of all project
macro(project_list)
  map_tryget(global project_names)
endmacro()

# File: source/cmake/targets/source_group_relative.cmake

## `(<relative path> <file>...)-> null` 
##
##  sets the source group for the specified files to their relative dirs 
function(source_group_relative  base_dir)
  foreach(file ${ARGN})
    path_parent_dir("${file}")
    ans(parent_dir)
    
    path_relative("${base_dir}" "${parent_dir}")
    ans(relative_dir_path)

    if(NOT "${relative_dir_path}" STREQUAL ".")
        string(REPLACE "../" "" relative_dir_path "${relative_dir_path}")
        string(REPLACE "/" "\\" relative_dir_path "${relative_dir_path}" )
        
        source_group(${relative_dir_path} FILES ${file})

    endif()

    



  endforeach()
  creturn()
endfunction()


# File: source/cmake/targets/target_add_auto.cmake

parameter_definition(target_add_auto
    <--name{"the name of the target, if empty or '.' the current folder name is used as project name"}:<string>=.>
    [--cppFeatures:<string>=cxx_variadic_templates;cxx_override]
    [--version{"the version of this target"}:<semver>=0.0.1]
    [--include-dir{"directory containing the public headers"}=>includeDir:<path>=include]
    [--source-dir{"directory containing the source files and private headers"}=>sourceDir:<string>=src]
    [--install{"generate install targets"}:<bool>=true]
    [--shared{"generate shared lib target"}:<bool>=true]
    [--static{"generate static lib target"}:<bool>=true]
    [--tests:<bool>=true]
    [--executable:<bool>=false]
    [--linkLibraries:<string>=]
    [--verbose]
    "#generates automatic targets for the current folder. assumes default package layout:
     # * directory `src` containing compilable files
     # * directory `header` containing public header files (which are installed)
     # * asdasd"    
 )

function(target_add_auto)
    arguments_extract_defined_values(0 ${ARGC} target_add_auto)
    

    if("${name}_" STREQUAL "_" OR "${name}_" STREQUAL "._")
      ## get target name from current path
    path_file_name(.)
    ans(targetName)
  else()
    set(targetName "${name}")
    endif()
  



  string(TOUPPER "${targetName}" targetNameUpper)



  glob("include/*.h" --recurse)
  ans(headers)
  glob("src/*.cpp" --recurse)
  ans(sources)





    if(verbose)
      print_vars(name cppFeatures verbose)
      message(INFO "adding auto target '${targetName}'...")
      message(INFO "target name: ${targetName}")
      message(INFO "c++ features: ${cppFeatures}")
      message(FORMAT INFO "version: {version.string}")
      list_length(headers)
      ans(nHeaders)
      list_length(sources)
      ans(nSources)
      message(INFO "include dir: ./${includeDir} (${nHeaders} files)")
      message(INFO "source dir: ./${sourceDir} (${nSources} files)")
    endif()


  set(static_suffix "_static")
  set(shared_suffix "_shared")

  source_group_relative("include" ${headers})
  source_group_relative("src" ${sources})


  write_compiler_detection_header(
    FILE "${CMAKE_CURRENT_BINARY_DIR}/${targetName}/compiler_detection.h"
    PREFIX ${targetNameUpper}
    COMPILERS GNU MSVC
    VERSION 3.5
    FEATURES
      ${cppFeatures}
  )


  if(shared)

    ## shared version
    add_library("${targetName}${shared_suffix}" SHARED ${sources} ${headers})


    target_include_directories("${targetName}${shared_suffix}" PUBLIC   
      "$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>"
      "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>"
      "$<INSTALL_INTERFACE:${targetName}/include>"
      )
    target_include_directories("${targetName}${shared_suffix}" PRIVATE src )
    target_version_info("${targetName}${shared_suffix}" --version "${version}")
    target_export_header("${targetName}${shared_suffix}" "${targetName}")
    if(MSVC)
      target_compile_options("${targetName}${shared_suffix}" PRIVATE  /MP /W4 /Zi)
      target_link_libraries("${targetName}${shared_suffix}" version.lib Iphlpapi.lib)
    endif()

  endif()

  if(static)

    ## static version
    add_library("${targetName}${static_suffix}" STATIC ${sources} ${headers})

    target_include_directories("${targetName}${static_suffix}" PUBLIC   
      "$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>"
      "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>"
      "$<INSTALL_INTERFACE:${targetName}/include>"
      )
    target_include_directories("${targetName}${static_suffix}" PRIVATE src )
    target_export_header("${targetName}${static_suffix}" "${targetName}")
    if(MSVC)
      target_compile_options("${targetName}${static_suffix}" PRIVATE  /MP /W4 /Zi)
      target_link_libraries("${targetName}${static_suffix}" version.lib Iphlpapi.lib)
    endif()

  endif()


  ## default library
  add_library(${targetName} ALIAS "${targetName}${shared_suffix}")


  if(install)
    install(DIRECTORY include DESTINATION ${targetName})
    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${targetName}/compiler_detection.h DESTINATION ${targetName}/include/${targetName})
    install(TARGETS ${targetName}${static_suffix} ${targetName}${shared_suffix}
      EXPORT ${targetName} 
      RUNTIME DESTINATION ${targetName}/bin
      LIBRARY DESTINATION ${targetName}/lib
      ARCHIVE DESTINATION ${targetName}/lib
      )
    install(EXPORT ${targetName} NAMESPACE toeb:: DESTINATION ${targetName})
  endif()

  if(tests)

    ## tests
    glob_ignore("${CMAKE_CURRENT_LIST_DIR}/tests/*.cpp" "${CMAKE_CURRENT_LIST_DIR}/tests/*.h"  "!${CMAKE_CURRENT_LIST_DIR}/bench.cpp")
    ans(test_sources)

    if(test_sources)
      add_executable("${targetName}_test" ${test_sources})
      target_link_libraries("${targetName}_test" "${targetName}${shared_suffix}" gtest)
      target_include_directories("${targetName}_test" PRIVATE ".")
      target_copy_shared_libraries_to_output("${targetName}_test")

      if(MSVC)
        target_compile_options("${targetName}_test" PRIVATE /MP /Zi)
      endif()
    endif()

  endif()
  


endfunction()



# File: source/cmake/targets/target_append.cmake


function(target_append tgt_name key)
	set_property(
		TARGET "${tgt_name}"
		APPEND
		PROPERTY "${key}"
		${ARGN})
	creturn()
endfunction()


# File: source/cmake/targets/target_append_string.cmake


function(target_append_string tgt_name key)
	set_property(
		TARGET "${tgt_name}"
		APPEND_STRING
		PROPERTY "${key}"
		${ARGN})
	creturn()
endfunction()


# File: source/cmake/targets/target_config_set.cmake

## sets a target config property
## ie.  target_config_set(mytarget RELEASE IMPORTED_LOCATION value)
## translates to set_property(TARGET mytarget PROPERTY IMPORTED_LOCATION_RELEASE value )
function(target_config_set targetName targetConfig propertyName)
    if(NOT "${targetConfig}_" STREQUAL "_")
        string_toupper("${targetConfig}")
        ans(targetConfig)


        list_contains(CMAKE_CONFIGURATION_TYPES ${targetConfig})
        ans(isvalid)
        if(NOT isvalid)
            message(FATAL_ERROR "cannot set target property '${propertyName}' for config '${targetConfig}' because this type of configuration does not exist  ")
            creturn(false)
        endif()

        set(propertyName "${propertyName}_${targetConfig}")
    endif()
    target_set("${targetName}" "${propertyName}" ${ARGN})
    creturn(true)
endfunction()

# File: source/cmake/targets/target_copy_imports.cmake


function(target_copy_imports target)
message(FATAL_ERROR "not implemented")
  target_get("${target}" IMPORTED)
  ans(isImported)
  if(NOT isImported)
    message(WARNING "${target} is not IMPORTED - cannot copy to output directory")
    creturn()
  endif()

  target_get("${target}" TYPE)
  ans(type)


  if(NOT "${type}" STREQUAL "SHARED_LIBRARY")
    message(WARNING "${target} is not a shared library")
  endif()

  target_get("${target}" IMPORTED_LOCATION)
  ans(sharedLibPath)
  target_get("${target}" RUNTIME_OUTPUT_DIRECTORY)
  ans(outputPath)

  message("cp ${sharedLibPath} to ${outputPath}")

endfunction()

# File: source/cmake/targets/target_copy_shared_libraries_to_output.cmake

## 
## adds a custom command to executableTarget which copies 
## the shared libraries of its dependencies to the target's directory
##
function(target_copy_shared_libraries_to_output executableTarget)
  target_get("${executableTarget}" TYPE)
  ans(exeType)
  if(NOT "${exeType}" STREQUAL "EXECUTABLE")
    message(WARNING "target_copy_shared_libraries_to_output only works for executable")
    creturn()
  endif()
  target_get(${executableTarget} LINK_LIBRARIES)
  ans(dependencies)
  foreach(dependency ${dependencies})

    target_get("${dependency}" TYPE)
    ans(targetType)
    if(NOT "${targetType}" STREQUAL "SHARED_LIBRARY")
      continue()
    endif()

    target_get(${dependency} IMPORTED)
    ans(isImported)
    if(isImported)
      add_custom_command(TARGET "${executableTarget}"  POST_BUILD 
        COMMAND ${CMAKE_COMMAND} -E  copy_if_different $<TARGET_PROPERTY:${dependency},LOCATION_$<CONFIG>>  "$<TARGET_FILE_DIR:${executableTarget}>"
        COMMENT "copying dlls for '${dependency}' to output directory of '${executableTarget}' ..."
      )
    else()
      add_custom_command(TARGET "${executableTarget}"  POST_BUILD 
        COMMAND ${CMAKE_COMMAND} -E  copy_if_different $<TARGET_FILE:${dependency}>  "$<TARGET_FILE_DIR:${executableTarget}>"
        COMMENT "copying dlls for '${dependency}' to output directory of '${executableTarget}' ..."
      )
    endif()
  endforeach()

endfunction()

# File: source/cmake/targets/target_export_header.cmake


function(target_export_header
  targetName
  apiName
  )


target_get("${targetName}" TYPE)
ans(targetType)


string(TOUPPER "${apiName}" targetNameUpper)


if("${targetType}" STREQUAL SHARED_LIBRARY)
  target_compile_definitions("${targetName}" PRIVATE "-D${targetNameUpper}_EXPORTS")
else()
  target_compile_definitions("${targetName}${staticSuffix}" PRIVATE "-D${targetNameUpper}_STATIC")
endif()



format("#pragma once
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the {targetNameUpper}_EXPORTS
// symbol defined on the command line. This symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// ISFREFLECTION_API functions as being imported from a DLL, whereas this DLL sees symbols
// defined with this macro as being exported.
#ifdef {targetNameUpper}_EXPORTS
#define {targetNameUpper}_API __declspec(dllexport)
#else
#ifdef {targetNameUpper}_STATIC
#define {targetNameUpper}_API
#else
#define {targetNameUpper}_API __declspec(dllimport)
#endif
#endif
//#define override  takes 10 seconds off compile time because of warnings generated (non standard extension)



#define {targetNameUpper}_NAMESPACE_BEGIN namespace ${targetName} {
#define {targetNameUpper}_NAMESPACE_END }


#define ${targetName}_namespace ${targetName}")
ans(formatted)
fwrite("${CMAKE_CURRENT_BINARY_DIR}/${targetName}/config.h" "${formatted}")

endfunction()


# File: source/cmake/targets/target_get.cmake



function(target_get tgt_name key)
	get_property(
		val
		TARGET "${tgt_name}"
		PROPERTY "${key}"
		)
	return_ref(val)
endfunction()


# File: source/cmake/targets/target_has.cmake


function(target_has tgt_name key)
	get_property(
		val
		TARGET "${tgt_name}"
		PROPERTY "${key}"
		SET)
	return_ref(val)
endfunction()


# File: source/cmake/targets/target_import.cmake

parameter_definition(
  build_info_evaluate_targets

  )
function(build_info_evaluate_targets)
  arguments_extract_defined_values(0 ${ARGC} build_info_evaluate_targets)    
  ans(build_infos)
  map_new()
  ans(evaluated_targets)
  foreach(build_info ${build_infos})    
    map_tryget(${build_info} build_parameters)
    ans(build_parameters)

    map_tryget(${build_info} id)
    ans(build_id)

    if(NOT build_parameters)
      fatal("no build parameters specified for build")
      # todo maybe just ignoriung is enough 
    endif()

    ## get the build descriptor template for current build
    map_tryget(${build_info} build_descriptor)
    ans(build_descriptor)

    ## get target templates generated by build
    map_tryget(${build_descriptor} targets)
    ans(build_targets)

    ## a single build info can have multiple targets
    map_template_evaluate_scoped("${build_parameters}" "${build_targets}")
    ans(evaluated_build_targets)

    foreach(evaluated_build_target ${evaluated_build_targets})
      map_tryget("${evaluated_build_target}" name)
      ans(target_name)
      if(NOT target_name)
        set(target_name "default")
        map_set(${evaluated_build_target} name "${target_name}")
      endif()
      map_set(${evaluated_build_target} build_id ${build_id})
      map_set(${evaluated_build_target} build_parameters ${build_parameters})
      map_append(${evaluated_targets} "${target_name}" "${evaluated_build_target}")
    endforeach()

  endforeach()
  creturn(${evaluated_targets})
endfunction()



  # if(NOT target_namespace)
  #   log("no target namespace is specified - defaulting to package id '${package_id}'")
  #   string_to_target_name("${package_id}")
  #   ans(target_namespace)
  # endif()


parameter_definition(cmake_import_target_from_build_info_targets
  <--target-namespace{"namespace for targets of package handle"}=>target_namespace:<target_identifier>>
  )
function(cmake_import_target_from_build_info_targets)
  arguments_extract_defined_values(0 ${ARGC} cmake_import_target_from_build_info_targets)    
  ans(target_configurations)

  ## targets are only available if in script mode
  cmake_check_configure_mode()


  assign(name = target_configurations[:].name)
  list_unique(name)
  ans(name)
  list(LENGTH name size )
  if(NOT "${size}" STREQUAL "1")
    fatal("all build info targets need to have the same name")
  endif()

  assign(type = target_configurations[:].type)
  list_unique(type)
  ans(type)
  list(LENGTH type size)  
  if(NOT "${size}" STREQUAL "1")
    fatal("all build info targets need to have the same target type")
  endif()




  if(NOT name OR "${name}_" STREQUAL "default_")
    set(cmake_target_name "${target_namespace}")
  else()
    set(cmake_target_name "${target_namespace}::${name}")
  endif()



  foreach(target_configuration ${target_configurations})      
    map_set_default("${target_configuration}" cmake_target_name "${cmake_target_name}")
  endforeach()

  #assign(ids = target_configurations[:].build_id)

  assign(configs  = target_configurations[:].build_parameters.config)
  assign(linkages = target_configurations[:].build_parameters.linkage)

  map_new()
  ans(cmake_target)
  map_set(${cmake_target} name "${cmake_target_name}")
  map_set(${cmake_target} type "${type}")

  # set default values  (default to release config)

  # map_set(${cmake_target} include_dirs)
  # map_set(${cmake_target} library) ## if library == empty -> use name as library name



  # then set release specific values
  foreach(config ${configs})
    map_new()
    ans(config_properties)


    set(build_parameters)
    set(target_configuration)
    foreach(current_target_configuration ${target_configurations})
      map_tryget("${current_target_configuration}" "build_parameters")
      ans(build_parameters)

      map_tryget(${build_parameters} config)
      ans(current_config)

      if("${current_config}_" STREQUAL "${config}_")
        set(target_configuration ${current_target_configuration})
        break()
      endif()
    endforeach()

    if(NOT target_configuration)
      fatal("could not associate config '${config}' with target_configuration config")
    endif()


    map_tryget(${target_configuration} include_dirs)
    ans(include_dirs)
    map_tryget(${target_configuration} output)
    ans(output)
    map_tryget(${target_configuration} libs)
    ans(libs)

    message("parameters for ${config} ######")
    print_vars(build_parameters)
    print_vars(target_configuration)

    map_tryget(${build_parameters} install_dir)
    ans(install_dir)


    map_template_evaluate_scoped("${build_parameters}" "${include_dirs}")
    ans(include_dirs)
    if(include_dirs)
      map_set(${config_properties} include_dirs ${include_dirs})      
    endif()

    map_template_evaluate_scoped("${build_parameters}" "${libs}")
    ans(libs)
    if(libs)
      pushd("${install_dir}")
        glob(${libs})
        ans(library_locations)
      popd()
    endif()

    
    map_template_evaluate_scoped("${build_parameters}" "${output}")
    ans(output)
    if(output)
      pushd("${install_dir}")
        glob(${output})
        ans(output)
        map_set(${config_properties} content_files ${output})
      popd()
    endif()

    #map_set(${config_properties} imported_location ${libs})
    #map_set(${config_properties} imported_implib "")
    #map_set(${config_properties} content_files ${output})
    #map_set(${config_properties} content_files )

    map_keys(${config_properties})
    ans(has_keys)

    if(has_keys)
      map_set(${cmake_target} ${config} ${config_properties})
    endif()


  endforeach()



  map_tryget(${cmake_target} release)
  ans(release_config)


  if(release_config)
    map_defaults(${cmake_target} "${release_config}")
  endif()


  creturn(${cmake_target})
  

endfunction()

parameter_definition(cmake_target_import
  <--cmake-target{""}=>cmake_target:<map>>
  )
function(cmake_target_import)  
  arguments_extract_defined_values(0 ${ARGC} cmake_target_import)    
  ans(args)

  log("trying to import target {cmake_target.name}")

  map_tryget(${cmake_target} name)
  ans(name)
  map_tryget(${cmake_target} type)
  ans(type)

  if(NOT ("${type}" STREQUAL library) AND NOT ("${type}" STREQUAL "interface"))
    fatal("cannot import cmake target of type '${type}'")
  endif()

  set(scope GLOBAL)
  set(imported IMPORTED)

  set(linkage SHARED) # or STATIC  or INTERFACE

  if("${type}" STREQUAL "interface")
    set(linkage "INTERFACE")  
  endif()

  add_library("${name}" ${linkage} ${imported} ${scope})


  if(imported)

    ## depending on config using generator expression
    target_set("${name}" INTERFACE_INCLUDE_DIRECTORIES ...)


    if("${linkage}" STREQUAL "SHARED")
      target_set("${name}" IMPORTED_LOCATION_<CONFIG>)
      target_set("${name}" IMPORTED_IMPLIB_<CONFIG>)
    elseif("${linkage}" STREQUAL "INTERFACE")

    elseif("${linkage}" STREQUAL "STATIC")
      target_set("${name}" IMPORTED_LOCATION_<CONFIG>)

    endif()

  endif()
  creturn()

endfunction()
parameter_definition(build_info_targets_import
  <--target-namespace{"namespace for targets of package handle"}=>target_namespace:<target_identifier>>
  )
function(build_info_targets_import)
  arguments_extract_defined_values(0 ${ARGC} build_info_targets_import)    
  ans(build_infos)

  log("trying to import builds to target-namespace '${target_namespace}'")

  build_info_evaluate_targets(${build_infos})
  ans(evaluated_targets)

  if(NOT evaluated_targets)
    fatal("could not evaluated targets")
  endif()

  map_keys(${evaluated_targets})
  ans(package_target_names)

  set(cmake_target)
  foreach(package_target_name ${package_target_names})
    map_tryget(${evaluated_targets} "${package_target_name}")
    ans(target_configurations)

    cmake_import_target_from_build_info_targets("${target_namespace}" ${target_configurations})
    ans_append(cmake_targets)




  endforeach()

  foreach(cmake_target ${cmake_targets})
    cmake_target_import(${cmake_target})
  endforeach()

  return_ref(cmake_targets)




  # set(bin_dir bin)
  # set(lib_dir lib)


  # set(include_dirs)
  # set(implib)
  # set(location)
  # set(configs)

  #   map_tryget(${build_parameters} install_dir)
  #   ans(install_dir)

  #   set(include_dir include)



  #   map_tryget("${build_parameters}" config)
  #   ans(cfg)   
  #   string_toupper("${cfg}")
  #   ans(cfg)
  #   list(APPEND configs "${cfg}")

  #   glob("${install_dir}/${bin_dir}/*${CMAKE_SHARED_MODULE_SUFFIX}")
  #   ans(shared_lib)


  #   glob("${install_dir}/${lib_dir}/*${CMAKE_STATIC_LIBRARY_SUFFIX}")
  #   ans(static_lib)

    
  #   set(include_dirs ${include_dirs} "$<$<CONFIG:${cfg}>:${install_dir}/${include_dir}>")


  #   if(shared_lib)
  #     if(NOT location)
  #       map_new()
  #       ans(location)
  #     endif()
  #     list(LENGTH shared_lib nLibs)
  #     if("${nLibs}" GREATER 1)
  #       message(FATAL_ERROR "cannot handle shared nlibs greater 1")
  #     endif()
  #     map_set("${location}" "${cfg}" "${shared_lib}")
  #   endif()

  #   if(static_lib)
  #     if(NOT implib)
  #       map_new()
  #       ans(implib)
  #     endif()

  #     list(LENGTH implib nLibs)
  #     if("${nLibs}" GREATER 1)
  #       message(FATAL_ERROR "cannot handle implib nlibs greater 1")        
  #     endif()
  #     map_set("${implib}" "${cfg}" "${static_lib}")
  #   endif()


  # set(global GLOBAL)
  # set(linkage SHARED ) # STATIC, INTERFACE


  # if(NOT location AND NOT implib)
  #   set(linkage INTERFACE)  
  # else()


  # endif()

  # if(location) 
  #   set(linkage SHARED)
  # elseif(location )
  # endif()

  # add_library(${target_name} ${linkage} IMPORTED ${global})
  # target_set(${target_name} INTERFACE_INCLUDE_DIRECTORIES ${include_dirs})


  # if(implib)
  #   map_keys(${implib})
  #   ans(cfgs)
  #   foreach(cfg ${cfgs})
  #     map_tryget(${implib} ${cfg})
  #     ans(lib)
  #     target_set(${target_name} "IMPORTED_IMPLIB_${cfg}" "${lib}")
  #   endforeach()
  # endif()

  # if(location)
  #   map_keys(${location})
  #   ans(cfgs)
  #   foreach(cfg ${cfgs})
  #     map_tryget(${location} ${cfg})
  #     ans(loc)
  #     target_set(${target_name} "IMPORTED_LOCATION_${cfg}" "${loc}")
  #   endforeach()
  # endif()

  # creturn(${target_name})

endfunction()



# File: source/cmake/targets/target_list.cmake


# returns all known target names
macro(target_list)
  map_tryget(global target_names)
endmacro()


# File: source/cmake/targets/target_register.cmake

# registers the target globally
# the name of the target is added to targets
#  or target_list()
function(target_register target_name)
  map_new()
  ans(target_map)
  map_set(global target_map ${target_map})
  function(target_register target_name)
    map_new()
    ans(tgt)
    map_set(${tgt} name "${target_name}")
    map_set(${tgt} project_name ${project_name})
    map_append(global targets ${tgt})
    map_append(global target_names ${target_name}) 
    map_get(global target_map)
    ans(target_map)
    map_set(${target_map} ${target_name} ${tgt}) 
    project_object()
    ans(proj)
    if(proj)
      map_append(${proj} targets ${tgt})
    endif()
    return_ref(tgt)
  endfunction()
  target_register(${target_name} ${ARGN})
  return_ans()
endfunction()





# File: source/cmake/targets/target_set.cmake


function(target_set tgt_name key)
	set_property(
		TARGET "${tgt_name}"
		PROPERTY "${key}"
		${ARGN}
		)
	creturn()
endfunction()

# File: source/cmake/targets/target_version_info.cmake

## adds version info to the specified target
## heavily inspired by https://github.com/halex2005/CMakeHelpers
function(target_version_info)
  arguments_extract_typed_values(0 ${ARGC} 
        <target:<string>>       
        [--icon:<path>=project.ico]
        [--version:<semver>=1.0.0]
        [--revision:<int>=0]
        [--company:<string>]
        [--description:<string>]
        [--internal_name:<string>]
        [--original_file_name:<string>]
        [--bundle:<string>]
        [--copyright:<int>]   #year
        [--verbose]            #verbose output
      )

if(NOT CMAKE_HOST_WIN32)
  message(WARNING "currently only supported under windows")
  creturn()
endif()

if(NOT EXISTS "${icon}")
  set(icon "")
endif()



  if(NOT comment)
    semver_format(${version})
    ans(formatted)
    set(comment "${target} in version ${formatted}")
  endif()


map()
    kv(version "${version}")
    kv(product_name "${target}")
    kv(icon_path "${icon}")
    kv(revision "${revision}")
    kv(comments "${comment}")
    kv(company "${company}")
    kv(description "${description}")
    kv(internal_name "${internal_name}")
    kv(original_file_name "${original_file_name}")
    kv(bundle "${bundle}")
    kv(copyright "(c) ${copyright}")
  end()
  ans(productInfo)





# format the include file
  format("#pragma once

#ifndef PRODUCT_VERSION_MAJOR
#define PRODUCT_VERSION_MAJOR {productInfo.version.major}
#endif

#ifndef PRODUCT_VERSION_MINOR
#define PRODUCT_VERSION_MINOR {productInfo.version.minor}
#endif

#ifndef PRODUCT_VERSION_PATCH
#define PRODUCT_VERSION_PATCH {productInfo.version.patch}
#endif

#ifndef PRODUCT_VERSION_BUILD
#define PRODUCT_VERSION_BUILD {productInfo.revision}
#endif

#ifndef FILE_VERSION_MAJOR
#define FILE_VERSION_MAJOR {productInfo.version.major}
#endif

#ifndef FILE_VERSION_MINOR
#define FILE_VERSION_MINOR {productInfo.version.minor}
#endif

#ifndef FILE_VERSION_PATCH
#define FILE_VERSION_PATCH {productInfo.version.patch}
#endif

#ifndef FILE_VERSION_BUILD
#define FILE_VERSION_BUILD {productInfo.revision}
#endif

#ifndef __TO_STRING
#define __TO_STRING_IMPL(x) #x
#define __TO_STRING(x) __TO_STRING_IMPL(x)
#endif

#define PRODUCT_VERSION_MAJOR_MINOR_STR        __TO_STRING(PRODUCT_VERSION_MAJOR) \".\" __TO_STRING(PRODUCT_VERSION_MINOR)
#define PRODUCT_VERSION_MAJOR_MINOR_PATCH_STR  PRODUCT_VERSION_MAJOR_MINOR_STR \".\" __TO_STRING(PRODUCT_VERSION_PATCH)
#define PRODUCT_VERSION_FULL_STR               PRODUCT_VERSION_MAJOR_MINOR_PATCH_STR \".\" __TO_STRING(PRODUCT_VERSION_BUILD)
#define PRODUCT_VERSION_RESOURCE               PRODUCT_VERSION_MAJOR,PRODUCT_VERSION_MINOR,PRODUCT_VERSION_PATCH,PRODUCT_VERSION_BUILD
#define PRODUCT_VERSION_RESOURCE_STR           PRODUCT_VERSION_FULL_STR \"\\0\"

#define FILE_VERSION_MAJOR_MINOR_STR        __TO_STRING(FILE_VERSION_MAJOR) \".\" __TO_STRING(FILE_VERSION_MINOR)
#define FILE_VERSION_MAJOR_MINOR_PATCH_STR  FILE_VERSION_MAJOR_MINOR_STR \".\" __TO_STRING(FILE_VERSION_PATCH)
#define FILE_VERSION_FULL_STR               FILE_VERSION_MAJOR_MINOR_PATCH_STR \".\" __TO_STRING(FILE_VERSION_BUILD)
#define FILE_VERSION_RESOURCE               FILE_VERSION_MAJOR,FILE_VERSION_MINOR,FILE_VERSION_PATCH,FILE_VERSION_BUILD
#define FILE_VERSION_RESOURCE_STR           FILE_VERSION_FULL_STR \"\\0\"

#ifndef PRODUCT_ICON
#define PRODUCT_ICON \"{productInfo.icon_path}\"
#endif

#ifndef PRODUCT_COMMENTS
#define PRODUCT_COMMENTS           \"{productInfo.comments}\\0\"
#endif

#ifndef PRODUCT_COMPANY_NAME
#define PRODUCT_COMPANY_NAME       \"{productInfo.company}\\0\"
#endif

#ifndef PRODUCT_COMPANY_COPYRIGHT
#define PRODUCT_COMPANY_COPYRIGHT  \"{productInfo.copyright}\\0\"
#endif

#ifndef PRODUCT_FILE_DESCRIPTION
#define PRODUCT_FILE_DESCRIPTION   \"{productInfo.description}\\0\"
#endif

#ifndef PRODUCT_INTERNAL_NAME
#define PRODUCT_INTERNAL_NAME      \"{productInfo.internal_name}\\0\"
#endif

#ifndef PRODUCT_ORIGINAL_FILENAME
#define PRODUCT_ORIGINAL_FILENAME  \"{productInfo.original_file_name}\\0\"
#endif

#ifndef PRODUCT_BUNDLE
#define PRODUCT_BUNDLE             \"{productInfo.bundle}\\0\"
#endif
")
ans(versionInfoTemplate)

set(iconComment "//")
if(icon)
  set(iconComment "")
endif()

# format the resource file
format("
#include \"VersionInfo.h\"
#include \"winres.h\"

${iconComment}IDI_ICON1               ICON                    PRODUCT_ICON

LANGUAGE LANG_INVARIANT, SUBLANG_NEUTRAL

VS_VERSION_INFO VERSIONINFO
    FILEVERSION FILE_VERSION_RESOURCE
    PRODUCTVERSION PRODUCT_VERSION_RESOURCE
    FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
    FILEFLAGS 0x1L
#else
    FILEFLAGS 0x0L
#endif
    FILEOS 0x4L
    FILETYPE 0x1L
    FILESUBTYPE 0x0L
BEGIN
    BLOCK \"StringFileInfo\"
    BEGIN
        BLOCK \"041904b0\"
        BEGIN
            VALUE \"Comments\", PRODUCT_COMMENTS
            VALUE \"CompanyName\", PRODUCT_COMPANY_NAME
            VALUE \"FileDescription\", PRODUCT_FILE_DESCRIPTION
            VALUE \"FileVersion\", FILE_VERSION_RESOURCE_STR
            VALUE \"InternalName\", PRODUCT_INTERNAL_NAME
            VALUE \"LegalCopyright\", PRODUCT_COMPANY_COPYRIGHT
            VALUE \"OriginalFilename\", PRODUCT_ORIGINAL_FILENAME
            VALUE \"ProductName\", PRODUCT_BUNDLE
            VALUE \"ProductVersion\", PRODUCT_VERSION_RESOURCE_STR
        END
    END
    BLOCK \"VarFileInfo\"
    BEGIN
        VALUE \"Translation\", 0x419, 1200
    END
END
")
ans(resourceTemplate)

  path("${CMAKE_CURRENT_BINARY_DIR}/VersionInfo.h")
  ans(versionInfoHeaderFile)

  path("${CMAKE_CURRENT_BINARY_DIR}/version.rc")
  ans(versionResourceFile)

  fwrite("${versionInfoHeaderFile}" "${versionInfoTemplate}")
  fwrite("${versionResourceFile}" "${resourceTemplate}")

  target_sources(${target} PRIVATE "${versionInfoHeaderFile}" "${versionResourceFile}")


if(verbose)
  message(INFO "added version information to target")
  message(INFO "  version header file @ ${versionInfoHeaderFile}")
  message(INFO "  resource file       @ ${versionResourceFile}")
  json_print("${productInfo}")
endif()

endfunction()

# File: source/cmakepp/cmakepp.cmake

## 
## executes the cmakepp command line as a separate process
##
## 
function(cmakepp)
  cmakepp_config(base_dir)
  ans(base_dir)
  cmake("-P" "${base_dir}/cmakepp.cmake" ${ARGN})
  return_ans()    
endfunction()



# File: source/cmakepp/cmakepp_cli.cmake

function(cmakepp_cli)
    set(args ${ARGN})

    if (NOT args)
        ## get command line args and remove executable -P and script file
        commandline_args_get(--no-script)
        ans(args)
    endif ()

    list_extract_flag(args --timer)
    ans(timer)
    list_extract_flag(args --silent)
    ans(silent)
    list_extract_labelled_value(args --select)
    ans(select)

    ## get format
    list_extract_flag(args --json)
    ans(json)
    list_extract_flag(args --qm)
    ans(qm)
    list_extract_flag(args --table)
    ans(table)
    list_extract_flag(args --csv)
    ans(csv)
    list_extract_flag(args --xml)
    ans(xml)
    list_extract_flag(args --plain)
    ans(plain)
    list_extract_flag(args --ini)
    ans(ini)

    set(lazy_cmake_code)
    foreach (arg ${args})
        cmake_string_escape("${arg}")
        set(lazy_cmake_code "${lazy_cmake_code} ${__ans}")
    endforeach ()

    #string_combine(" " ${args})
    #ans(lazy_cmake_code)

    lazy_cmake("${lazy_cmake_code}")
    ans(cmake_code)

    ## execute code
    set_ans("")
    if (timer)
        timer_start(timer)
    endif ()
    eval("${cmake_code}")
    ans(result)

    if (timer)
        timer_print_elapsed(timer)
    endif ()

    if (select)
        string(REGEX REPLACE "@([^ ]*)" "{result.\\1}" select "${select}")
        format("${select}")
        ans(result)
        # assign(result = "result${select}")
    endif ()

    ## serialize code
    if (json)
        json_indented("${result}")
        ans(result)
    elseif (ini)
        ini_serialize("${result}")
        ans(result)
    elseif (qm)
        qm_serialize("${result}")
        ans(result)
    elseif (table)
        table_serialize("${result}")
        ans(result)
    elseif (csv)
        csv_serialize("${result}")
        ans(result)
    elseif (xml)
        xml_serialize("${result}")
        ans(result)
    elseif (plain)

    else ()
        json_indented("${result}")
        ans(result)
    endif ()

    ## print code
    if (NOT silent)
        echo("${result}")
    endif ()
    return_ref(result)
endfunction()




# File: source/cmakepp/cmakepp_compile.cmake

## cmakepp_compile()
##
## compiles cmakepp into a single file which is faster to include
function(cmakepp_compile target_file)
    path_qualify(target_file)
    cmakepp_config(base_dir)
    ans(base_dir)

    file(STRINGS "${base_dir}/cmakepp.cmake" cmakepp_main_file)

    file(WRITE "${target_file}" "##  CMake++ Compiled module\n\n")

    foreach (line ${cmakepp_main_file})
        if ("_${line}" STREQUAL "_include(\"\${cmakepp_base_dir}/source/core/require.cmake\")")
        elseif ("_${line}" STREQUAL "_include(\"\${cmakepp_base_dir}/source/core/return/creturn.cmake\")")
            file(READ "${base_dir}/source/core/return/creturn.cmake" content)
            file(APPEND "${target_file}" "\n\n\n${content}\n\n")
        elseif ("_${line}" STREQUAL "_include(\"\${cmakepp_base_dir}/source/type/parameter_definition.cmake\")")
            file(READ "${base_dir}/source/type/parameter_definition.cmake" content)
            file(APPEND "${target_file}" "\n\n\n${content}\n\n")
        elseif ("_${line}" STREQUAL "_require(\"\${cmakepp_base_dir}/source/*.cmake\")")
            file(GLOB_RECURSE files "${base_dir}/source/**.cmake")
            foreach (file ${files})
                file(READ "${file}" content)
                file(RELATIVE_PATH rel_path "${base_dir}" "${file}")
                file(APPEND "${target_file}" "\n# File: ${rel_path}\n\n${content}\n")
            endforeach ()
        elseif ("_${line}" STREQUAL "_include(\"\${cmakepp_base_dir}/source/task/task_enqueue.cmake\")")
            file(READ "${base_dir}/source/task/task_enqueue.cmake" content)
            file(APPEND "${target_file}" "\n\n\n${content}\n\n")
        else ()
            file(APPEND "${target_file}" "${line}\n")
        endif ()
    endforeach ()
    message("Building ${target_file} done")
endfunction()


# File: source/cmakepp/cmakepp_compile_docs.cmake

## 
## goes through all of cmakepp's README.md.in files and generates them
function(cmakepp_compile_docs)
  cmakepp_config(base_dir)
  ans(base_dir)
  file(GLOB_RECURSE template_paths "${base_dir}/**README.md.in")
  
  foreach(template_path ${template_paths})
      get_filename_component(template_dir "${template_path}" PATH)
      set(output_file "${template_dir}/README.md")
      message("generating ${output_file}")
      template_run_file("${template_path}")
      ans(generated_content)
      fwrite("${output_file}" "${generated_content}")
  endforeach()

endfunction()

# File: source/cmakepp/cmakepp_project_cli.cmake

## 
##
## invokes the cmakepp project command line interface
function(cmakepp_project_cli)
    #commandline_args_get(--no-script)
    #ans(args)
    set(args ${ARGN})

    list_extract_any_flag(args -g --global)
    ans(global)

    list_extract_any_flag(args -v --verbose)
    ans(verbose)

    if (verbose)

        event_addhandler("on_log_message" "[](entry)message(FORMAT '{entry.function}: {entry.message}')")
        event_addhandler("project_on_opening" "[](proj) message(FORMAT '{event.event_id}: {proj.content_dir}'); message(PUSH)")
        event_addhandler("project_on_opened" "[](proj) message(FORMAT '{event.event_id}')")
        event_addhandler("project_on_loading" "[](proj) message(FORMAT '{event.event_id}'); message(PUSH)")
        event_addhandler("project_on_package_loading" "[](proj pack) message(FORMAT '{event.event_id}: {pack.uri}'); message(PUSH)")
        event_addhandler("project_on_package_loaded" "[](proj pack)  message(POP); message(FORMAT '{event.event_id}: {pack.uri}')")
        event_addhandler("project_on_package_reload" "[](proj pack)   message(FORMAT '{event.event_id}: {pack.uri}')")
        event_addhandler("project_on_package_cycle" "[](proj pack)   message(FORMAT '{event.event_id}: {pack.uri}')")
        event_addhandler("project_on_package_unloading" "[](proj pack) message(FORMAT '{event.event_id}: {pack.uri}'); message(PUSH)")
        event_addhandler("project_on_package_unloaded" "[](proj pack)  message(POP); message(FORMAT '{event.event_id}: {pack.uri}')")
        event_addhandler("project_on_package_materializing" "[](proj pack) message(FORMAT '{event.event_id}: {pack.uri}'); message(PUSH)")
        event_addhandler("project_on_package_materialized" "[](proj pack)  message(POP); message(FORMAT '{event.event_id}: {pack.uri} => {pack.content_dir}')")
        event_addhandler("project_on_package_dematerializing" "[](proj pack) message(FORMAT '{event.event_id}: {pack.uri}'); message(PUSH)")
        event_addhandler("project_on_package_dematerialized" "[](proj pack)  message(POP); message(FORMAT '{event.event_id}: {pack.uri}')")
        event_addhandler("project_on_loaded" "[](proj) message(POP); message(FORMAT '{event.event_id}') ")
        event_addhandler("project_on_closing" "[](proj) message(FORMAT '{event.event_id}'); message(POP)")
        event_addhandler("project_on_closed" "[](proj) message(FORMAT '{event.event_id}: {proj.content_dir}')")
        event_addhandler("project_on_dependency_configuration_changed" "[](proj) message(FORMAT '{event.event_id}: {{ARGN}}')")
        event_addhandler("project_on_dependencies_materializing" "[](proj ) message(FORMAT '{event.event_id}'); message(PUSH)")
        event_addhandler("project_on_dependencies_materialized" "[](proj )  message(POP); message(FORMAT '{event.event_id}')")
        event_addhandler("project_on_package_ready" "[](proj pack)   message(FORMAT '{event.event_id}: {pack.uri}')")
        event_addhandler("project_on_package_unready" "[](proj pack)   message(FORMAT '{event.event_id}: {pack.uri}')")
    endif ()

    list_extract_flag(args --save)
    ans(save)

    list_extract_labelled_value(args --project)
    ans(project_dir)

    if (global)
        dir_ensure_exists("~/.cmakepp")
        project_read("~/.cmakepp")
        ans(project)
        assign(project.project_descriptor.is_global = 'true')
    else ()
        project_read("${project_dir}")
        ans(project)
    endif ()

    list_pop_front(args)
    ans(cmd)

    if (NOT cmd)
        set(cmd run)
    endif ()

    if ("${cmd}" STREQUAL "init")
        list_pop_front(args)
        ans(path)
        project_open("${path}")
        ans(project)
    endif ()

    if (NOT project)
        error("no project available")
        creturn()
    endif ()

    map_tryget(${project} project_descriptor)
    ans(project_descriptor)
    map_tryget(${project_descriptor} package_source)
    ans(package_source)
    if (NOT package_source)
        message("no package source found")
        default_package_source()
        ans(package_source)
        map_set(${project_descriptor} package_source ${package_source})
    endif ()


    if ("${cmd}" STREQUAL "init")
    elseif ("${cmd}" STREQUAL "get")

        if ("${args}" MATCHES "(.+)\\((.*)\\)$")
            set(path "${CMAKE_MATCH_1}")
            set(call (${CMAKE_MATCH_2}))
        else ()
            set(call)
            set(path ${args})
        endif ()
        assign(res = "project.${path}" ${call})
    elseif ("${cmd}" STREQUAL "set")
        list_pop_front(args)
        ans(path)
        set(call false)
        if ("${path}_" STREQUAL "call_")
            list_pop_front(args)
            ans(path)
            set(call true)
        endif ()

        if (NOT path)
            error("no path specified")
            creturn()
        endif ()
        if (NOT call)
            assign("!project.${path}" = "'${args}'")
        else ()
            list_pop_front(args)
            ans(func)
            assign("!project.${path}" = "${func}" (${args}))
        endif ()
        set(save true)
        assign(res = "project.${path}")

    elseif ("${cmd}" STREQUAL "run")
        package_handle_invoke_hook("${project}" cmakepp.hooks.run "${project}" "${project}" ${args})
        ans(res)
    else ()
        call("project_${cmd}" ("${project}" ${args}))
        ans(res)
    endif ()

    project_write(${project})
    return_ref(res)

endfunction()

# File: source/cmakepp/cmakepp_require.cmake

## can be used as a standalone file to get a working copy of cmakepp
function(cmakepp_require)
    set(installation_dir ${ARGN})
    if ("${installation_dir}_" STREQUAL "_")
        set(installation_dir "${CMAKE_CURRENT_BINARY_DIR}/cmakepp")
    endif ()

    ## prefer local verison
    if (EXISTS "${installation_dir}/cmakepp.cmake")
        message(STATUS "Using CMake++ from local installation")
        include("${installation_dir}/cmakepp.cmake")
        creturn()
    endif ()

    ## prefer version
    if (EXISTS "$ENV{CMAKEPP_PATH}")
        message(STATUS "Using CMake++ from path")
        include("$ENV{CMAKEPP_PATH}")
        creturn()
    endif ()

    ## download cmakepp
    set(git_uri "https://github.com/AnotherFoxGuy/cmakepp")
    set(cmakepp_uri "${git_uri}/releases/download/v0.0.3/cmakepp.cmake")
    set(target_file "${CMAKE_CURRENT_BINARY_DIR}/__cmakepp.cmake")

    message(STATUS "Installing CMake++")
    message(STATUS "\n installation_dir: ${installation_dir}")


    file(DOWNLOAD "${cmakepp_uri}" "${target_file}" STATUS status)
    include("${target_file}")
    file(REMOVE "${target_file}")

    ## uses git functionality of cmakepp v0.0.3
    ## to download the current git repository
    git(clone "${git_uri}.git" "${installation_dir}")

    cmake(-P "${installation_dir}/cmakepp.cmake" cmakepp_compile "${installation_dir}/tmp/cmakepp.cmake")
    file(READ "${installation_dir}/tmp/cmakepp.cmake")
    rm(-r "${installation_dir}")
    file(WRITE "${installation_dir}/cmakepp.cmake")

    ## so this line causes a segmentation fault so i'm just gonna ignore it for now...
    ## include("${installation_dir}/cmakepp.cmake")

    creturn()
endfunction()

# File: source/cmakepp/cmakepp_setup_environment.cmake

## sets up the cmakepp environment 
## creates aliases
##    icmake - interactive cmakepp
##    cmakepp - commandline interface to cmakepp 
##    pkg - package manager command line interface
function(cmakepp_setup_environment)
    cmakepp_config(base_dir)
    ans(base_dir)

    message(STATUS "creating alias `icmakepp`")
    alias_create("icmakepp" "cmake -P ${base_dir}/cmakepp.cmake icmake")
    message(STATUS "creating alias `cmakepp`")
    alias_create("cmakepp" "cmake -P ${base_dir}/cmakepp.cmake")
    message(STATUS "creating alias `pkg`")
    alias_create("pkg" "cmake -P ${base_dir}/cmakepp.cmake cmakepp_project_cli")
    message(STATUS "creating alias `cml`")
    alias_create("cml" "cmake -P ${base_dir}/cmakepp.cmake cmakelists_cli")
    message(STATUS "setting CMAKEPP_PATH to ${base_dir}/cmakepp.cmake ")

    shell_env_set(CMAKEPP_PATH "${base_dir}/cmakepp.cmake")

endfunction()

# File: source/cmakepp/cmakepp_tool.cmake

function(cmakepp_tool)
  set(args ${ARGN})
  list_pop_front(args)
  ans(path)

  pushd("${path}")
    cd("build" --create)
    cmake(
      -DCMAKE_RUNTIME_OUTPUT_DIRECTORY=bin 
      -DCMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG=bin 
      .. --process-handle)
    ans(handle)

    cmake(--build . --process-handle)
    ans(handle)

    json_print(${handle})

  popd()
  execute_process(COMMAND "${path}/build/bin/tool")
  return_ans()
endfunction()

# File: source/collections/encoded_list/encoded_list.cmake

## creates encoded lists from the specified arguments
function(encoded_list)
  arguments_encoded_list(0 ${ARGC})
  set(__ans "${__ans}" PARENT_SCOPE)
endfunction()




# File: source/collections/encoded_list/encoded_list_append.cmake


  function(encoded_list_append __lst)
    string_encode_list("${ARGN}")
    list(APPEND "${__lst}" ${__ans})
    set(${__lst} ${${__lst}} PARENT_SCOPE)
  endfunction()


# File: source/collections/encoded_list/encoded_list_decode.cmake



## faster
function(encoded_list_decode str)
  string_codes()
  eval("
  function(encoded_list_decode str)
    if(\"\${str}_\" STREQUAL \"${empty_code}_\")
      creturn()
    endif()
    string(REPLACE \"${bracket_open_code}\" \"[\"  str \"\${str}\")
    string(REPLACE \"${bracket_close_code}\" \"]\"  str \"\${str}\")
    string(REPLACE \"${semicolon_code}\" \";\"  str \"\${str}\")
    set(__ans \"\${str}\" PARENT_SCOPE)
  endfunction()
  ")
  encoded_list_decode("${str}")
  return_ans()
endfunction()


# File: source/collections/encoded_list/encoded_list_get.cmake




  macro(encoded_list_get __lst idx)
    list(GET ${__lst} ${idx} __ans)
    string_decode_list("${__ans}")
  endmacro()


# File: source/collections/encoded_list/encoded_list_peek_back.cmake


  function(encoded_list_peek_back __lst)
    list_peek_back(${__lst})
    ans(back)
    string_decode_list("${back}")
    return_ans()
  endfunction()

# File: source/collections/encoded_list/encoded_list_peek_front.cmake


  function(encoded_list_peek_front __lst)
    list_peek_front(${__lst})
    ans(front)
    string_decode_list("${front}")
    return_ans()
  endfunction()


# File: source/collections/encoded_list/encoded_list_pop_back.cmake


  function(encoded_list_pop_back __lst)
    list_pop_back(${__lst})
    ans(back)
    set(${__lst} ${${__lst}} PARENT_SCOPE)
    string_decode_list("${back}")
    return_ans()
  endfunction()


# File: source/collections/encoded_list/encoded_list_pop_front.cmake



  function(encoded_list_pop_front __lst)
    list_pop_front(${__lst})
    ans(front)
    set(${__lst} ${${__lst}} PARENT_SCOPE)
    string_decode_list("${front}")
    return_ans()
  endfunction()



# File: source/collections/encoded_list/encoded_list_remove_at.cmake


  macro(encoded_list_remove_at __lst)
    list_remove_at(${__lst} ${ARGN})
  endmacro()

# File: source/collections/encoded_list/encoded_list_remove_item.cmake




  function(encoded_list_remove_item __lst)
    string_encode_list("${ARGN}")
    if(NOT ${__lst})
      creturn()
    endif()
    list(REMOVE_ITEM ${__lst} ${__ans})
    set(${__lst} ${${__lst}} PARENT_SCOPE)
    creturn()
  endfunction()
  

# File: source/collections/encoded_list/encoded_list_set.cmake


  function(encoded_list_set __lst idx)
    string_encode_list("${ARGN}")
    list_replace_at(${__lst} ${idx} ${__ans})
    set(${__lst} ${${__lst}} PARENT_SCOPE)
  endfunction()


# File: source/collections/encoded_list/encoded_list_to_cmake_string.cmake


function(encoded_list_to_cmake_string)
  ## free token 
  set(result "${ARGN}")
  string(REPLACE ";" "" result "${result}")
  cmake_string_escape2("${result}")
  ans(result)
  string(REPLACE "" " " result "${result}")
  encoded_list_decode("${result}")
  ans(result)
  return_ref(result)
endfunction()

# File: source/collections/encoded_list/is_encoded_list.cmake

##
##
## returns true iff the arguments passed are in encoded list format
function(is_encoded_list)
  if("${ARGN}" MATCHES "[]")
    set(__ans true PARENT_SCOPE)
  else()
    set(__ans false PARENT_SCOPE)
  endif()
endfunction()

# File: source/collections/index_range.cmake

## returns a list of numbers [ start_index, end_index)
## if start_index equals end_index the list is empty
## if end_index is less than start_index then the indices are in declining order
## ie index_range(5 3) => 5 4
## (do not confuse this function with the `range_` functions)
function(index_range start_index end_index)
  
  if(${start_index} EQUAL ${end_index})
    creturn()
  endif()

  set(result)
  if(${end_index} LESS ${start_index})
    set(increment -1)
    math(EXPR end_index "${end_index} + 1")
  else()
    set(increment 1)
    math(EXPR end_index "${end_index} - 1")
  
  endif()
  
  foreach(i RANGE ${start_index} ${end_index} ${increment})
    list(APPEND result ${i})
  endforeach()
  creturn(${result})
endfunction()

# File: source/collections/linked_list/linked_list_insert_after.cmake




## `(<linked list> <where: <linked list node> = <linked list>.tail >  <any>... )-><linked list node>`
## 
## inserts a new linked list node after `where`. if where is null then the tail of the list is used.
## the arguments passed after where are used as the value of the new node
function(linked_list_insert_after linked_list where)
  
  linked_list_node_new(${ARGN})
  ans(node)

  if(NOT where)
    map_tryget(${linked_list} tail)
    ans(where)
    if(NOT where)
      map_set(${linked_list} head ${node})
      map_set(${linked_list} tail ${node})
      creturn(${node})
    endif()
  endif() 

  map_tryget(${where} next)
  ans(next)

  map_set_hidden(${node} previous ${where})
  map_set_hidden(${node} next ${next})
  map_set_hidden(${where} next ${node})
  if(next)
    map_set_hidden(${next} previous ${node})
  else()
    map_set(${linked_list} tail ${node})
  endif()

  creturn(${node})
endfunction()


# File: source/collections/linked_list/linked_list_insert_before.cmake


## `(<linked list> <where: <linked list node> = <linked list>.head)-><linked list node>`
##
## inserts a new linked list node into the linked list before where and returns it.
function(linked_list_insert_before linked_list where)
  linked_list_node_new(${ARGN})
  ans(node)

  if(NOT where)
    map_tryget(${linked_list} tail)
    ans(where)
    if(NOT where)
      map_set(${linked_list} head ${node})
      map_set(${linked_list} tail ${node})
      creturn(${node})
    endif()
  endif() 

  map_tryget(${where} previous)
  ans(previous)

  map_set_hidden(${node} next ${where})
  map_set_hidden(${node} previous ${previous})
  map_set_hidden(${where} previous ${node})

  if(previous)
    map_set_hidden(${previous} next ${node})
  else()
    map_set(${linked_list} head ${node})
  endif()

  creturn(${node})
endfunction()


# File: source/collections/linked_list/linked_list_new.cmake

## `()-><linked list>`
## 
## creates a new linked list 
## 
## ```
## <linked list node> ::= <null> | {
##   head: <linked list node>|<null>
##   tail: <linekd list node>|<null>
## }
## ```
function(linked_list_new)
  map_new()
  ans(linked_list) 

  map_set(${linked_list} head)
  map_set(${linked_list} tail)

  return_ref(linked_list)  
endfunction()


# File: source/collections/linked_list/linked_list_node_new.cmake


## `(<any>...)-><linked list node>`
## 
## creates a new linked list node which contains the value specified
## 
function(linked_list_node_new)
  map_new()
  ans(node)
  map_set_special(${node} $type linked_list_node)
  address_set(${node} ${ARGN})
  creturn(${node})
endfunction()

# File: source/collections/linked_list/linked_list_peek_back.cmake

function(linked_list_peek_back linked_list)
  map_tryget("${linked_list}" tail)
  ans(tail)
  if(NOT tail)
    creturn()
  endif()

  if("${ARGN}" STREQUAL "--node")
    creturn(${tail})
  endif() 

  address_get("${tail}")
  return_ans()
endfunction()

# File: source/collections/linked_list/linked_list_peek_front.cmake

function(linked_list_peek_front linked_list)
  map_tryget("${linked_list}" head)
  ans(head)
  if(NOT head)
    creturn()
  endif()

  if("${ARGN}" STREQUAL "--node")
    creturn(${head})
  endif()    

  address_get("${head}")
  return_ans()
endfunction()


# File: source/collections/linked_list/linked_list_pop_back.cmake



function(linked_list_pop_back linked_list)
  map_tryget(${linked_list} tail)
  ans(tail)
  if(NOT tail)
    creturn()
  endif()
  linked_list_remove("${linked_list}" "${tail}")
  if("${ARGN}_" STREQUAL "--node_")
    creturn("${tail}")
  endif()
  address_get("${tail}")
  return_ans()
endfunction()

# File: source/collections/linked_list/linked_list_pop_front.cmake

function(linked_list_pop_front linked_list) 
  map_tryget("${linked_list}" head)
  ans(head)
  if(NOT head)
    creturn()
  endif()
  linked_list_remove("${linked_list}" "${head}")
  if("${ARGN}_" STREQUAL "--node_")
    creturn(${head})
  endif()
  address_get("${head}")
  return_ans()
endfunction()


# File: source/collections/linked_list/linked_list_push_back.cmake


  function(linked_list_push_back linked_list)
    linked_list_insert_after("${linked_list}" "" ${ARGN})
    return_ans()
  endfunction()
  

# File: source/collections/linked_list/linked_list_push_front.cmake

function(linked_list_push_front linked_list)
  linked_list_insert_before("${linked_list}" "" ${ARGN})
  return_ans()
endfunction()


# File: source/collections/linked_list/linked_list_remove.cmake


  function(linked_list_remove linked_list where)
    map_import_properties("${where}" previous next)

    if(next)
      map_set_hidden("${next}" previous "${previous}")
    else()
      map_set("${linked_list}" tail "${previous}")
    endif()

    if(previous)
      map_set_hidden("${previous}" next "${next}")
    else()
      map_set("${linked_list}" head "${next}")
    endif()

    creturn()
  endfunction() 

# File: source/collections/linked_list/linked_list_replace.cmake

## `(<linked list> <where:<linked list node>> <any>...)-><linked list node>`
##  
## replaces the specified linked list node and returns new node
function(linked_list_replace linked_list where)
  map_import_properties(${where} previous next)
  linked_list_node_new(${ARGN})
  ans(node)
  map_set_hidden(${node} next ${next})
  map_set_hidden(${node} previous ${previous})
  if(next)
    map_set_hidden(${next} previous ${node})
  else()
    map_set(${linked_list} tail "${node}")
  endif()
  if(previous)
    map_set_hidden(${previous} next ${node})
  else()
    map_set(${linked_list} head "${node}")
  endif()
  creturn(${node})
endfunction()

# File: source/collections/list_after.cmake

## `(<list ref> <key:<string>>)-><any ....>`
##
## returns the elements after the specified key
function(list_after __lst __key)
  list(LENGTH ${__lst} __len)
  if(NOT __len)
    creturn()
  endif()
  list(FIND ${__lst} "${__key}" __idx)
  if(__idx LESS 0)
    creturn()
  endif()
  math(EXPR __idx "${__idx} + 1")
  list_split(__ __rhs ${__lst} ${__idx})
  return_ref(__rhs)
endfunction()


# File: source/collections/list_all.cmake

## `(<list&> <predicate:<[](<any>)->bool>>)-><bool>` 
##
## returns true iff predicate holds for all elements of `<list>` 
## 
function(list_all __list_all_lst __list_all_predicate)
  function_import("${__list_all_predicate}" as __list_all_predicate REDEFINE)
  foreach(it ${${__list_all_lst}})
    __list_all_predicate("${it}")
    ans(__list_all_match)
    if(NOT __list_all_match)
      creturn(false)
    endif()
  endforeach()
  creturn(true)
endfunction()

# File: source/collections/list_any.cmake

## `[](<list&> <predicate:<[](<any>)->bool>)-><bool>`
##
## returns true if there exists an element in `<list>` for which the `<predicate>` holds
function(list_any __list_any_lst __list_any_predicate)
  function_import("${__list_any_predicate}" as __list_any_predicate REDEFINE)

  foreach(__list_any_item ${${__list_any_lst}})
    __list_any_predicate("${__list_any_item}")
    ans(__list_any_predicate_holds)
    if(__list_any_predicate_holds)
      creturn(true)
    endif()
  endforeach()
  creturn(false)
endfunction()




# File: source/collections/list_append.cmake

## safe append (can also append empty element)
function(list_append __lst value)
  if("${value}_" STREQUAL "_")
    set(value ";")
    if("${${__lst}}_" STREQUAL "_")
      creturn()
    endif()
  endif()  
  set(${__lst} ${${__lst}} "${value}" PARENT_SCOPE)
  creturn()
endfunction()

# File: source/collections/list_at.cmake

## 
##
## returns all elements whose index are specfied
## 
function(list_at __list_at_lst)
  set(__list_at_result)
  foreach(__list_at_idx ${ARGN})
    list_get(${__list_at_lst} ${__list_at_idx})
    list(APPEND __list_at_result ${__ans})
  endforeach()
  return_ref(__list_at_result)
endfunction()

# File: source/collections/list_before.cmake

## `(<list&> <key:<string>>)-><any ....>`
##
## returns the elements before key
function(list_before __lst __key)
  list(LENGTH ${__lst} __len)
  if(NOT __len)
    creturn()
  endif()
  list(FIND ${__lst} "${__key}" __idx)
  if(__idx LESS 0)
    creturn()
  endif()
  math(EXPR __idx "${__idx} + 1")
  list_split(__lhs __ ${__lst} ${__idx})
  return_ref(__lhs)
endfunction()


# File: source/collections/list_check_items.cmake

## `(<list&> <query...>)-><bool>`
##  
## `<query> := <value>|'!'<value>|<value>'?'`
## 
## * checks to see that every value specified is contained in the list 
## * if the value is preceded by a `!` checks that the value is not in the list
## * if the value is succeeded by a `?` the value may or may not be contained
##
## returns true if all queries match
## 
function(list_check_items __lst)
  set(lst ${${__lst}})
  set(result 0)
  list(LENGTH ARGN len)

  foreach(item ${ARGN})
    set(negate false)
    set(optional false)
    if("${item}" MATCHES "^!(.+)$")
      set(item "${CMAKE_MATCH_1}")
      set(negate true)
    endif()
    if("${item}" MATCHES "^(.+)\\?$")
      set(item "${CMAKE_MATCH_1}")
      set(optional true)
    endif()

    list_contains(lst "${item}")
    ans(is_contained)

    if(false)
    elseif(    is_contained AND     negate AND     optional)
      list_remove(lst "${item}")
    elseif(    is_contained AND     negate AND NOT optional)
      creturn(false)
    elseif(    is_contained AND NOT negate AND     optional)
      list_remove(lst "${item}")
    elseif(    is_contained AND NOT negate AND NOT optional)
      list_remove(lst "${item}")
    elseif(NOT is_contained AND     negate AND     optional)
      list_remove(lst "${item}")
    elseif(NOT is_contained AND     negate AND NOT optional)
      list_remove(lst "${item}")
    elseif(NOT is_contained AND NOT negate AND     optional)
      list_remove(lst "${item}")
    elseif(NOT is_contained AND NOT negate AND NOT optional)
      creturn()
    endif()

   # print_vars(lst item is_contained negate optional)
  endforeach()

  list(LENGTH lst len)
  if(len)
    creturn(false)
  endif()
  creturn(true)
endfunction()

# File: source/collections/list_combinations.cmake

## `(<list&...>)-><any...>`
##
## returns all possible combinations of the specified lists
## e.g.
## ```
## set(range 0 1)
## list_combinations(range range range)
## ans(result)
## assert(${result} EQUALS 000 001 010 011 100 101 110 111)
## ```
##
function(list_combinations)
  set(lists ${ARGN})
  list_length(lists)
  ans(len)

  if(${len} LESS 1)
    creturn()
  elseif(${len} EQUAL 1)
    return_ref(${lists})
  elseif(${len} EQUAL 2)
    list_extract(lists __listA __listB)
    set(__result)
    foreach(elementA ${${__listA}})
      foreach(elementB ${${__listB}})
        list(APPEND __result "${elementA}${elementB}")
      endforeach()
    endforeach()
    return_ref(__result)
  else()
    list_pop_front(lists)
    ans(___listA)

    list_combinations(${lists})
    ans(___listB)

    list_combinations(${___listA} ___listB)
    return_ans()
  endif()
endfunction()

# File: source/collections/list_contains.cmake

## `(<list&> <element:<any...>>)-><bool>`
##
## returns true if list contains every element specified 
##
function(list_contains __list_contains_lst)
	foreach(arg ${ARGN})
		list(FIND ${__list_contains_lst} "${arg}" idx)
		if(${idx} LESS 0)
			creturn(false)
		endif()
	endforeach()
	creturn(true)
endfunction()

# File: source/collections/list_contains_any.cmake


function(list_contains_any __lst)
    if("${ARGC}" EQUAL "1")
    ## no items specified 
    creturn(true)
  endif()

  list(LENGTH ${__lst} list_len)
  if(NOT list_len)
    ## list is empty and items are specified -> list does not contain
    creturn(false)
  endif()


  foreach(item ${ARGN})
    list(FIND ${__lst} ${item} idx)
    if(idx GREATER -1)
      creturn(true)
    endif()

  endforeach() 
  creturn(false)
endfunction()

# File: source/collections/list_count.cmake

## `(<list&> <predicate:<[](<any>)-><bool>>> )-><uint>`
##
## counts all element for which the predicate holds 
function(list_count __list_count_lst __list_count_predicate)
  function_import("${__list_count_predicate}" as __list_count_predicate REDEFINE)
  set(__list_count_counter 0)
  foreach(__list_count_item ${${__list_count_lst}})
    __list_count_predicate("${__list_count_item}")
    ans(__list_count_match)
    if(__list_count_match)
      math(EXPR __list_count_counter "${__list_count_counter} + 1") 
    endif()
  endforeach()
  creturn("${__list_count_counter}")
endfunction()





# File: source/collections/list_equal.cmake

# comapres two lists with each other
# usage
# list_equal( 1 2 3 4 1 2 3 4)
# list_equal( listA listB)
# list_equal( ${listA} ${listB})
# ...
# COMPARATOR defaults to STREQUAL
# COMPARATOR can also be a lambda expression
# COMPARATOR can also be EQUAL
function(list_equal)
	set(options)
  	set(oneValueArgs COMPARATOR)
  	set(multiValueArgs)
  	set(prefix)
  	cmake_parse_arguments("${prefix}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
	#_UNPARSED_ARGUMENTS


	# get length of both lists

	list(LENGTH _UNPARSED_ARGUMENTS count)



	#if count is exactly two input could be list references
	if(${count} EQUAL 2)
		list(GET _UNPARSED_ARGUMENTS 0 ____listA)
		list(GET _UNPARSED_ARGUMENTS 1 ____listB)
		if(DEFINED ${____listA} AND DEFINED ${____listB})
			# recursive call and return
			list_equal(  ${${____listA}} ${${____listB}} COMPARATOR "${_COMPARATOR}")
			return_ans()
		endif()

	endif()

	set(listA)
	set(listB)




	math(EXPR single_count "${count} / 2")
	math(EXPR is_even "${count} % 2")
	if(NOT ${is_even} EQUAL "0")
		#element count is not divisible by two so the lists cannot be equal
		# because they do not have the same length

		creturn(false)

	else()
		# split input arguments into two
		list_split(listA listB _UNPARSED_ARGUMENTS ${single_count})
	#message("${_UNPARSED_ARGUMENTS} => ${listA} AND ${listB}")
	endif()


	# set default comparator to strequal
	if(NOT _COMPARATOR)
		set(_COMPARATOR "STREQUAL")
	endif()

	# depending on the comparator
	if(${_COMPARATOR} STREQUAL "STREQUAL")
		set(lambda "[](a b) eval_truth('{{a}}' STREQUAL '{{b}}')")
	elseif(${_COMPARATOR} STREQUAL "EQUAL")
		set(lambda "[](a b) eval_truth('{{a}}' EQUAL '{{b}}')")
	else()
		set(lambda "${_COMPARATOR}")
	endif()
	# import function string 
	function_import("${lambda}" as __list_equal_comparator REDEFINE)
		
	set(res)
	# compare list
	math(EXPR single_count "${single_count} - 1")
	foreach(i RANGE ${single_count})
		list(GET listA ${i} a)
		list(GET listB ${i} b)
		#message("comparing ${a} ${b}")
		__list_equal_comparator(${a} ${b})
		ans(res)
		if(NOT res)
			creturn(false)
		endif()
	endforeach()
	creturn(true)

endfunction()

# File: source/collections/list_erase.cmake

# removes the specified range from lst the start_index is inclusive and end_index is exclusive
#
macro(list_erase __list_erase_lst start_index end_index)
  list_without_range(${__list_erase_lst} ${start_index} ${end_index})
  ans(${__list_erase_lst})
endmacro()

# File: source/collections/list_erase_slice.cmake

# removes the specified range from lst and returns the removed elements
macro(list_erase_slice __list_erase_slice_lst start_index end_index)
  list_slice(${__list_erase_slice_lst} ${start_index} ${end_index})
  ans(__res)

  list_without_range(${__list_erase_slice_lst} ${start_index} ${end_index})
  ans(${__list_erase_slice_lst})
  set(__ans ${__res})
  #set(${__list_erase_slice_lst} ${rest} PARENT_SCOPE)
  #return_ref(res)
endmacro()





# File: source/collections/list_except.cmake

# return those elemnents of minuend that are not in subtrahend
function(list_except __list_except_minuend list_except_subtrahend)
	set(__list_except_result)
	foreach(__list_except_current ${${__list_except_minuend}})
		list(FIND ${list_except_subtrahend} "${__list_except_current}" __list_except_idx)
		if(${__list_except_idx} LESS 0)
			list(APPEND __list_except_result ${__list_except_current})
		endif()
	endforeach()
  return_ref(__list_except_result)
endfunction()

# File: source/collections/list_extract.cmake

# extracts elements from the list
# example
# set(lst 1 2  )
# list_extract(lst a b c)
# a contains 1
# b contains 2
# c contains nothing
# returns the rest of list
function(list_extract __list_extract_lst)
  set(__list_extract_list_tmp ${${__list_extract_lst}})
  set(args ${ARGN})
  while(true)
    list_pop_front( args)
    ans(current_arg)
    if(NOT current_arg)
      break()
    endif()
    list_pop_front( __list_extract_list_tmp)
    ans(current_value)
    set(${current_arg} ${current_value} PARENT_SCOPE)
  endwhile()
  return_ref(__list_extract_list_tmp)
endfunction()






# File: source/collections/list_extract_any_flag.cmake


# extracts all of the specified flags and returns true if any of them were found
function(list_extract_any_flag __list_extract_any_flag_lst)
  list_extract_flags("${__list_extract_any_flag_lst}" ${ARGN})
  set("${__list_extract_any_flag_lst}" ${${__list_extract_any_flag_lst}} PARENT_SCOPE)
  ans(flag_map)
  map_keys(${flag_map})
  ans(found_keys)
  list(LENGTH found_keys len)
  if(${len} GREATER 0)
    creturn(true)
  endif()
  creturn(false)
endfunction()




# File: source/collections/list_extract_any_labelled_value.cmake

## extracts any of the specified labelled values and returns as soon 
## the first labelled value is found
## lst contains its original elements without the labelled value 
function(list_extract_any_labelled_value __list_extract_any_labelled_value_lst)
  set(__list_extract_any_labelled_value_res)
  foreach(label ${ARGN})
    list_extract_labelled_value(${__list_extract_any_labelled_value_lst} ${label})
    ans(__list_extract_any_labelled_value_res)
    if(NOT "${__list_extract_any_labelled_value_res}_" STREQUAL "_")    
      break()
    endif()
  endforeach()
  set(${__list_extract_any_labelled_value_lst} ${${__list_extract_any_labelled_value_lst}}  PARENT_SCOPE)
  return_ref(__list_extract_any_labelled_value_res)
endfunction()


# File: source/collections/list_extract_flag.cmake

  #extracts a single flag from a list returning true if it was found
  # false otherwise. 
  # if flag exists multiple time online the first instance of the flag is removed
  # from the list
 function(list_extract_flag __list_extract_flag flag)
    list(FIND "${__list_extract_flag}" "${flag}" idx)
    if(${idx} LESS 0)
      creturn(false)
    endif()
    list(REMOVE_AT "${__list_extract_flag}" "${idx}") 
    set("${__list_extract_flag}" "${${__list_extract_flag}}" PARENT_SCOPE)
    creturn(true)
endfunction()



# File: source/collections/list_extract_flag_name.cmake

 ## extracts a flag from the list if it is found 
 ## returns the flag itself (usefull for forwarding flags)
  macro(list_extract_flag_name __lst __flag)
    list_extract_flag("${__lst}" "${__flag}")
    ans(__flag_was_found)
    set_ans("")
    if(__flag_was_found)
      if(NOT "${ARGN}_" STREQUAL "_")
        set_ans("${ARGN}")
      else()
        set_ans("${__flag}")
      endif()
    endif()
  endmacro()

# File: source/collections/list_extract_flags.cmake


# extracts all flags specified and returns a map with the key being the flag name if it was found and the value being set to tru
# e.g. list_extract_flags([a,b,c,d] a c e) -> {a:true,c:true}, [b,d]
function(list_extract_flags __list_extract_flags_lst)
  list_find_flags("${__list_extract_flags_lst}" ${ARGN})
  ans(__list_extract_flags_flag_map)
  map_keys(${__list_extract_flags_flag_map})
  ans(__list_extract_flags_found_flags)
  list_remove("${__list_extract_flags_lst}" ${__list_extract_flags_found_flags})
 # list(REMOVE_ITEM "${__list_extract_flags_lst}" ${__list_extract_flags_found_flags})
  set("${__list_extract_flags_lst}" ${${__list_extract_flags_lst}} PARENT_SCOPE)
  creturn(${__list_extract_flags_flag_map})
endfunction()


# File: source/collections/list_extract_labelled_keyvalue.cmake


    ## extracts a labelled key value (the label and the value if it exists)
    macro(list_extract_labelled_keyvalue __lst label)
      list_extract_labelled_value(${__lst} "${label}")
      ans(__lbl_value)
      if(NOT "${__lbl_value}_" STREQUAL "_")
        if(ARGN)
          set_ans("${ARGN};${__lbl_value}")
        else()
          set_ans("${label};${__lbl_value}")
        endif()
      else()
        set_ans("")
      endif()
    endmacro()

# File: source/collections/list_extract_labelled_value.cmake

# searchs for label in lst. if label is found 
# the label and its following value is removed
# and returned
# if label is found but no value follows ${ARGN} is returned
# if following value is enclosed in [] the brackets are removed
# this allows mulitple values to be returned ie
# list_extract_labelled_value(lstA --test1)
# if lstA is a;b;c;--test1;[1;3;4];d
# the function returns 1;3;4
function(list_extract_labelled_value lst label)
  # return nothing if lst is empty
  list_length(${lst})
  ans(len)
  if(NOT len)
    creturn()
  endif()
  # find label in list
  list_find(${lst} "${label}")
  ans(pos)
  
  if("${pos}" LESS 0)
    creturn()
  endif()

  eval_math("${pos} + 2")
  ans(end)


  if(${end} GREATER ${len} )
    eval_math("${pos} + 1")
    ans(end)
  endif()

  list_erase_slice(${lst} ${pos} ${end})
  ans(vals)

  list_pop_front(vals)
  ans(flag)
    

  # special treatment for [] values
  if("_${vals}" MATCHES "^_\\[.*\\]$")
    string_slice("${vals}" 1 -2)
    ans(vals)
  endif()


  if("${vals}_" STREQUAL "_")
    set(vals ${ARGN})
  endif()

  
  set(${lst} ${${lst}} PARENT_SCOPE)


  return_ref(vals)
endfunction()


# File: source/collections/list_extract_matches.cmake

## `(<&> <regex>...)-><any...>`
##
## removes all matches from the list and returns them
## sideffect: matches are removed from list
function(list_extract_matches __list_extract_matches_lst)
  list_regex_match(${__list_extract_matches_lst} ${ARGN})
  ans(matches)
  list_remove(${__list_extract_matches_lst} ${matches})
  #print_vars(matches __list_extract_matches_lst ${__list_extract_matches_lst})
  set(${__list_extract_matches_lst} ${${__list_extract_matches_lst}} PARENT_SCOPE)
  return_ref(matches)
endfunction()

# File: source/collections/list_find.cmake

# searchs lst for value and returns the first idx found
# returns -1 if value is not found
function(list_find __list_find_lst value)
    if (NOT ${__list_find_lst})
        creturn(-1)
    endif ()
    list(FIND ${__list_find_lst} "${value}" idx)
    return_ref(idx)
endfunction()






# File: source/collections/list_find_any.cmake

## returns the index of the one of the specified items
## if no element is found then -1 is returned 
## no guarantee is made on which item's index
## is returned 
function(list_find_any __list_find_any_lst )
  foreach(__list_find_any_item ${ARGN})
    list(FIND ${__list_find_any_lst} ${__list_find_any_item} __list_find_any_idx)
    if(${__list_find_any_idx} GREATER -1)
      creturn(${__list_find_any_idx})
    endif()
  endforeach()
  creturn(-1)
endfunction()


# File: source/collections/list_find_flags.cmake

## returns a map of all found flags specified as ARGN
##  
function(list_find_flags __list_find_flags_lst)
  map_new()
  ans(__list_find_flags_result)
  foreach(__list_find_flags_itm ${ARGN})
    list(FIND "${__list_find_flags_lst}" "${__list_find_flags_itm}" __list_find_flags_item)
    if(NOT "${__list_find_flags_item}" LESS 0)
      map_set(${__list_find_flags_result} "${__list_find_flags_itm}" true)
    endif()
  endforeach()
  creturn(${__list_find_flags_result})
endfunction()

# File: source/collections/list_fold.cmake

# folds the specified list into a single result by recursively applying the aggregator
function(list_fold lst aggregator)
  if(NOT "_${ARGN}" STREQUAL _folding)
    function_import("${aggregator}" as __list_fold_folder REDEFINE)
  endif()
  set(rst ${${lst}})
  list_pop_front(rst)
  ans(left)
  
  if("${rst}_" STREQUAL "_")
    creturn(${left})
  endif()


  list_fold(rst "" folding)
  ans(right)
  __list_fold_folder("${left}" "${right}")

  ans(res)

 # message("left ${left} right ${right} => ${res}")
  creturn(${res})
endfunction()



## faster non recursive version
function(list_fold lst aggregator)
  if(NOT "_${ARGN}" STREQUAL _folding)
    function_import("${aggregator}" as __list_fold_folder REDEFINE)
  endif()

  set(rst ${${lst}})
  list_pop_front(rst)
  ans(left)
  
  if("${rst}_" STREQUAL "_")
    creturn(${left})
  endif()

  set(prev "${left}")
  foreach(item ${rst})
    __list_fold_folder("${prev}" "${item}")
    ans(prev)
  endforeach()
  return_ref(prev)



endfunction()


# File: source/collections/list_get.cmake

## returns the item at the specified index
## the index is normalized (see list_normalize_index)
function(list_get __list_get_lst idx)
  list_normalize_index("${__list_get_lst}" "${idx}")
  ans(index)
  list_length("${__list_get_lst}")
  ans(len)
  if("${index}" LESS 0 OR "${index}" GREATER "${len}")
    creturn()
  endif()
  list(GET ${__list_get_lst} "${index}" value)
  return_ref(value)
endfunction()

# File: source/collections/list_get_labelled_value.cmake

## gets the labelled value from the specified list
## set(thelist a b c d)
## list_get_labelled_value(thelist b) -> c
function(list_get_labelled_value __list_get_labelled_value_lst __list_get_labelled_value_value)
  list_extract_labelled_value(${__list_get_labelled_value_lst} ${__list_get_labelled_value_value} ${ARGN})
  return_ans()
endfunction()

# File: source/collections/list_get_lean.cmake


## quickly gets the items from the specified list
macro(list_get_lean __lst_ref)
  list(LENGTH ARGN __len)
  if(__len)
    list(GET "${__lst_ref}" ${ARGN})
  else()
    set(__ans)
  endif() 
endmacro()



# File: source/collections/list_intersect.cmake

# returns a list containing all elements contained
# in all passed list references
function(list_intersect)
    set(__list_intersect_lists ${ARGN})

    list(LENGTH __list_intersect_lists __list_intersect_lists_length)
    if (NOT __list_intersect_lists_length)
        creturn()
    endif ()

    if ("${__list_intersect_lists_length}" EQUAL 1)
        if (${__list_intersect_lists})
            list(REMOVE_DUPLICATES "${__list_intersect_lists}")
        endif ()
        return_ref("${__list_intersect_lists}")
    endif ()


    list_pop_front(__list_intersect_lists)
    ans(__list_intersect_first)
    list_intersect(${__list_intersect_first})
    ans(__list_intersect_current_elements)
    # __list_intersect_current_elements is now unique

    # intersect rest elements
    list_intersect(${__list_intersect_lists})
    ans(__list_intersect_rest_elements)

    # get elements which are to be removed from list
    set(__list_intersect_elements_to_remove ${__list_intersect_current_elements})
    if (__list_intersect_elements_to_remove)
        foreach (__list_operation_item ${__list_intersect_rest_elements})
            list(REMOVE_ITEM __list_intersect_elements_to_remove ${__list_operation_item})
        endforeach ()
    endif ()
    # remove elements and return result
    if (__list_intersect_elements_to_remove)
        list(REMOVE_ITEM __list_intersect_current_elements ${__list_intersect_elements_to_remove})
    endif ()
    return_ref(__list_intersect_current_elements)
endfunction()

# File: source/collections/list_intersect_args.cmake

# returns only those flags which are contained in list and in the varargs
# ie list = [--a --b --c --d]
# list_intersect_args(list --c --d --e) ->  [--c --d]
function(list_intersect_args __list_intersect_args_lst)
  set(__list_intersect_args_flags ${ARGN})
  list_intersect(${__list_intersect_args_lst} __list_intersect_args_flags)
  return_ans()
endfunction()

# File: source/collections/list_isempty.cmake

# checks if the given list reference is an empty list
  function(list_isempty __list_empty_lst)
    list(LENGTH  ${__list_empty_lst} len)
    if("${len}" EQUAL 0)
      creturn(true)
    endif()
    creturn(false)
  endfunction()

# File: source/collections/list_isinorder.cmake

# returns true if value ${a} comes before value ${b} in list __list_isinorder_lst
# sets ${result} to true or false
function(list_isinorder  __list_isinorder_lst a b)
	list(FIND ${__list_isinorder_lst} ${a} indexA)
	list(FIND ${__list_isinorder_lst} ${b} indexB)
	if(${indexA} LESS 0)
		creturn(false)
	endif()
	if(${indexB} LESS 0)
		creturn(false)
	endif()
	if(${indexA} LESS ${indexB})
		creturn(true)
	endif()
	creturn(false)
endfunction()

# File: source/collections/list_iterator.cmake


## instanciates a list_iterator from the specified list
  function(list_iterator __list_ref)
    list(LENGTH ${__list_ref} __list_ref_len)
    creturn(${__list_ref} ${__list_ref_len} 0-1)
  endfunction()


# File: source/collections/list_iterator_break.cmake

## advances the iterator using list_iterator_next 
## and breaks the current loop when the iterator is done
macro(list_iterator_break it_ref)
  list_iterator_next(${it_ref})
  if(NOT __ans)
    break()
  endif()
endmacro()

# File: source/collections/list_iterator_next.cmake

## advances the iterator specified 
## and returns true if it is on a valid element (else false)
## sets the fields 
## ${it_ref}.index
## ${it_ref}.length
## ${it_ref}.list_ref
## ${it_ref}.value (only if a valid value exists)
function(list_iterator_next it_ref)
  list(GET ${it_ref} 0 list_ref)
  list(GET ${it_ref} 1 length)
  list(GET ${it_ref} 2 index)
  math(EXPR index "${index} + 1")    
  #print_vars(list_ref length index)
  set(${it_ref} ${list_ref} ${length} ${index} PARENT_SCOPE)
  set(${it_ref}.index ${index} PARENT_SCOPE)
  set(${it_ref}.length ${length} PARENT_SCOPE)
  set(${it_ref}.list_ref ${list_ref} PARENT_SCOPE)
  if(${index} LESS ${length})
    list(GET ${list_ref} ${index} value)
    set(${it_ref}.value "${value}" PARENT_SCOPE)
    creturn(true)
  else()
    set(${it_ref}.value PARENT_SCOPE)
    creturn(false)
  endif()
endfunction()


# File: source/collections/list_length.cmake

## returns the length of the specified list
macro(list_length __list_count_lst)
    list(LENGTH "${__list_count_lst}" __ans)
endmacro()


# File: source/collections/list_max.cmake

## returns the maximum value in the list 
## using the specified comparerer function
function(list_max lst comparer)
  list_fold(${lst} "${comparer}")
  ans(res)
  creturn(${res})
endfunction()


# File: source/collections/list_modify.cmake


    
function(list_modify __list_name)
  set(args ${ARGN})
  list_extract_flag(args --append)
  ans(append)
  list_extract_flag(args --remove)
  ans(remove)
  list_extract_flag(args --sort)
  ans(sort)
  list_extract_flag(args --set)
  ans(set)
  list_extract_flag(args --get)
  ans(get)
  list_extract_labelled_value(args --insert)
  ans(insert)
  list_extract_labelled_value(args --remove-at)
  ans(remove_at)
  list_extract_flag(args --remove-duplicates)
  ans(remove_duplicates)

  set(value ${${__list_name}})

  list(LENGTH value length)

  if(NOT "${insert}_" STREQUAL "_")
    list(INSERT value ${insert} ${args})
  elseif(set)
    set(value ${args})
  elseif(append)
    list(APPEND value ${args})
  elseif(remove)
    list(REMOVE_ITEM value ${args})
  elseif(NOT "${remove_at}_" STREQUAL "_")
    list(REMOVE_AT value ${remove_at})
  else()

  endif()

  if(length)
    if(remove_duplicates)
      list(REMOVE_DUPLICATES value)
    endif()
    if(sort)
      list(SORT value)
    endif()
  endif()

  set(${__list_name} ${value} PARENT_SCOPE)
endfunction()

# File: source/collections/list_normalize_index.cmake

# returns the normalized index.  negative indices are transformed to i => length - i
# if the index is out of range after transformation -1 is returned and a warnign is issued
# note: index evaluating to length are valid (one behind last)
function(list_normalize_index __lst index )
  set(idx ${index})
  list(LENGTH ${__lst} length)

  if("${idx}" STREQUAL "*")
    set(idx ${length})
  endif()
  
  if(${idx} LESS 0)
    math(EXPR idx "${length} ${idx} + 1")
  endif()
  if(${idx} LESS 0)
    message(WARNING "index out of range: ${index} (${idx}) length of list '${lst}': ${length}")
    creturn(-1)
  endif()

  if(${idx} GREATER ${length})
    message(WARNING "index out of range: ${index} (${idx}) length of list '${lst}': ${length}")
    creturn(-1)
  endif()
  creturn(${idx})
endfunction()

# File: source/collections/list_pad.cmake

  
  function(list_pad ref n)
    # contains alot of workaroudn for empty list elements
    set(list ${${ref}})
    list(LENGTH list len)
    string(REPLACE ";" "" list "${list}")


    set(pad_value ${ARGN})
    if("${pad_value}_" STREQUAL "_")
      if(${len} EQUAL 0 AND ${n} EQUAL 1)
        # special case...
        creturn(false)
      endif()
    endif()
    if(${len} LESS "${n}")
      math(EXPR n "${n} - 1")
      foreach(i RANGE ${len} ${n})
        if(${i} EQUAL 0)
          set(list "${pad_value}")
        else()
          set(list  "${list}${pad_value}")
        endif()
        list(LENGTH list thelen)
      endforeach()
    else()
      creturn(false)
    endif()
    string(REPLACE "" ";" list "${list}")
    set(${ref} "${list}" PARENT_SCOPE)
    creturn(true)
  endfunction()


# File: source/collections/list_pad_set.cmake


  ## pads the list so that every index is set then applies the specified value
  function(list_pad_set lst_ref indices pad_value value)
    
    set(list "${${lst_ref}}")
    set(max -1)
    foreach(i ${indices})
      if(${i} GREATER ${max})
        set(max ${i})
      endif()
    endforeach()
    math(EXPR max "${max} + 1")
    list_pad(list "${max}" "${pad_value}")
    foreach(i ${indices})
      list(INSERT list "${i}" "${value}")
      math(EXPR i "${i} + 1")
      list(REMOVE_AT list "${i}")
    endforeach()
    set(${lst_ref} "${list}" PARENT_SCOPE)
    creturn()
  endfunction()



# File: source/collections/list_parse_descriptor.cmake


# returns true if value could be parsed
function(list_parse_descriptor descriptor)  
  cmake_parse_arguments("" "" "UNUSED_ARGS;ERROR;CUTOFFS" "" ${ARGN})
  set(args ${_UNPARSED_ARGUMENTS})
  scope_import_map(${descriptor})
  list_find_any(args ${labels})
  ans(starting_index)

  list_slice(args 0 ${starting_index})
  ans(unused_args)
  list_slice(args ${starting_index} -1)
  ans(value_args)

  list_find_any(value_args ${${_CUTOFFS}})
  ans(cut_off)
  if(${cut_off} LESS 0)
    set(cut_off ${max})
  endif()
  math_min(${max} ${cut_off})
  ans(cut_off)

  #message(FORMAT "value args for {descriptor.id} max:${cut_off} are ${value_args} args: ${args}")

  # remove first arg as its the flag used to start this value
  list_pop_front( value_args)
  ans(used_label)
  
  # list length
  list(LENGTH value_args len)

  if("${cut_off}" STREQUAL "*")
    set(cut_off -1)
  endif()
  
  math_min(${len} ${cut_off})
  ans(cut_off)  
  list_slice(value_args "${cut_off}" -1)
  ans(tmp)

  list(APPEND unused_args ${tmp})

  # set result value for unused args
  if(_UNUSED_ARGS)
    set(${_UNUSED_ARGS} ${unused_args} PARENT_SCOPE)
  endif()
  
  list_slice(value_args 0 "${cut_off}")
  ans(value_args)

  # option
  if(${min} STREQUAL 0 AND ${max} STREQUAL 0)
    set(${_ERROR} false PARENT_SCOPE)
    if(starting_index LESS 0)
      creturn(false)
    else()
      creturn(true)
    endif()
  endif()

  # if less than min args are avaiable set error to true but
  # still return the found values however
  if(${cut_off} LESS ${min} )
    set(${_ERROR} true PARENT_SCOPE)
  else()
    set(${_ERROR} false PARENT_SCOPE)
  endif()


  # use return ref because value_args might return strange strings
  return_ref(value_args)

endfunction()

# File: source/collections/list_peek_back.cmake

## Returns the last element of a list without modifying it
function(list_peek_back  __list_peek_back_lst)
  if("${${__list_peek_back_lst}}_" STREQUAL "_")
    creturn()
  endif()
  list(LENGTH ${__list_peek_back_lst} len)
  math(EXPR len "${len} - 1")
  list(GET ${__list_peek_back_lst} "${len}" res)
  return_ref(res)
endfunction()

# File: source/collections/list_peek_front.cmake

# gets the first element of the list without modififying it
function(list_peek_front __list_peek_front_lst)
  if("${${__list_peek_front_lst}}_" STREQUAL "_")
    creturn()
  endif()
  list(GET "${__list_peek_front_lst}" 0 res)
  return_ref(res)
endfunction()

# File: source/collections/list_pop_back.cmake

# removes the last element from list and returns it
function(list_pop_back __list_pop_back_lst)

  if("${${__list_pop_back_lst}}_" STREQUAL "_")
    creturn()
  endif()
  list(LENGTH "${__list_pop_back_lst}" len)
  math(EXPR len "${len} - 1")
  list(GET "${__list_pop_back_lst}" "${len}" res)
  list(REMOVE_AT "${__list_pop_back_lst}" ${len})
  set("${__list_pop_back_lst}" ${${__list_pop_back_lst}} PARENT_SCOPE)
  return_ref(res)
endfunction()



  # removes the last element from list and returns it
  ## faster version
macro(list_pop_back __list_pop_back_lst)
  if("${${__list_pop_back_lst}}_" STREQUAL "_")
    set(__ans)
  else()
    list(LENGTH "${__list_pop_back_lst}" __list_pop_back_length)
    math(EXPR __list_pop_back_length "${__list_pop_back_length} - 1")
    list(GET "${__list_pop_back_lst}" "${__list_pop_back_length}" __ans)
    list(REMOVE_AT "${__list_pop_back_lst}" ${__list_pop_back_length})
  endif()
endmacro()

# File: source/collections/list_pop_front.cmake

# removes the first value of the list and returns it
function(list_pop_front  __list_pop_front_lst)
  set(res)

  list(LENGTH "${__list_pop_front_lst}" len)
  if("${len}" EQUAL 0)
    creturn()
  endif()

  list(GET ${__list_pop_front_lst} 0 res)

  if(${len} EQUAL 1) 
    set(${__list_pop_front_lst} )
  else()
    list(REMOVE_AT "${__list_pop_front_lst}" 0)
  endif()
  #message("${__list_pop_front_lst} is ${${__list_pop_front_lst}}")
#  set(${result} ${res} PARENT_SCOPE)
  set(${__list_pop_front_lst} ${${__list_pop_front_lst}} PARENT_SCOPE)
  return_ref(res)
endfunction()


# removes the first value of the list and returns it
## faster version
macro(list_pop_front  __list_pop_front_lst)
  list(LENGTH "${__list_pop_front_lst}" __list_pop_front_length)
  if(NOT "${__list_pop_front_length}" EQUAL 0)
    list(GET ${__list_pop_front_lst} 0 __ans)

    if(${__list_pop_front_length} EQUAL 1) 
      set(${__list_pop_front_lst})
    else()
      list(REMOVE_AT "${__list_pop_front_lst}" 0)
    endif()
  else()
    set(__ans)
  endif()

endmacro()

# File: source/collections/list_push_back.cmake

# adds a value to the end of the list
function(list_push_back __list_push_back_lst value)
  set(${__list_push_back_lst} ${${__list_push_back_lst}} ${value} PARENT_SCOPE)
endfunction()

# File: source/collections/list_push_front.cmake

# adds a value at the beginning of the list
function(list_push_front __list_push_front_lst value)
  set(${__list_push_front_lst} ${value} ${${__list_push_front_lst}} PARENT_SCOPE)   
  creturn(true)
endfunction()

# File: source/collections/list_regex_match.cmake

## matches all elements of lst to regex
## all elements in list which match the regex are returned
function(list_regex_match __list_regex_match_lst )
  set(__list_regex_match_result)
  foreach(__list_regex_match_item ${${__list_regex_match_lst}})
    foreach(__list_regex_match_regex ${ARGN})
      if("${__list_regex_match_item}" MATCHES "${__list_regex_match_regex}")
        list(APPEND __list_regex_match_result "${__list_regex_match_item}")
        break() ## break inner loop on first match
      endif()
    endforeach()
  endforeach()
  return_ref(__list_regex_match_result)
endfunction()


# File: source/collections/list_regex_match_ignore.cmake

## returns every element of lst that matches any of the given regexes
## and does not match any regex that starts with !
  function(list_regex_match_ignore lst)
    set(regexes ${ARGN})
    list_regex_match(regexes "^[!]")
    ans(negs)
    set(negatives)
    foreach(negative ${negs})
      string(SUBSTRING "${negative}" 1 -1 negative )
      list(APPEND negatives "${negative}")
    endforeach()

    list_regex_match(regexes "^[^!]")
    ans(positives)


    list_regex_match(${lst} ${positives})
    ans(matches)

    list_regex_match(matches ${negatives})
    ans(ignores)

    list(REMOVE_ITEM matches ${ignores})

    return_ref(matches)

  endfunction()


# File: source/collections/list_remove.cmake

# removes all items specified in varargs from list
# returns the number of items removed
function(list_remove __list_remove_lst)
  list(LENGTH "${__list_remove_lst}" __lst_len)
  list(LENGTH ARGN __arg_len)
  if(__arg_len EQUAL 0 OR __lst_len EQUAL 0)
    creturn()
  endif()
  list(REMOVE_ITEM "${__list_remove_lst}" ${ARGN})
  list(LENGTH "${__list_remove_lst}" __lst_new_len)
  math(EXPR __removed_item_count "${__lst_len} - ${__lst_new_len}")
  set("${__list_remove_lst}" "${${__list_remove_lst}}" PARENT_SCOPE)
  return_ref(__removed_item_count)
endfunction()

# File: source/collections/list_remove_at.cmake

# removes all items at all specified indices from list 
function(list_remove_at __list_remove_at_lst)
    if (NOT ${__list_remove_at_lst})
        creturn()
    endif ()
    set(args)

    foreach (arg ${ARGN})
        list_normalize_index(${__list_remove_at_lst} ${arg})
        ans(res)
        list(APPEND args ${res})
    endforeach ()


    list(REMOVE_AT "${__list_remove_at_lst}" ${args})

    set("${__list_remove_at_lst}" "${${__list_remove_at_lst}}" PARENT_SCOPE)

    return_ref("${__list_remove_at_lst}")

endfunction()

# File: source/collections/list_remove_duplicates.cmake

## removes duplicates from a list
function(list_remove_duplicates __lst)
  list(LENGTH ${__lst} len)
  if(len EQUAL 0)
    creturn()
  endif()
  list(REMOVE_DUPLICATES ${__lst})
  set(${__lst} ${${__lst}} PARENT_SCOPE)
  creturn()
endfunction()


# File: source/collections/list_replace_at.cmake

# replaces lists  value at i with new_value
function(list_replace_at __list_replace_at_lst i new_value)
  list(LENGTH ${__list_replace_at_lst} len)
  if(NOT "${i}" LESS "${len}")
    creturn(false)
  endif()
  list(INSERT ${__list_replace_at_lst} ${i} ${new_value}) 
  math(EXPR i_plusone "${i} + 1" )
  list(REMOVE_AT ${__list_replace_at_lst} ${i_plusone})
  set(${__list_replace_at_lst} ${${__list_replace_at_lst}} PARENT_SCOPE)
  creturn(true)
endfunction()


# File: source/collections/list_replace_slice.cmake


  ## replaces the specified slice with the specified varargs
  ## returns the elements which were removed
  function(list_replace_slice __list_ref __start_index __end_index)
    ## normalize indices
    list_normalize_index(${__list_ref} ${__start_index})
    ans(__start_index)
    list_normalize_index(${__list_ref} ${__end_index})
    ans(__end_index)


    list(LENGTH ARGN __insert_count)
    ## add new elements
    if(__insert_count)
      list(LENGTH ${__list_ref} __old_length)
      if("${__old_length}" EQUAL "${__start_index}")
        list(APPEND ${__list_ref} ${ARGN})
      else()
        list(INSERT ${__list_ref} ${__start_index} ${ARGN})
      endif()
      math(EXPR __start_index "${__start_index} + ${__insert_count}")
      math(EXPR __end_index "${__end_index} + ${__insert_count}")
    endif()
    
    ## generate index list of elements to remove
    index_range(${__start_index} ${__end_index})
    ans(__indices)

    ## get number of elements to remove
    list(LENGTH __indices __remove_count)
    
    ## get slice which is to be removed and remove it
    set(__removed_elements)
    if(__remove_count)
      list(GET ${__list_ref} ${__indices} __removed_elements)
      list(REMOVE_AT ${__list_ref} ${__indices})
    endif()
    

    ## set result
    set(${__list_ref} ${${__list_ref}} PARENT_SCOPE)
    return_ref(__removed_elements)
  endfunction()

# File: source/collections/list_reverse.cmake

## `(<list ref>)-><void>`
##
## reverses the specified lists elements
macro(list_reverse __list_reverse_lst)
  if(${__list_reverse_lst})
    list(REVERSE ${__list_reverse_lst})
  endif()
endmacro()

# File: source/collections/list_select.cmake

# uses the selector on each element of the list
function(list_select __list_select_lst selector)
  list(LENGTH ${__list_select_lst} l)
  message(list_select ${l})
  set(__list_select_result_list)

  foreach(item ${${__list_select_lst}})
		rcall(res = "${selector}"("${item}"))
		list(APPEND __list_select_result_list ${res})

	endforeach()
  message("list_select end")
	return_ref(__list_select_result_list)
endfunction()



## fast implementation of list_select
function(list_select __list_select_lst __list_select_selector)
  function_import("${__list_select_selector}" as __list_select_selector REDEFINE)

  set(__res)
  set(__ans)
  foreach(__list_select_current_arg ${${__list_select_lst}})
    __list_select_selector(${__list_select_current_arg})
    list(APPEND __res ${__ans})
  endforeach()
  return_ref(__res)  
endfunction()

# File: source/collections/list_select_property.cmake


function(list_select_property __lst __prop)
  set(__result)
  foreach(__itm ${${__lst}})
    map_tryget("${__itm}" "${__prop}")
    ans(__res)
    list(APPEND __result "${__res}")
  endforeach()
  return_ref(__result)
endfunction()

# File: source/collections/list_set_at.cmake

# sets the lists value at index to the specified value
# the index is normalized -> negativ indices count down from back of list 
  function(list_set_at __list_set_lst index value)
    if("${index}" EQUAL -1)
      #insert element at end
      list(APPEND ${__list_set_lst} ${value})
      set(${__list_set_lst} ${${__list_set_lst}} PARENT_SCOPE)
      creturn(true)
    endif()
    list_normalize_index(${__list_set_lst} "${index}")
    ans(index)
    if(index LESS 0)
      creturn(false)
    endif()
    list_replace_at(${__list_set_lst} "${index}" "${value}")

    set(${__list_set_lst} ${${__list_set_lst}} PARENT_SCOPE)
    creturn(true)
  endfunction()

# File: source/collections/list_slice.cmake

# retruns a portion of the list specified.
# negative indices count from back of list 
#
function(list_slice __list_slice_lst start_index end_index)
  # indices equal => select nothing

  list_normalize_index(${__list_slice_lst} ${start_index})
  ans(start_index)
  list_normalize_index(${__list_slice_lst} ${end_index})
  ans(end_index)

  if(${start_index} LESS 0)
    message(FATAL_ERROR "list_slice: invalid start_index ")
  endif()
  if(${end_index} LESS 0)
    message(FATAL_ERROR "list_slice: invalid end_index")
  endif()
  # copy array
  set(res)
  index_range(${start_index} ${end_index})
  ans(indices)

  list(LENGTH indices indices_len)
  if(indices_len)
    list(GET ${__list_slice_lst} ${indices} res)
  endif()
  #foreach(idx ${indices})
   # list(GET ${__list_slice_lst} ${idx} value)
    #list(APPEND res ${value})
   # message("getting value at ${idx} from ${${__list_slice_lst}} : ${value}")
  #endforeach()
 # message("${start_index} - ${end_index} : ${indices} : ${res}" )
  return_ref(res)
endfunction()




# File: source/collections/list_sort.cmake


# orders a list by a comparator function
function(list_sort __list_order_lst comparator)
  list(LENGTH ${__list_order_lst} len)

  function_import("${comparator}" as __compare REDEFINE)

  # copyright 2014 Tobias Becker -> triple s "slow slow sort"
  set(i 0)
  set(j 0)
  while(true)
    if(NOT ${i} LESS ${len})
      set(i 0)
      math(EXPR j "${j} + 1")
    endif()

    if(NOT ${j} LESS ${len}  )
      break()
    endif()
    list(GET ${__list_order_lst} ${i} a)
    list(GET ${__list_order_lst} ${j} b)
    #rcall(res = "${comparator}"("${a}" "${b}"))
    __compare("${a}" "${b}")
    ans(res)
    if(res LESS 0)
      list_swap(${__list_order_lst} ${i} ${j})
    endif()


    math(EXPR i "${i} + 1")
  endwhile()
  return_ref(${__list_order_lst})
endfunction()

## faster implementation: quicksort


# orders a list by a comparator function and returns it
function(list_sort __list_sort_lst comparator)
  list(LENGTH ${__list_sort_lst} len)
  math(EXPR len "${len} - 1")
  function_import("${comparator}" as __quicksort_compare REDEFINE)
  __quicksort(${__list_sort_lst} 0 ${len})
  return_ref(${__list_sort_lst})
endfunction()

   ## the quicksort routine expects a function called 
   ## __quicksort_compare to be defined
 macro(__quicksort __list_sort_lst lo hi)
  if("${lo}" LESS "${hi}")
    ## choose pivot
    set(p_idx ${lo})
    ## get value of pivot 
    list(GET ${__list_sort_lst} ${p_idx} p_val)
    
    list_swap(${__list_sort_lst} ${p_idx} ${hi})
    math(EXPR upper "${hi} - 1")
    
    ## store index p
    set(p ${lo})
    foreach(i RANGE ${lo} ${upper})
      list(GET ${__list_sort_lst} ${i} c_val)
      __quicksort_compare("${c_val}" "${p_val}")
      ans(cmp)
      if("${cmp}" GREATER 0)
        list_swap(${__list_sort_lst} ${p} ${i})
        math(EXPR p "${p} + 1")
      endif()
    endforeach()
    list_swap(${__list_sort_lst} ${p} ${hi})

    math(EXPR p_lo "${p} - 1")
    math(EXPR p_hi "${p} + 1")
    ## recursive call
    __quicksort("${__list_sort_lst}" "${lo}" "${p_lo}")
    __quicksort("${__list_sort_lst}" "${p_hi}" "${hi}")
  endif()
 endmacro()


# File: source/collections/list_split.cmake

## assert allows assertion

# splits a list into two parts after the specified index
# example:
# set(lst 1 2 3 4 5 6 7)
# list_split(p1 p2 lst 3)
# p1 will countain 1 2 3
# p2 will contain 4 5 6 7
function(list_split part1 part2 _lst index)
	list(LENGTH ${_lst} count)
	#message("${count} ${${_lst}}")
	# subtract one because range goes to index count and should only got to count -1
	math(EXPR count "${count} -1")
	set(p1)
	set(p2)
	foreach(i RANGE ${count})
		#message("${i}")
		list(GET ${_lst} ${i} val)
		if(${i} LESS ${index} )
			list(APPEND p1 ${val})
		else()
			list(APPEND p2 ${val})
		endif()
	endforeach()
	set(${part1} ${p1} PARENT_SCOPE)
	set(${part2} ${p2} PARENT_SCOPE)
	creturn()
endfunction()




# File: source/collections/list_split_at.cmake


## list_split_at()
##
##
function(list_split_at lhs rhs __lst key)
  list(LENGTH ${__lst} len)
  if(NOT len)
    set(${lhs} PARENT_SCOPE)
    set(${rhs} PARENT_SCOPE)
    creturn()
  endif()

  list(FIND ${__lst} ${key} idx)

  list_split(${lhs} ${rhs} ${__lst} ${idx})

  set(${lhs} ${${lhs}} PARENT_SCOPE)
  set(${rhs} ${${rhs}} PARENT_SCOPE)

  creturn()
endfunction()

# File: source/collections/list_swap.cmake

# swaps the element of lst at i with element at index j
macro(list_swap __list_swap_lst i j)
	list(GET ${__list_swap_lst} ${i} a)
	list(GET ${__list_swap_lst} ${j} b)
	list_replace_at(${__list_swap_lst} ${i} ${b})
	list_replace_at(${__list_swap_lst} ${j} ${a})
endmacro()



# File: source/collections/list_to_map.cmake


  function(list_to_map lst key_selector)
    function_import("${key_selector}" as __to_map_key_selector REDEFINE)
    map_new()
    ans(res)
    foreach(item ${${lst}})
      __to_map_key_selector(${item})
      ans(key)
      map_set(${res} "${key}" "${item}")
    endforeach()
    return_ref(res)

  endfunction()


# File: source/collections/list_to_string.cmake



# Converts a CMake list to a string containing elements separated by spaces
function(list_to_string  list_name separator )
  set(res)
  set(current_separator)
  foreach(element ${${list_name}})
    set(res "${res}${current_separator}${element}")
    # after first iteration separator will be set correctly
    # so i do not need to remove initial separator afterwords
    set(current_separator ${separator})
  endforeach()
  return_ref(res)

endfunction()

# File: source/collections/list_union.cmake

# returns a list containing the unqiue set of all elements
# contained in passed list referencese
function(list_union)
  if(NOT ARGN)
    creturn()
  endif()
  set(__list_union_result)
  foreach(__list_union_list ${ARGN})
    list(APPEND __list_union_result ${${__list_union_list}})
  endforeach() 

  list(REMOVE_DUPLICATES __list_union_result)
  return_ref(__list_union_result)
endfunction()


# File: source/collections/list_unique.cmake

# takes the passed list and returns only its unique elements
# see cmake's list(REMOVE_DUPLICATES)
function(list_unique __list_unique_lst)
  list(LENGTH ${__list_unique_lst} __len)
  if(${__len} GREATER 1)
	 list(REMOVE_DUPLICATES ${__list_unique_lst})
  endif()
	return_ref(${__list_unique_lst})
endfunction()


# File: source/collections/list_where.cmake

# executes a predicate on every item of the list (passed by reference)
# and returns those items for which the predicate holds
function(list_where __list_where_lst predicate)

	foreach(item ${${__list_where_lst}})
    rcall(__matched = "${predicate}"("${item}"))
		if(__matched)
			list(APPEND result_list ${item})
		endif()
	endforeach()
	return_ref(result_list)
endfunction()


## fast implemenation
function(list_where __list_where_lst __list_where_predicate)
  function_import("${__list_where_predicate}" as __list_where_predicate REDEFINE)
  set(__list_where_result_list)
  foreach(__list_where_item ${${__list_where_lst}})
    __list_where_predicate(${__list_where_item})
    ans(__matched)
    if(__matched)
      list(APPEND __list_where_result_list ${__list_where_item})
    endif()
  endforeach()
  return_ref(__list_where_result_list)
endfunction()


# File: source/collections/list_without_range.cmake

# removes the specifed range from the list
# and returns remaining elements
function(list_without_range __list_without_range_lst start_index end_index)

  list_normalize_index(${__list_without_range_lst} -1)
  ans(list_end)

  list_slice(${__list_without_range_lst} 0 ${start_index})
  ans(part1)
  list_slice(${__list_without_range_lst} ${end_index} ${list_end})
  ans(part2)

  set(res ${part1} ${part2})
  return_ref(res)
endfunction()

# File: source/collections/range/is_range.cmake

##
##
##
function(is_range)
  if("_${ARGN}_" MATCHES "^_[0-9:\\$,\\-]*_$")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/collections/range/list_range_get.cmake


## returns the elements of the specified list ref which are indexed by specified range
function(list_range_get __lst_ref)
  list(LENGTH ${__lst_ref} __len)
  range_indices("${__len}" ${ARGN})
  ans(__indices)
  list(LENGTH __indices __len)
  if(NOT __len)
    creturn()
  endif()
  list(GET ${__lst_ref} ${__indices} __res)
  return_ref(__res)
endfunction()


# File: source/collections/range/list_range_indices.cmake


  ## list_range_indices(<list&> <range ...>)
  ## returns the indices for the range for the specified list
  ## e.g. 
  ## 
  function(list_range_indices __lst)
    list(LENGTH ${__lst} len)
    range_indices("${len}" ${ARGN})
    ans(indices)
    return_ref(indices)
  endfunction()



# File: source/collections/range/list_range_partial_write.cmake

## writes the specified varargs to the list
## at the beginning of the specified partial range
## fails if the range is a  multi range
## e.g. 
## set(lstB a b c)
## list_range_partial_write(lstB "[]" 1 2 3)
## -> lst== [a b c 1 2 3]
## list_range_partial_write(lstB "[1]" 1 2 3)
## -> lst == [a 1 2 3 c]
## list_range_partial_write(lstB "[1)" 1 2 3)
## -> lst == [a 1 2 3 b c]
  function(list_range_partial_write __lst __range)
    range_parse("${__range}")
    ans(partial_range)
    list(LENGTH partial_range len)
    if("${len}" GREATER 1)
      message(FATAL_ERROR "only partial partial_range allowed")
      creturn()
    endif()
   # print_vars(partial_range)

    string(REPLACE ":" ";" partial_range "${partial_range}")
    list(GET partial_range 0 begin)
    list(GET partial_range 1 end)

    if("${begin}" STREQUAL "n" AND "${end}" STREQUAL "n")
      set(${__lst} ${${__lst}} ${ARGN} PARENT_SCOPE)
      creturn()
    endif()

    list_range_remove("${__lst}" "${__range}")

    list(LENGTH ARGN insertion_count)
    if(NOT insertion_count)
      set(${__lst} ${${__lst}} PARENT_SCOPE)
      creturn()
    endif() 

    list(GET partial_range 6 reverse)
    if(reverse)
      set(insertion_index "${end}")
    else()
      set(insertion_index "${begin}")
    endif()

    list(LENGTH ${__lst} __len)
    if("${insertion_index}" LESS ${__len})
      list(INSERT ${__lst} "${insertion_index}" ${ARGN})
    elseif("${insertion_index}" EQUAL ${__len})
      list(APPEND ${__lst} ${ARGN})
    else()
      message(FATAL_ERROR "list_range_partial_write could not write to index ${insertion_index}")
    endif()


    set(${__lst} ${${__lst}} PARENT_SCOPE)
    creturn()
  endfunction()

# File: source/collections/range/list_range_remove.cmake

## removes the specified range from the list
function(list_range_remove __lst range)
  list(LENGTH ${__lst} list_len)
  range_indices(${list_len} "${range}")
  ans(indices)
  list(LENGTH indices len)

  if(NOT len)
    creturn(0)
  endif()
  #message("${indices} - ${list_len}")
  if("${indices}" EQUAL ${list_len})
    creturn(0)
  endif()
  list(REMOVE_AT ${__lst} ${indices})
  set(${__lst} ${${__lst}} PARENT_SCOPE)
  creturn(${len})
endfunction()

# File: source/collections/range/list_range_replace.cmake


  ## replaces the specified range with the specified arguments
  ## the varags are taken and fill up the range to replace_count
  ## e.g. set(list a b c d e) 
  ## list_range_replace(list "4 0 3:1:-2" 1 2 3 4 5) --> list is equal to  2 4 c 3 1 
  ##
  function(list_range_replace lst_ref range)
    set(lst ${${lst_ref}})

    list(LENGTH lst len)
    range_instanciate(${len} "${range}")
    ans(range)

    set(replaced)
    message("inputlist '${lst}' length : ${len} ")
    message("range: ${range}")
    set(difference)

    range_indices("${len}" ":")
    ans(indices)
    
    range_indices("${len}" "${range}")
    ans(indices_to_replace)
    
    list(LENGTH indices_to_replace replace_count)
    message("indices_to_replace '${indices_to_replace}' count: ${replace_count}")

    math(EXPR replace_count "${replace_count} - 1")

    if(${replace_count} LESS 0)
      message("done\n")
      creturn()
    endif()

    set(args ${ARGN})
    set(replaced)

    message_indent_push()
    foreach(i RANGE 0 ${replace_count})
      list(GET indices_to_replace ${i} index)

      list_pop_front(args)
      ans(current_value)

      #if(${i} EQUAL ${replace_count})
      #  set(current_value ${args})
      #endif()

      if(${index} GREATER ${len})
        message(FATAL_ERROR "invalid index '${index}' - list is only ${len} long")
      elseif(${index} EQUAL ${len}) 
        message("appending to '${current_value}' to list")
        list(APPEND lst "${current_value}")
      else()
        list(GET lst ${index} val)
        list(APPEND replaced ${val})
        message("replacing '${val}' with '${current_value}' at '${index}'")
        list(INSERT lst ${index} "${current_value}")
        #list(LENGTH current_value current_len)
        math(EXPR index "${index} + 1")
        list(REMOVE_AT lst ${index})
        message("list is now ${lst}")
      endif()



    endforeach()
    message_indent_pop()


    message("lst '${lst}'")
    message("replaced '${replaced}'")
    message("done\n")
    set(${lst_ref} ${lst} PARENT_SCOPE)
    return_ref(replaced)
  endfunction()

# File: source/collections/range/list_range_set.cmake

  ## sets every element included in range to specified value
  ## 
  function(list_range_set __lst __range __value)
    list_range_indices(${__lst} "${__range}")
    ans(indices)
    foreach(i ${indices})
      list(INSERT "${__lst}" "${i}" "${__value}")
      math(EXPR i "${i} + 1")
      list(REMOVE_AT "${__lst}" "${i}")
    endforeach()
    set(${__lst} ${${__lst}} PARENT_SCOPE)
    creturn()
  endfunction()


# File: source/collections/range/list_range_try_get.cmake

## `(<&list> )`
##
## returns the elements of the specified list ref which are indexed by specified range
function(list_range_try_get __lst_ref)
  list(LENGTH ${__lst_ref} __len)
  # range_indices("${__len}" ${ARGN})
  # ans(__indices2)

  # set(__indices)
  # foreach(__idx ${__indices2})
  #   if(NOT ${__idx} LESS 0 AND ${__idx} LESS ${__len} )
  #     list(APPEND __indices ${__idx})
  #   endif()
  # endforeach()

  range_indices_valid("${__len}" ${ARGN})
  ans(__indices)

  list(LENGTH __indices __len)
  if(NOT __len)
    creturn()
  endif()
  list(GET ${__lst_ref} ${__indices} __res)
  return_ref(__res)
endfunction()



# File: source/collections/range/range_from_indices.cmake

## `(<index:<uint>...>)-><instanciated range...>`
## 
## returns the best ranges from the specified indices
## e.g range_from_indices(1 2 3) -> [1:3]
##     range_from_indices(1 2) -> 1 2
##     range_from_indices(1 2 3 4 5 6 7 8 4 3 2 1 9 6 7) -> [1:8] [4:1:-1] 9 6 7
function(range_from_indices)
  set(range)
  set(prev)
  set(begin -1)
  set(end -1)
  set(increment)
  list(LENGTH ARGN index_count)
  if(${index_count} EQUAL 0)
    creturn()
  endif() 


  set(indices_in_partial_range)
  foreach(i ${ARGN})
    if("${begin}"  EQUAL -1)
      set(begin ${i})
      set(end ${i})
    endif()


    if(NOT increment)
      math(EXPR increment "${i} - ${begin}")
      if( ${increment} GREATER 0)
        set(increment "+${increment}")
      elseif(${increment} EQUAL 0)
        set(increment)
      endif()
    endif()

    if(increment)
      math(EXPR expected "${end}${increment}")    
    else()
      set(expected ${i})
    endif()


    if(NOT ${expected} EQUAL ${i})
      __range_from_indices_create_range()
      ## end of current range
      set(begin ${i})
      set(increment)
      set(indices_in_partial_range)

    endif()
    set(end ${i}) 
    list(APPEND indices_in_partial_range ${i})
  endforeach()

  __range_from_indices_create_range()
  


  string(REPLACE ";" " " range "${range}")
  #message("res '${range}'")
  return_ref(range)
endfunction()

## helper macro
macro(__range_from_indices_create_range)
    list(LENGTH indices_in_partial_range number_of_indices)
 #   message("done with range: ${begin} ${end} ${increment} ${number_of_indices}")

    if(${number_of_indices} EQUAL 2)
      list(APPEND range "${begin}")
      list(APPEND range "${end}")
    elseif("${begin}" EQUAL "${end}")
      list(APPEND range "${begin}")
    elseif("${increment}" EQUAL 1)
      list(APPEND range "[${begin}:${end}]")
    else()
      math(EXPR increment "0${increment}")
      list(APPEND range "[${begin}:${end}:${increment}]")
    endif()
endmacro()

# File: source/collections/range/range_indices.cmake

## `(<length:<int>> <~range...>)-><index:<uint>...>` 
##
## returns the list of indices for the specified range
## length may be negative which causes a failure if any anchors are used (`$` or `n`) 
## 
## if the length is valid  (`>-1`) only valid indices are returned or failure occurs
##
## a length of 0 always returns no indices
##
## **Examples**
## ```
## ```
function(range_indices length)

  if("${length}" EQUAL 0)
    creturn()
  endif()
  if("${length}" LESS 0)
    set(length 0)
  endif()
  
  range_instanciate("${length}" ${ARGN})
  ans(range)

  ## foreach partial range in range 
  ## get the begin and end and increment 
  ## use cmake's foreach loop to enumerate the range 
  ## and save the indices 
  ## remove a index at front and or back if the inclusivity warrants it
  ## return the indices
  set(indices)
  foreach(partial ${range})
    string(REPLACE ":" ";" partial "${partial}")
    list(GET partial 0 1 2 partial_range)
    foreach(i RANGE ${partial_range})
      list(APPEND indices ${i})
    endforeach() 
    list(GET partial 3 begin_inclusivity)
    list(GET partial 4 end_inclusivity)
    if(NOT end_inclusivity)
      list_pop_back(indices)
    endif()
    if(NOT begin_inclusivity)
      list_pop_front(indices)
    endif()
  endforeach()
  return_ref(indices)
endfunction()


# File: source/collections/range/range_indices_valid.cmake

## returns all valid indices for the specified range
function(range_indices_valid __len)
  range_indices("${__len}" ${ARGN})
  ans(__indices2)
  set(__indices)
  foreach(__idx ${__indices2})
    if(NOT ${__idx} LESS 0 AND ${__idx} LESS ${__len} )
      list(APPEND __indices ${__idx})
    endif()
  endforeach()
  return_ref(__indices)
endfunction()


# File: source/collections/range/range_instanciate.cmake

## `(<length:<int>> <~range...>)-><instanciated range...>`
## 
## instanciates a range.  A uninstanciated range contains anchors
## these are removed when a length is specified (`n`)
## returns a valid range  with no anchors
function(range_instanciate length)
  range_parse(${ARGN})
  ans(range)

  if(${length} LESS 0)
    set(length 0)
  endif()

  math(EXPR last "${length}-1")

  set(result)
  foreach(part ${range})
    string(REPLACE : ";" part ${part})
    set(part ${part})
    list(GET part 0 begin)
    list(GET part 1 end)
    list(GET part 2 increment)
    list(GET part 3 begin_inclusivity)
    list(GET part 4 end_inclusivity)
    list(GET part 5 range_length)
    list(GET part 6 reverse)

    string(REPLACE "n" "${length}" range_length "${range_length}")
    string(REPLACE "$" "${last}" range_length "${range_length}")

    math(EXPR range_length "${range_length}")


    string(REPLACE "n" "${length}" end "${end}")
    string(REPLACE "$" "${last}" end "${end}")

    math(EXPR end "${end}")
    if(${end} LESS 0)
      message(FATAL_ERROR "invalid range end: ${end}")
    endif()

    string(REPLACE "n" "${length}" begin "${begin}")
    string(REPLACE "$" "${last}" begin "${begin}")
    math(EXPR begin "${begin}")
    if(${begin} LESS 0)
      message(FATAL_ERROR "invalid range begin: ${begin}")
    endif()

    list(APPEND result "${begin}:${end}:${increment}:${begin_inclusivity}:${end_inclusivity}:${range_length}:${reverse}")  
  endforeach()
 # message("res ${result}")
  return_ref(result)
endfunction()


# File: source/collections/range/range_parse.cmake

## `(<~range...>)-><range>`
##
## parses a range string and normalizes it to have the following form:
## `<range> ::= <begin>":"<end>":"<increment>":"<begin inclusivity:<bool>>":"<end inclusivity:<bool>>":"<length>":"<reverse:<bool>>
## these `<range>`s can be used to generate a index list which can in turn be used to address lists.
##  
##   * a list of `<range>`s is a  `<range>`  
##   * `$` the last element 
##   * `n` the element after the last element ($+1)
##   * `-<n>` a begin or end starting with `-` is transformed into `$-<n>`
##   * `"["` `"("` `")"` and `"]"`  signify the inclusivity.  
## 
function(range_parse)
  ## normalize input by replacing certain characters
  string(REPLACE " " ";" range "${ARGN}")
  string(REPLACE "," ";" range "${range}")

  string(REPLACE "(" ">" range "${range}")
  string(REPLACE ")" "<" range "${range}")
  string(REPLACE "[" "<" range "${range}")
  string(REPLACE "]" ">" range "${range}")

  ## if there is more than one range group 
  ## recursively invoke range_parse
  list(LENGTH range group_count)
  set(ranges)
  if(${group_count} GREATER 1)
    foreach(group ${range})
      range_parse("${group}")
      ans(current)
      list(APPEND ranges "${current}")
    endforeach()
    return_ref(ranges)
  endif()


  ## get begin and end_inclusivity chars
  ## results in begin_inclusivity and end_inclusivity to be either "<" ">" or " "
  string(REGEX REPLACE "([^<>])+" "_" inclusivity "${range}")
  set(inclusivity "${inclusivity}___")
  string(SUBSTRING ${inclusivity} 0 1 begin_inclusivity )
  string(SUBSTRING ${inclusivity} 1 1 end_inclusivity )
  string(SUBSTRING ${inclusivity} 2 1 three )
  if(${end_inclusivity} STREQUAL _)
    set(end_inclusivity ${three})
  endif()


  ## transform "<" ">" and " " to a true or false value
  ## " " means default inclusivity
  set(default_begin_inclusivity)
  set(default_end_inclusivity)

  if("${begin_inclusivity}" STREQUAL "<")
    set(begin_inclusivity true)
  elseif("${begin_inclusivity}" STREQUAL ">")
    set(begin_inclusivity false)
  else()
   set(begin_inclusivity true)
   set(default_begin_inclusivity true) 
  endif()

  if("${end_inclusivity}" STREQUAL "<")
    set(end_inclusivity false)
  elseif("${end_inclusivity}" STREQUAL ">")
    set(end_inclusivity true)
  else()
    set(end_inclusivity true)
    set(default_end_inclusivity true)
  endif()

  ## remove all angular brackets from current range
  string(REGEX REPLACE "[<>]" "" range "${range}")

  ## default range for emtpy range (n:n)
  if("${range}_" STREQUAL "_")
    set(range "n:n:1")
    if(default_end_inclusivity)
      set(end_inclusivity false)
    endif()
  endif()

  ## default range for * 0:n
  if("${range}" STREQUAL "*")
    set(range "0:n:1")
  endif()

  ##  default range for  : 0:$
  if("${range}" STREQUAL ":")
    set(range "0:$:1")
  endif()

  ## split list at ":"
  string(REPLACE  ":" ";" range "${range}")
  
  ## normalize range and simplify elements
  

  ## single number is transformed to i;i;1 
  list(LENGTH range part_count)
  if(${part_count} EQUAL 1)
    set(range ${range} ${range} 1)
  endif()

  ## 2 numbers is autocompleted to  i;j;1
  if(${part_count} EQUAL 2)
    list(APPEND range 1)
  endif()

  ## now every range has 3 number begin end and increment
  list(GET range 0 begin)
  list(GET range 1 end)
  list(GET range 2 increment)

  ## if part count is higher than 3 the begin_inclusivity is specified
  if(${part_count} GREATER 3)
    list(GET range 3 begin_inclusivity)
  endif()
  ## if part count is higher than 4 the end_inclusivity is specified
  if(${part_count} GREATER 4)
    list(GET range 4 end_inclusivity)
  endif()

  ## invalid range end must be reachable from end using the specified increment
  if((${end} LESS ${begin} AND ${increment} GREATER 0) OR (${end} GREATER ${begin} AND ${increment} LESS 0))
    creturn()
  endif()

  ## set wether the range is reverse or forward
  set(reverse false)
  if(${begin} GREATER ${end})
    set(reverse true)
  endif()

  ## some special cases  -0 = $ (end)
  if(${begin} STREQUAL -0)
    set(begin $)
  endif()
  if(${end} STREQUAL -0)
    set(end $)
  endif()

  ## create math expression to calculate begin and end if anchors are used
  ## negative begin or end is transformed into $-i 
  set(begin_negative false)
  set(end_negative false)
  if(${begin} LESS 0)
    set(begin "($${begin})")
    set(begin_negative true)
  endif()
  if(${end} LESS 0)
    set(end "($${end})")
    set(end_negative true)
  endif()

  ## if begin or end contains a sign operator
  ## put it in parentheses
  if("${begin}" MATCHES "[\\-\\+]")
    set(begin "(${begin})")
  endif()
  if("${end}" MATCHES "[\\-\\+]")
    set(end "(${end})")
  endif()

  ## calculate length of range (number of elements that are spanned)
  ## depending on the orientation of the range 
  if(NOT reverse)
    set(length "${end}-${begin}")
    if(end_inclusivity)
      set(length "${length}+1")
    endif()
    if(NOT begin_inclusivity)
      set(length "${length}-1")
    endif()
  else()
    set(length "${begin}-${end}")
    if(begin_inclusivity)
      set(length "${length}+1")
    endif()
    if(NOT end_inclusivity)
      set(length "${length}-1")
    endif()
  endif()

  ## simplify some typical ranges 
  string(REPLACE "n-n" "0" length "${length}")
  string(REPLACE "n-$" "1" length "${length}")
  string(REPLACE "$-n" "0-1" length "${length}")
  string(REPLACE "$-$" "0" length "${length}")

  ## recalculate length by dividing by step size
  if("${increment}" GREATER 1)
    set(length "(${length}-1)/${increment}+1")
  elseif("${increment}" LESS -1)
    set(length "(${length}-1)/(0-(0${increment}))+1")
  elseif(${increment} EQUAL 0)
    set(length 1)
  endif()

  ## if no anchor is used the length can be directly computed
  if(NOT "${length}" MATCHES "\\$|n" )
    math(EXPR length "${length}")
  else()
     # 
  endif()

  ## set the range string and return it
  set(range "${begin}:${end}:${increment}:${begin_inclusivity}:${end_inclusivity}:${length}:${reverse}")

  return_ref(range)
endfunction()

# File: source/collections/range/range_partial_unpack.cmake

##
function(range_partial_unpack ref)
    if(NOT ${ref})
      set(${ref} ${ARGN})
    endif()
    set(partial ${${ref}})

    string(REPLACE ":" ";" parts ${partial})
    list(GET parts 0 begin)
    list(GET parts 1 end)
    list(GET parts 2 increment)
    list(GET parts 3 inclusive_begin)
    list(GET parts 4 inclusive_end)
    list(GET parts 5 length)

    set(${ref}.inclusive_begin ${inclusive_begin} PARENT_SCOPE)
    set(${ref}.inclusive_end ${inclusive_end} PARENT_SCOPE)    
    set(${ref}.begin ${begin} PARENT_SCOPE)
    set(${ref}.end ${end} PARENT_SCOPE)
    set(${ref}.increment ${increment} PARENT_SCOPE)
    set(${ref}.length  ${length} PARENT_SCOPE)
endfunction()



# File: source/collections/range/range_simplify.cmake

## `(<length:<int>> <range...>)-><instanciated range...>`
##
## tries to simplify the specified range for the given length
## his is done by getting the indices and then getting the range from indices
function(range_simplify length)
  set(args ${ARGN})

  list_pop_front(args)
  ans(current_range)

  range_indices("${length}" "${current_range}")
  ans(indices)

  ## get all indices
  while(true)
    list(LENGTH args indices_length)
    if(${indices_length} EQUAL 0)
      break()
    endif()
    list_pop_front(args)
    ans(current_range)
    list_range_get(indices "${current_range}")
    ans(indices)
  endwhile()

  range_from_indices(${indices})
  return_ans()
endfunction()

# File: source/collections/set/set_difference.cmake

## `(<listA&:<any...> <listB&:<any...>>)-><any..>`
## 
## 
function(set_difference __set_difference_listA __set_difference_listB)
  if("${${__set_difference_listA}}_" STREQUAL "_")
    creturn()
  endif()

  if(NOT "${${__set_difference_listB}}_" STREQUAL "_")
    list(REMOVE_ITEM "${__set_difference_listA}" ${${__set_difference_listB}})
  endif()
  list(REMOVE_DUPLICATES ${__set_difference_listA})
  #foreach(__list_operation_item ${${__set_difference_listB}})
   # list(REMOVE_ITEM ${__set_difference_listA} ${__list_operation_item})
  #endforeach()
  return_ref(${__set_difference_listA})
endfunction()




# File: source/collections/set/set_isequal.cmake

# retruns true iff lhs and rhs are the same set (ignoring duplicates)
# the null set is only equal to the null set 
# the order of the set (as implied in being a set) does not matter
function(set_isequal __set_equal_lhs __set_equal_rhs)
  set_issubset(${__set_equal_lhs} ${__set_equal_rhs})
  ans(__set_equal_lhsIsInRhs)
  set_issubset(${__set_equal_rhs} ${__set_equal_lhs})
  ans(__set_equal_rhsIsInLhs)
  if(__set_equal_lhsIsInRhs AND __set_equal_rhsIsInLhs)
    creturn(true)
  endif() 
  creturn(false)
endfunction()

# File: source/collections/set/set_issubset.cmake

# returns true iff lhs is subset of rhs
# duplicate elements in lhs and rhs are ignored
# the null set is subset of every set including itself
# no other set is subset of the null set
# if rhs contains all elements of lhs then lhs is the subset of rhs
function(set_issubset __set_is_subset_of_lhs __set_is_subset_of_rhs)
  list(LENGTH ${__set_is_subset_of_lhs} __set_is_subset_of_length)
  if("${__set_is_subset_of_length}" EQUAL "0")
    creturn(true)
  endif()
  list(LENGTH ${__set_is_subset_of_rhs} __set_is_subset_of_length)
  if("${__set_is_subset_of_length}" EQUAL "0")
    creturn(false)
  endif()
  foreach(__set_is_subset_of_item ${${__set_is_subset_of_lhs}})
    list(FIND ${__set_is_subset_of_rhs} "${__set_is_subset_of_item}" __set_is_subset_of_idx)
    if("${__set_is_subset_of_idx}" EQUAL "-1")
      creturn(false)
    endif()
  endforeach()
  creturn(true)
endfunction()



# File: source/collections/structured_list/structured_list_parse.cmake


# parses a structured list given the structure map
# returning a map which contains all the parsed values
function(structured_list_parse structure_map)
  map_new()
  ans(result)
  set(args ${ARGN})
  obj("${structure_map}")
  ans(structure_map)

  if(NOT structure_map)
    return_ref(result)
  endif() 

  # get all keys
  map_keys(${structure_map} )
  ans(keys)
  set(cutoffs)

  # parse every value descriptor from structure map
  # add every label to the list of cutoffs (a new element definition cuts othe rvalues)
  set(descriptors)
  foreach(key ${keys})
    map_tryget(${structure_map}  "${key}")
    ans(current)
    if(current)
      value_descriptor_parse(${key} ${current})
      ans(current_descriptor)

      list(APPEND descriptors ${current_descriptor})
      map_tryget(${current_descriptor}  "labels")
      ans(labels)
      list(APPEND cutoffs ${labels})        
    endif()
  endforeach()

  # go through each descriptor
  set(errors)
  foreach(current_descriptor ${descriptors})
    nav(labels = current_descriptor.labels)
    nav(id = current_descriptor.id)
    list(REMOVE_ITEM cutoffs ${labels})

    set(error)
    list_parse_descriptor(${current_descriptor} ERROR error UNUSED_ARGS args CUTOFFS cutoffs ${args} )
    #message(FORMAT "args left ${args} after {current_descriptor.id}")
    ans(current_result)
    if(NOT current_result)
      nav(current_result = current_descriptor.default)
    endif()
    if(error)
      list(APPEND errors ${id})
    endif()
    string_decode_semicolon("${current_result}")
    ans(current_result)
    map_navigate_set("result.${id}" ${current_result})
  endforeach()
  #message("args left ${args}")
  map_navigate_set("result.unused" "${args}")
  map_navigate_set("result.errors" "${errors}")
  #message("errors ${errors}")
  creturn(${result})
endfunction()

# File: source/collections/structured_list/structured_list_print_help.cmake


  function(list_structure_print_help structure)
    map_keys(${structure} )
    ans(keys)

    set(descriptors)
    set(structure_help)
    foreach(key ${keys})

      map_get(${structure}  ${key})
      ans(descriptor)
      value_descriptor_parse(${key} ${descriptor})
      ans(descriptor)
      list(APPEND descriptors ${descriptor})

      scope_import_map(${descriptor})
      set(current_help)
      list(GET labels 0 first_label)
      set(current_help ${first_label})

      if(NOT "${default}_" STREQUAL "_")
        set(current_help "[${current_help} = ${default}]")
      elseif(${min} EQUAL 0 )
        set(current_help "[${current_help}]")
      endif()


      set(structure_help "${structure_help} ${current_help}")

    endforeach()
    if(structure_help)
      string(SUBSTRING "${structure_help}" 1 -1 structure_help)
    endif()
    message("${structure_help}")
    message("Details: ")
    foreach(descriptor ${descriptors})
      scope_import_map(${descriptor})
      list_to_string( labels ", ")
      ans(res)
      message("${displayName}: ${res}")
      if(description)
        message_indent_push()
        message("${description}")
        message_indent_pop()
      endif()

    endforeach()
  endfunction()


# File: source/config/config_function.cmake

function(config_function config_obj config_definition key)
    set(args ${ARGN})

    if (${key} STREQUAL "*")
        creturn(${config_obj})
    endif ()
    if (${key} STREQUAL "help")
        list_structure_print_help(${config_definition})
        creturn()
    endif ()
    if (${key} STREQUAL "print")
        json_print(${config_obj})
        creturn()
    endif ()
    if (${key} STREQUAL "set")
        list_pop_front(args)
        ans(key)
        map_set("${config_obj}" "${key}" ${args})
    endif ()
    map_get("${config_obj}" "${key}")
    return_ans()
endfunction()

# File: source/config/config_setup.cmake



function(config_setup name definition)
  map_get(global unused_command_line_args)
  ans(args)
  structured_list_parse("${definition}" ${args})
  ans(config)
  map_tryget(${config} unused)
  ans(args)
  map_set(global unused_command_line_args ${args})
  #curry(config_function("${config}" "${definition}" /1) as "${name}")
  curry3("${name}"(a) => config_function("${config}" "${definition}" /a))
endfunction()

# File: source/core/beep.cmake

function(beep)
  string(ASCII 7 beep)
  echo_append("${beep}")
endfunction()

# File: source/core/cache.cmake

function(cached arg)
    json("${arg}")
    ans(ser)
    string(MD5 cache_key "${ser}")
    set(args ${ARGN})
    list(LENGTH args arg_len)
    if(arg_len)

      map_set(global_cache_entries "${cache_key}" "${args}")
      return_ref(args)
    endif()


    map_tryget(global_cache_entries "${cache_key}")    
    ans(res)
    return_ref(res)


endfunction()

  macro(return_hit arg_name)
    cached("${${arg_name}}")
    if(__ans)
      message("hit")
      return_ans()
    endif()
      message("not hit")
  endmacro()




# File: source/core/cmake/_cmake.cmake


## fast wrapper for cmake
function(cmake_lean)
  wrap_executable_bare(cmake_lean "${CMAKE_COMMAND}")
  cmake_lean(${ARGN})
  return_ans()
endfunction()

# File: source/core/cmake/cmake.cmake


## convenience function for accessing cmake
function(cmake)
  wrap_executable(cmake "${CMAKE_COMMAND}")
  cmake(${ARGN})
  return_ans()
endfunction() 


# File: source/core/cmake/cpack.cmake


## convenience function for accessing cpack
function(cpack)
  path_parent_dir("${CMAKE_COMMAND}")
  ans(parentPath)
  glob("${parentPath}/cpack*")
  ans(cpack_command)

  wrap_executable(cpack "${cpack_command}")
  cpack(${ARGN})
  return_ans()
endfunction() 


# File: source/core/cmake/ctest.cmake


## convenience function for accessing ctest
function(ctest)
  path_parent_dir("${CMAKE_COMMAND}")
  ans(parentPath)
  glob("${parentPath}/ctest*")
  ans(ctest_command)

  wrap_executable(ctest "${ctest_command}")
  ctest(${ARGN})
  return_ans()
endfunction() 


# File: source/core/cmake_entry_point.cmake

## returns the entry script file from which cmake was started
function(cmake_entry_point)
  commandline_args_get()
  ans(args)
  list_extract_labelled_value(args -P)
  ans(script_file)
  path_qualify(script_file)
  return_ref(script_file)
endfunction()

# File: source/core/commandline_arg_string.cmake

# returns the list of command line arguments
function(commandline_arg_string)
  set(args)
  foreach(i RANGE 3 ${CMAKE_ARGC})  
    set(current ${CMAKE_ARGV${i}})
    string(REPLACE \\ / current "${current}")
    set(args "${args} ${current}")
    
  endforeach()  

  return_ref(args)
endfunction() 


# File: source/core/commandline_args_get.cmake

## commandline_args_get([--no-script])-> <string...>
## 
## returns the command line arguments with which cmake 
## was without the executable
##
## --no-script flag removes the script file from the command line args
##
## Example:
## command line: 'cmake -P myscript.cmake a s d'
## commandline_args_get() -> -P;myscript;a;s;d
## commandline_args_get(--no-script) -> a;s;d

function(commandline_args_get)
  set(args ${ARGN})
  list_extract_flag(args --no-script)
  ans(no_script)
  commandline_get()
  ans(args)
  # remove executable
  list_pop_front(args)
  if(no_script)
    list_extract_labelled_value(args -P)
  endif()
  return_ref(args)
endfunction()

# File: source/core/commandline_extract.cmake


# extracts the specified values from the command line (see list extract)
# returns the rest of the command line
# the first three arguments of commandline_get are cmake command, -P, script file 
# these are ignored
function(commandline_extract)
  commandline_get()
  ans(args)
  list_extract(args cmd p script ${ARGN})
  ans(res)
  vars_elevate(${ARGN})
  set(res ${cmd} ${p} ${script} ${res})
  return_ref(res)
endfunction()



# File: source/core/commandline_get.cmake

# returns the list of command line arguments
function(commandline_get)
  set(args)
  foreach(i RANGE ${CMAKE_ARGC})  
    set(current ${CMAKE_ARGV${i}})
    string(REPLACE \\ / current "${current}")
    list(APPEND args "${current}")    
  endforeach()  

  return_ref(args)
endfunction() 


## 
##
## returns script | configure | build
function(cmake_mode)

endfunction()


# File: source/core/commandline_string.cmake

# returns the list of command line arguments
function(commandline_string)
  set(args)
  foreach(i RANGE ${CMAKE_ARGC})  
    set(current ${CMAKE_ARGV${i}})
    string(REPLACE \\ / current "${current}")
    set(args "${args} ${current}")
    
  endforeach()  

  return_ref(args)
endfunction() 


# File: source/core/dbg.cmake

function(dbg)
  set(args ${ARGN})
  list_extract_flag(args --indented)
  ans(indented)
  if(NOT args)
    set(last_return_value "${__ans}")
    set(args last_return_value)
  endif()
  if("${args}")
    is_map("${${args}}")
    ans(ismap)
    if(ismap)
      if(indented)
        json_indented("${${args}}")
      else()
        json("${${args}}")
      endif()
      ans("${args}")
    endif()
    dbg("${args}: '${${args}}'")
    creturn()
  endif()
  list_length(args)
  ans(len)
  if("${len}" EQUAL 1)
    is_map("${args}")
    ans(ismap)
    if(ismap)  
      if(indented)
        json_indented("${args}")
      else()
        json("${args}")
      endif()
      ans("${args}")

    endif()
    message(FORMAT "dbg (${__function_call_func}): '${args}'")
    creturn()
  endif()

  foreach(arg ${args})
    dbg("${arg}")
  endforeach()

  creturn()
endfunction()

# File: source/core/dec2hex.cmake

# converts a decimal number to a hexadecimal string
# e.g. dec2hex(195936478) => "BADC0DE"

  function(dec2hex n)
    set(rest ${n})
    set(converted)

    if("${n}" EQUAL 0)
      creturn(0)
    endif()
    
    while(${rest} GREATER 0)
      math(EXPR c "${rest} % 16")
      math(EXPR rest "(${rest} - ${c})>> 4")

      if("${c}" LESS 10)
        list(APPEND converted "${c}")
      else()
        if(${c} EQUAL 10)
          list(APPEND converted A)
        elseif(${c} EQUAL 11)
          list(APPEND converted B)
        elseif(${c} EQUAL 12)
          list(APPEND converted C)
        elseif(${c} EQUAL 13)
          list(APPEND converted D)
        elseif(${c} EQUAL 14)
          list(APPEND converted E)
        elseif(${c} EQUAL 15)
          list(APPEND converted F)
        endif()
      endif()
    endwhile()
    list(LENGTH converted len)
    if(${len} LESS 2)
      creturn(${converted})
    endif()
    list(REVERSE converted)
    string_combine("" ${converted})
    return_ans()
  endfunction() 

# File: source/core/define_cache_function.cmake

## `()->`
## 
## defines a function called alias which caches its results
##
function(define_cache_function generate_value)
  set(args ${ARGN})

  list_extract_labelled_value(args =>)
  ans(alias)
  if(NOT alias)
    function_new()
    ans(alias)
  endif()

  list_extract_labelled_value(args --generate-key)
  ans(generate_key)
  if(NOT generate_key)
      set(generate_key "[]()checksum_string('{{ARGN}}')")
  endif()

  list_extract_labelled_value(args --select-value)
  ans(select_value)
  if(NOT select_value)
      set(select_value "[]()set_ans('{{ARGN}}')")
  endif()
  

  list_extract_labelled_value(args --cache-dir)
  ans(cache_dir)
  if(NOT cache_dir)
    cmakepp_config(temp_dir)
    ans(cache_dir)
    set(cache_dir "${cache_dir}/cache_functions/${alias}")
  endif()


  list_extract_flag(args --refresh)
  ans(refresh)

#    print_vars(generate_key generate_value select_value refresh  cache_dir)
  if(refresh)
    rm(-r "${cache_dir}")
  endif()
    
  callable_function("${generate_key}")
  ans(generate_key)
  callable_function("${generate_value}")
  ans(generate_value)
  callable_function("${select_value}")
  ans(select_value)

  eval("
    function(${alias})
      set(args \${ARGN})
      list_extract_flag(args --update-cache)
      ans(update)

      ${generate_key}(\${args})
      ans(cache_key)
      set(cache_path \"${cache_dir}/\${cache_key}\")
      
      map_has(memory_cache \"\${cache_path}\")
      ans(has_entry)

      if(has_entry AND NOT update)
  #      message(memhit)
        map_tryget(memory_cache \"\${cache_path}\")
        ans(cached_result)
      elseif(EXISTS \"\${cache_path}/value.scmake\" AND NOT update)
   #     message(filehit)
        cmake_read(\"\${cache_path}/value.scmake\")
        ans(cached_result)
        map_set(memory_cache \"\${cache_path}\" \${cached_result})
      else()
       # if(update)
    #      message(update )
       # else()
     #     message(miss )
      #  endif()
        ${generate_value}(\${args})
        ans(cached_result)
        map_set(memory_cache \"\${cache_path}\" \${cached_result})
        cmake_write(\"\${cache_path}/value.scmake\" \${cached_result})
      endif()
      ${select_value}(\${cached_result})
      return_ans()
    endfunction()
    ")
  return_ref(alias)
endfunction()




# File: source/core/echo_append_indent.cmake


  function(echo_append_indent)
    message_indent_get()
    ans(indent)

    echo_append("${indent} ${ARGN}")
    creturn()
  endfunction()

# File: source/core/echo_append_padded.cmake


  function(echo_append_padded len str)
    string_pad("${str}" "${len}" " ")
    ans(str)
    echo_append("${str}")
  endfunction()

# File: source/core/err.cmake



# File: source/core/eval.cmake

# Evaluate expression (faster version)
# Suggestion from the Wiki: http://cmake.org/Wiki/CMake/Language_Syntax
# Unfortunately, no built-in stuff for this: http://public.kitware.com/Bug/view.php?id=4034
# eval will not modify ans (the code evaluated may modify ans)
# vars starting with __eval should not be used in code
function(eval __eval_code)
  
  # one file per execution of cmake (if this file were in memory it would probably be faster...)
  fwrite_temp("" ".cmake")
  ans(__eval_temp_file)


# speedup: statically write filename so eval boils down to 3 function calls
 file(WRITE "${__eval_temp_file}" "
function(eval __eval_code)
  file(WRITE ${__eval_temp_file} \"\${__eval_code}\")
  include(${__eval_temp_file})
  set(__ans \${__ans} PARENT_SCOPE)
endfunction()
  ")
include("${__eval_temp_file}")


eval("${__eval_code}")
return_ans()
endfunction()




# File: source/core/eval_cmake.cmake

 ## `(<unquoated cmake code>)-><any>`
  ##
  ## evals the unquoted cmake code
  ## **example**
  ## ```
  ## set(callback message)
  ## eval_unquoted(
  ##   function(my_func)
  ##     ${callback}(hello \${ARGN} )
  ##     creturn(ok)
  ##   endfunction()
  ##   creturn(huhu)
  ## )
  ## ans(result) #-> result contains 'huhu'
  ## my_func(tobias) # -> returns 'ok' and prints 'hello tobias'
  ## ```
  function(eval_cmake)
    arguments_cmake_code(0 ${ARGC})
    ans(code)
    eval("${code}")
    return_ans()
  endfunction()

# File: source/core/eval_math.cmake

# evaluates a cmake math expression and returns its
# value
function(eval_math)
  math(EXPR res ${ARGN})
  return_ref(res)
endfunction()


# File: source/core/eval_ref.cmake

# macro version of eval function which causes set(PARENT_SCOPE ) statements to access 
# scope of invokation
macro(eval_ref __eval_code_ref)
  fwrite_temp("" ".cmake")
  eval("
 macro(eval_ref __eval_code_ref_inner)
   file(WRITE ${__ans} \"\${\${__eval_code_ref_inner}}\")
   include(${__ans})
 endmacro()
   ")
 eval_ref(${__eval_code_ref})
endmacro()




# File: source/core/eval_truth.cmake

# evaluates a truth expression 'if' and returns true or false 
function(eval_truth)
  if(${ARGN})
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/core/eval_unique.cmake

## 
## 
## for special cases eval unique will create a new file for every code
## 
function(eval_unique __unique_eval_code)
  mk_temp()
  ans(dir)
  eval("
  function(eval_unique __unique_eval_code)
    string(MD5 file \"\${__unique_eval_code}\")
    file(WRITE \"${dir}/\${file}\" \"\${__unique_eval_code}\")
    include(\"${dir}/\${file}\")
  endfunction()
  ")
  eval_unique("${__unique_eval_code}")
  return_ans()
endfunction()




# File: source/core/exception/catch.cmake

## `(<exception_handler: <anonymous function>>)-><error>|<any>`
##
## catches an exception using the specified exception handler
## if no exception handler is specified the catch function returns nothing
## which is not an exception
## the exception handler may throw a new exception 
## which can be caught as well
function(catch)
  set(exception "${__ans}")
  is_exception("${exception}")
  ans(is_exception)
  
  if(NOT is_exception)
    return()
  endif()

  address_pop_back(unhandled_exceptions)
  address_push_back(handled_exceptions ${exception})

  ## a single argument is interpreted as a variable
  if(${ARGC} EQUAL 1)
    ## maybe handle callable here as well?
    set(${ARGV0} ${exception} PARENT_SCOPE)
    creturn()
  endif()

  arguments_anonymous_function(0 ${ARGC})
  ans(exception_handler)
  
  if(NOT exception_handler)
    creturn()
  endif()

  eval("${exception_handler}(${exception})")
  return_ans()
endfunction()

# File: source/core/exception/exception.cmake

## `(<exception>|<any>)-> <exception>`
##
## transforms the input into an exception
## or returns the input exception
function(exception)
  is_exception("${ARGN}")
  ans(is_exception)
  if(is_exception)
    creturn("${ARGN}")
  endif()
  exception_new("${ARGN}")
  return_ans()
endfunction()

# File: source/core/exception/exception_new.cmake

##
##
## an exception is map `<exception> ::= { message: <string> }` of $type `exception` 
## if checked in an if statement it evaluates to false because it ends with -NOTFOUND
## 
function(exception_new message)
  address_new()
  ans(error)
  set(error "${error}-NOTFOUND")
  map_set(${error} message "${message}")
  if(ARGN)
    map_set(${error} inner_exceptions ${ARGN})
  endif()
  map_set_special(${error} $type exception)
  return_ref(error)
endfunction()

# File: source/core/exception/is_exception.cmake


## `(<any>...)-><bool>`
##
## returns true iff the specified value is an exception
function(is_exception)
  map_get_special("${ARGN}" $type)
  ans(type)
  if("_${type}" STREQUAL "_exception")
    creturn(true)
  endif()
  creturn(false)
endfunction()


# File: source/core/exception/rethrow.cmake

## `(<fail:<bool>> )->` 
## 
## rethrows if the last return value was an exception
## else changes nothing
## if you pass true the exception will be treated as a fatal error
macro(rethrow)
  set(___ans "${__ans}")
  is_exception("${__ans}")
  if(__ans)
    if("${ARGN}_" STREQUAL "true_")
      set(ex ${___ans})
      message(FATAL_ERROR FORMAT "fatal exception: '{ex.message}'")
    endif()
    throw("${___ans}")
  endif()
  set(__ans "${___ans}")
endmacro()




# File: source/core/exception/throw.cmake

## `(<exception> | <any>)->`
##
## may be used in functions.  causes the function to 
## return with an exception which can be caught
macro(throw)
  exception("${ARGN}")
  ans(__exc)
  address_push_back(unhandled_exceptions "${__exc}")
  address_push_back(exceptions "${__exc}")
  event_emit(on_exception ${__exc})
  return_ref(__exc)
endmacro()

# File: source/core/global_config.cmake

function(global_config key)
  map_get(global "${key}")
  ans(res)
  set("${key}" "${res}" PARENT_SCOPE)
  return_ref(res)
endfunction()

# File: source/core/graphsearch.cmake

  function(graphsearch)
    cmake_parse_arguments("" "" "EXPAND;PUSH;POP" "" ${ARGN})

    if(NOT _EXPAND)
      message(FATAL_ERROR "graphsearch: no expand function set")
    endif()

    function_import("${_EXPAND}" as gs_expand REDEFINE)
    function_import("${_PUSH}" as gs_push REDEFINE)
    function_import("${_POP}" as gs_pop REDEFINE)

    # add all arguments to stack
    foreach(node ${_UNPARSED_ARGUMENTS})

      gs_push(${node})
    endforeach()

    # iterate
    while(true)
      gs_pop()
      ans(current)
      #message("current ${current}")
      # recursion anchor - no more node
      if(NOT current)
        break()
      endif()
      gs_expand(${current})
      ans(successors)
      foreach(successor ${successors})
        gs_push(${successor})
      endforeach()
      
    endwhile()
  endfunction()


# File: source/core/hex2dec.cmake

function(hex2dec str)
    string(LENGTH "${str}" len)
    
    if ("${len}" LESS 1)
    elseif (${len} EQUAL 1)
        if (${str} MATCHES "[0-9]")
            creturn("${str}")
        elseif (${str} MATCHES "[aA]")
            creturn(10)
        elseif (${str} MATCHES "[bB]")
            creturn(11)
        elseif (${str} MATCHES "[cC]")
            creturn(12)
        elseif (${str} MATCHES "[dD]")
            creturn(13)
        elseif (${str} MATCHES "[eE]")
            creturn(14)
        elseif (${str} MATCHES "[fF]")
            creturn(15)
        else ()
            # invalid character
            creturn()
        endif ()
    else ()
        math(EXPR len "${len} - 1")
        set(result 0)

        foreach (i RANGE 0 ${len})
            string_char_at(${str} "${i}")
            ans(c)
            hex2dec("${c}")
            ans(c)

            if ("${c}_" STREQUAL "_")
                # illegal char
                creturn()
            endif ()

            math(EXPR result "${result} + (2 << ((${len}-${i})*4)) * ${c}")
        endforeach ()

        math(EXPR result "${result} >> 1")
        creturn(${result})

    endif ()
    creturn()
endfunction()

# File: source/core/icmake.cmake

# spawns an interactive cmake session
# use @echo off and @echo on to turn printing of result off and on
# use quit or exit to terminate
# usage: cmake()
function(icmake)
    # outer loop loops untul quit or exit is input
    set(echo on)
    set(strict off)
    while (true)
        pwd()
        ans(pwd)
        echo_append("icmake ${pwd}/> ")
        set(cmd)
        # inner loop for reading multiline inputs (delimited by \)
        set(line "\\")
        set(first true)
        while ("${line}" MATCHES ".*\\\\$")
            if (first)
                set(first false)
                set(line "")
            else ()
                echo_append("        ")
            endif ()

            read_line()
            ans(line)
            if ("${line}" MATCHES ".*\\\\$")
                string_slice("${line}" 0 -2)
                ans(theline)
            else ()
                set(theline "${line}")
            endif ()
            set(cmd "${cmd}\n${theline}")

        endwhile ()
        if ("${line}" MATCHES "^(quit|exit)$")
            break()
        endif ()

        if ("${cmd}" MATCHES "@echo on")
            message("echo is now on")
            set(echo on)
            break()
        elseif ("${cmd}" MATCHES "@echo off")
            message("echo is now off")
            set(echo off)
            break()
        elseif ("${cmd}" MATCHES "@string off")
            message("strict is now off")
            set(strict off)
        elseif ("${cmd}" MATCHES "@string on")
            message("strict is no on")
            set(strict on)
        else ()
            # check if cmd is valid cmake
            #todo
            if (NOT strict)
                lazy_cmake("${cmd}")
                ans(cmd)
            endif ()
            set_ans("${ANS}")
            eval_ref(cmd)
            ans(ANS)
            if (echo)
                json_print(${ANS})
            endif ()
        endif ()
    endwhile ()
    creturn()
endfunction()

# File: source/core/identifier.cmake


## 
##
## returns an identifier of the form `__{ARGN}_{unique}`
## the idetnfier will not be a defined function 
## nor a defined variable, nor a existing global 
## property.  it is unique to the execution of cmake
## and can be used as a function name
function(identifier)
  #string_codes()
  while(true)
    make_guid()
    ans(guid)
    set(identifier "__${ARGN}_${guid}")
    if(NOT COMMAND "${identifier}" AND NOT "${identifier}")
      return_ref(identifier)
    endif()
  endwhile()
  message(FATAL_ERROR "code never reached")
endfunction()

# File: source/core/include_glob.cmake

## includes all files identified by globbing expressions
## see `glob` on globbing expressions
function(include_glob)
  set(args ${ARGN})
  glob(${args})
  ans(files)
  foreach(file ${files})
    include_once("${file}")
  endforeach()

  creturn()
endfunction()

# File: source/core/include_once.cmake

function(include_once file)
  get_filename_component(file "${file}" REALPATH)
  string(MD5 md5 "${file}")
  get_property(wasIncluded GLOBAL PROPERTY "include_guards.${md5}")
  if(wasIncluded)
  	creturn()
  endif()
  set_property(GLOBAL PROPERTY "include_guards.${md5}" true)
  include("${file}")
endfunction()

# File: source/core/is_script_mode.cmake

## returns true iff cmake is currently in script mode
function(is_script_mode)
 commandline_get()
 ans(args)

 list_extract(args command P path)
 if("${P}" STREQUAL "-P")
  creturn(true)
else()
  creturn(false)
 endif()
endfunction()

## returns the file that was executed via script mode
function(script_mode_file)
  commandline_get()
  ans(args)

 list_extract(args command P path)
if(NOT "${P}" STREQUAL "-P")
  creturn()
endif()
  path("${path}")
  ans(path)
  return_ref(path)
endfunction()



# File: source/core/lazy_cmake.cmake

# turns the lazy cmake code into valid cmake
#
function(lazy_cmake cmake_code)
# normalize cmake 
  # 
  string(STRIP "${cmake_code}" cmake_code )
  if(NOT "${cmake_code}" MATCHES "[ ]*[a-zA-Z0-9_]+\\(.*\\)[ ]*")
    string(REGEX REPLACE "[ ]*([a-zA-Z0-9_]+)[ ]*(.*)" "\\1(\\2)" cmd "${cmake_code}")
    string(REGEX REPLACE "[ ]*([a-zA-Z0-9_]+)[ ]*(.*)" "\\1" cmdname "${cmake_code}")
    if(NOT COMMAND "${cmdname}")
      string(STRIP "${cmake_code}" cc)
      set(cmd "set_ans(\"\${${cc}}\")")
    endif()
  endif()



  return_ref(cmd)

endfunction()

# File: source/core/make_guid.cmake


#creates a unique id
function(make_guid)
  string(RANDOM LENGTH 10 id)
   return_ref(id)
endfunction()

## faster
macro(make_guid)
  string(RANDOM LENGTH 10 __ans)
  #set(__ans ${id} PARENT_SCOPE)
endmacro()


# File: source/core/math_max.cmake

# retruns the larger of the two values
function(math_max a b)
  if(${a} GREATER ${b})
    creturn(${a})
  else()
    creturn(${b})
  endif() 
endfunction()

# File: source/core/math_min.cmake


function(math_min a b)
  if(${a} LESS ${b})
    creturn(${a})
  else()
    creturn(${b})
  endif() 
endfunction()

# File: source/core/message.cmake


# function(message)
# 	cmake_parse_arguments("" "PUSH_AFTER;POP_AFTER;DEBUG;INFO;FORMAT;PUSH;POP" "LEVEL" "" ${ARGN})
# 	set(log_level ${_LEVEL})
# 	set(text ${_UNPARSED_ARGUMENTS})
# 
# 	## indentation
# 	if(_PUSH)
# 		message_indent_push()
# 	endif()
# 	if(_POP)
# 		message_indent_pop()
# 	endif()
# 
# 
# 	message_indent_get()
# 	ans(indent)
# 	if(_POP_AFTER)
# 		message_indent_pop()
# 	endif()
# 	if(_PUSH_AFTER)
# 		message_indent_push()
# 	endif()
# 	## end of indentationb
# 
# 
# 	## log_level
# 	if(_DEBUG)
# 		if(NOT log_level)
# 			set(log_level 3)
# 		endif()
# 		set(text STATUS ${text})
# 	endif()
# 	if(_INFO)
# 		if(NOT log_level)
# 			set(log_level 2)
# 		endif()
# 		set(text STATUS ${text})
# 	endif()
# 	if(NOT log_level)
# 		set(log_level 0)
# 	endif()
# 
# 	if(NOT MESSAGE_LEVEL)
# 		set(MESSAGE_LEVEL 3)
# 	endif()
# 
# 	list(GET text 0 modifier)
# 	if(${modifier} MATCHES "FATAL_ERROR|STATUS|AUTHOR_WARNING|WARNING|SEND_ERROR|DEPRECATION")
# 		list(REMOVE_AT text 0)
# 	else()
# 		set(modifier)
# 	endif()
# 
# 	## format
# 	if(_FORMAT)
# 		format( "${text}")
# 		ans(text)
# 	endif()
# 
# 	if(NOT MESSAGE_DEPTH )
# 		set(MESSAGE_DEPTH -1)
# 	endif()
# 
# 	if(NOT text)
# 		creturn()
# 	endif()
# 
# 	map_new()
# 	ans(message)
# 	map_set(${message} text "${text}")
# 	map_set(${message} indent_level ${message_indent_level})
# 	map_set(${message} log_level ${log_level})
# 	map_set(${message} mode "${modifier}")
# 	event_emit(on_message ${message})
# 
# 	if(log_level GREATER MESSAGE_LEVEL)
# 		creturn()
# 	endif()
# 	if(MESSAGE_QUIET)
# 		creturn()
# 	endif()
# 	# check if deep message are to be ignored
# 	if(NOT MESSAGE_DEPTH LESS 0)
# 		if("${message_indent_level}" GREATER "${MESSAGE_DEPTH}")
# 			creturn()
# 		endif()
# 	endif()
# 
# 	tock()
# 
# 	## clear status line
# 	status_line_clear()
# 	_message(${modifier} "${indent}" "${text}")
# 	status_line_restore()
# 
# 	
# 	creturn()
# endfunction()




# File: source/core/message_indent.cmake


  
  function(message_indent msg) 
    message_indent_get()
    ans(indent)
    _message("${indent}${msg}")
  endfunction()



# File: source/core/message_indent_get.cmake

function(message_indent_get)
  message_indent_level()
  ans(level)
  string_repeat(" " ${level})
  return_ans()
endfunction()


# File: source/core/message_indent_level.cmake

function(message_indent_level)
  map_peek_back("global" "message_indent_level")
  ans(level)
  if(NOT level)
    creturn(0)
  endif()
  return_ref(level)
endfunction()


# File: source/core/message_indent_level_pop.cmake


function(message_indent_pop)
  map_pop_back(global message_indent_level)
  ans(old_level)
  message_indent_level()
  ans(current_level)
  return_ref(current_level)
endfunction()


# File: source/core/message_indent_level_push.cmake



function(message_indent_push)
  
  set(new_level ${ARGN})
  if("${new_level}_" STREQUAL "_")
    set(new_level +1)
  endif()
  
  if("${new_level}" MATCHES "[+\\-]")
    message_indent_level()
    ans(previous_level)
    math(EXPR new_level "${previous_level} ${new_level}")
    if(new_level LESS 0)
      set(new_level 0)
    endif()
  endif()
  map_push_back(global message_indent_level ${new_level})
  creturn(${new_level})
endfunction()

# File: source/core/os.cmake

# returns the identifier for the os being used
function(os)
  if(CMAKE_HOST_WIN32)
    creturn(Windows)
  elseif(UNIX)
    creturn(Linux)
  else()
    creturn()
  endif()


endfunction()


# File: source/core/parse_command_line.cmake

# parses the command line string into parts (handling strings and semicolons)
function(parse_command_line result args)

  string(ASCII  31 ar)
  string(REPLACE "\;" "${ar}" args "${args}" )
  string(REGEX MATCHALL "((\\\"[^\\\"]*\\\")|[^ ]+)" matches "${args}")
  string(REGEX REPLACE "(^\\\")|(\\\"$)" "" matches "${matches}")
  string(REGEX REPLACE "(;\\\")|(\\\";)" ";" matches "${matches}")
# hack for windows paths
  string(REPLACE "\\" "/" matches "${matches}")
  set("${result}" "${matches}" PARENT_SCOPE)
endfunction()

# File: source/core/pkg.cmake

function(pkg)
  cmakepp_project_cli(${ARGN})
  return_ans()
endfunction()


  

# File: source/core/print.cmake

## prints str to console without reformatting it and no message type
function(print str)
  _message("${str}")
endfunction()

# File: source/core/process_start_info.cmake

## takes a ~<command line> or ~<process start info>
## and returns a valid  process start info
function(process_start_info)
  set(__args ${ARGN})

  list_extract_labelled_value(__args TIMEOUT)
  ans(timeout_arg)

  list_extract_labelled_value(__args WORKING_DIRECTORY)
  ans(cwd_arg)

  if("${ARGN}_" STREQUAL "_")
    creturn()
  endif()


  obj("${ARGN}")
  ans(obj)

  if(NOT obj)
    command_line(${__args})
    ans(obj)
  endif()


  if(NOT obj)
    message(FATAL_ERROR "invalid process start info ${ARGN}")
  endif()

  set(path)
  set(cwd)
  set(command)
  set(args)
  set(parameters)
  set(timeout)
  set(arg_string)
  set(command_string)

  scope_import_map(${obj})

  if("${args}_" STREQUAL "_")
    set(args ${parameters})
  endif()

  if("${command}_" STREQUAL "_")
    set(command "${path}")
    if("${command}_" STREQUAL "_")
      message(FATAL_ERROR "invalid <process start info> missing command property")
    endif()
  endif()

  if(timeout_arg)
    set(timeout "${timeout_arg}")
  endif()

  if("${timeout}_" STREQUAL "_" )
    set(timeout -1)
  endif()




  if(cwd_arg)
    set(cwd "${cwd_arg}")
  endif()

  path("${cwd}")
  ans(cwd)

  if(EXISTS "${cwd}")
    if(NOT IS_DIRECTORY "${cwd}")
      message(FATAL_ERROR "specified working directory path is a file not a directory: '${cwd}'")
    endif()
  else()
    message(FATAL_ERROR "specified workind directory path does not exist : '${cwd}'")
  endif()



  # create a map from the normalized input vars
  map_capture_new(command args cwd timeout)
  return_ans()

endfunction()

# File: source/core/promote.cmake

## `(<ref>...)->void`
##
## promotes every specified variable to the PARENT_SCOPE if it is defined
macro(promote )
  foreach(__current_arg ${ARGN})      
    if(DEFINED ${__current_arg})
      set(${__current_arg} "${${__current_arg}}" PARENT_SCOPE)      
    endif()
  endforeach()
endmacro()  

# File: source/core/require.cmake

function(require file)
  file(GLOB_RECURSE res "${file}")

  if(NOT res)
    message(FATAL_ERROR "could not find required file for '${file}'")
  endif()

  foreach(file ${res})
    include("${file}")
  endforeach()

endfunction()


# File: source/core/require_include_dirs.cmake


  function(require_include_dirs )
    require_map()
    ans(map)
    map_get(${map}  include_dirs)
    ans(stack)
    stack_pop(${stack})
    ans(dirs)
    list(APPEND dirs ${ARGN})
    stack_push(${stack} ${dirs})

  endfunction()


# File: source/core/require_map.cmake

function(require_map)
  map_set_hidden(:__require_map __type__ map)
  stack_new()
  ans(stack)
  map_set_hidden(:__require_map include_dirs ${stack})

  function(require_map)
    creturn(":__require_map")
  endfunction()
  require_map()
  return_ans()
endfunction()

# File: source/core/return/ans.cmake

# assigns the result return by a functi on to the specified variable
# must be immediately called after funct ion call
# if no argument is passed current __ans will be cleared (this should be called at beginning of ffunc)
# the name ans stems from calculators ans and signifies the last answer
function(ans __ans_result)
  set(${__ans_result} "${__ans}" PARENT_SCOPE)
endfunction()



# File: source/core/return/ans_append.cmake



## appends the last return value to the specified list
macro(ans_append __lst)
  list(APPEND ${__lst} ${__ans})
endmacro()

# File: source/core/return/ans_extract.cmake

## extracts the the specified variables in order from last result
## returns the rest of the result which was unused
## ```
## do_something()
## ans_extract(value1 value2)
## ans(rest)
## ``` 
macro(ans_extract)
  ans(__ans_extract_list)
  list_extract(__ans_extract_list ${ARGN})
endmacro()

# File: source/core/return/clr.cmake

# used to clear the __ans variable. may also called inside a function with argument PARENT_SCOPE to clear
# parent __ans variable
macro(clr)
  set(__ans ${ARGN})
endmacro()

# File: source/core/return/creturn.cmake

## 
##
## when not to use: if your data degrades when evaluated by a macro
## for example escapes are resolved
macro(creturn)
  set(__ans "${ARGN}" PARENT_SCOPE)
	return()
endmacro()

# File: source/core/return/return_ans.cmake

#returns the last returned value
# this is a shorthand useful when returning the rsult of a previous function
macro(return_ans)
  return_ref(__ans)
endmacro()


# File: source/core/return/return_math.cmake


  macro(return_math expr)
    math(EXPR __return_math_res "${expr}")
    creturn(${__return_math_res})
  endmacro()


# File: source/core/return/return_ref.cmake

# returns the var called ${ref}
# this inderection is needed when returning escaped string, else macro will evaluate the string
macro(return_ref __return_ref_ref)
  set(__ans "${${__return_ref_ref}}" PARENT_SCOPE)
  return()
endmacro()



# File: source/core/return/return_refs.cmake


## returns the values of multiple refs
macro(return_refs)
  set(__ans)
  foreach(arg ${ARGN})
    list(APPEND __ans "${${arg}}")
  endforeach()
  set(__ans "${__ans}" PARENT_SCOPE)
  return()
endmacro()

# File: source/core/return/return_reset.cmake

macro(return_reset)
  set(__ans PARENT_SCOPE)
endmacro()

# File: source/core/return/return_truth.cmake

macro(return_truth)
  if(${ARGN})
    creturn(true)
  endif()
  creturn(false)
endmacro()


# File: source/core/return/set_ans.cmake

function(set_ans )
  set(__set_ans_val ${ARGN})
  return_ref(__set_ans_val)
endfunction()

# File: source/core/return/set_ans_ref.cmake

function(set_ans_ref __set_ans_ref_ref)
  return_ref("${__set_ans_ref_ref}")

endfunction()

# File: source/core/return_data.cmake


  macro(return_data data)
    data("${data}")
    return_ans()
  endmacro()

# File: source/core/return_if_run_before.cmake

macro( return_if_run_before id)
	#string(MAKE_C_IDENTIFIER ${id} guard)
	string_normalize( "{id}")
  ans(guard)
	get_property(was_run GLOBAL PROPERTY ${guard})
	if(was_run)
		creturn()
	endif()
	set_property(GLOBAL PROPERTY ${guard} true)
endmacro()


# File: source/core/return_nav.cmake


  macro(return_nav)
    assign(result = ${ARGN})
    return_ref(result)
  endmacro()

# File: source/core/return_value.cmake


#returns a value 
# expects a variable called result to exist in function signature
# may only be used inside functions
macro(return_value)
  if(NOT result)
    message(FATAL_ERROR "expected a variable called result to exist in function")
    creturn()
  endif()
  set(${result} ${ARGN} PARENT_SCOPE)
  creturn(${ARGN})
endmacro()

# File: source/core/scope_resolve.cmake

function(scope_resolve key)
  map_has("${local}" "${key}")
  ans(has_local)
  if(has_local)
    map_tryget("${local}" "${key}")
    return_ans()
  endif()

  obj_get("${this}" "${key}")
  return_ans()
endfunction()   

# File: source/core/sleep.cmake

# sleeps for the specified amount of seconds
function(sleep seconds)
  if("${CMAKE_MAJOR_VERSION}" LESS 3)
    if(UNIX)
      execute_process(COMMAND sleep ${seconds} RESULT_VARIABLE res)

      if(NOT "${res}" EQUAL 0)
        message(FATAL_ERROR "sleep failed")
      endif()
      creturn()
    endif()

    message(WARNING "sleep no available in cmake version ${CMAKE_VERSION}")
    creturn()
  endif()

  cmake_lean(-E sleep "${seconds}")
  creturn()
endfunction()

# File: source/core/spinner.cmake


  function(spinner)
    map_set(__spinner counter 0)
    function(spinner)
      set(spinner "|" "/" "-")
      list(APPEND spinner "\\")
      map_tryget(__spinner counter)
      ans(counter)
      math(EXPR next "(${counter} + 1) % 4")
      map_set(__spinner counter ${next})
      list(GET spinner ${counter} res )
      return_ref(res)
    endfunction()
  endfunction()

# File: source/core/status_line.cmake

function(status_line)
  map_set(global status "${ARGN}")
  string_pad("${ARGN}" 100)
  ans(str)  
  echo_append("\r${str}\r")
endfunction()  

# File: source/core/status_line_clear.cmake

function(status_line_clear)

  string_repeat(" " 100)
  ans(whitespace)

  eval("

    function(status_line_clear)
      map_tryget(global status)
      ans(status)
      if(\"\${status}_\" STREQUAL \"_\")
        creturn()
      endif()

      echo_append(\"\r${whitespace}\r\")
    endfunction()
  ")
  status_line_clear()
endfunction()



# File: source/core/status_line_restore.cmake

function(status_line_restore)
  map_tryget(global status)
  ans(status)
  if("${status}_" STREQUAL "_")
    creturn()
  endif()
  echo_append("${status}")
endfunction()

# File: source/core/string_parse.cmake

 function(expr_string_parse str)
  set(regex_single_quote_string "'[^']*'")
  set(regex_double_quote_string "\"[^\"]*\"")
  if("${str}" MATCHES "^${regex_single_quote_string}$")
    string_slice("${str}" 1 -2)
    return_ans()
  endif()
  if("${str}" MATCHES "^(${regex_double_quote_string})$")
    string_slice("${str}" 1 -2)
    return_ans()
  endif()
  creturn()
endfunction()

# File: source/core/string_progress.cmake

## this function creates a string containing status information
  function(progress_string value maximum ticks)
    math(EXPR multiplier "20/${maximum}")
    math(EXPR value "${value} * ${multiplier}")
    math(EXPR maximum "${maximum} * ${multiplier}")
    math(EXPR rest_count "${maximum} - ${value}")
    string_repeat("=" ${value})
    ans(status)
    string_repeat(" " ${rest_count})
    ans(rest)
    math(EXPR status_ticker "${ticks} % 5")
    string_repeat("." ${status_ticker})
    ans(status_ticker)
    creturn("[${status}${rest}]${status_ticker}          ")
  endfunction()

# File: source/core/target_get_properties.cmake

# returns a map of all set target properties for target
# if target does not exist it returns null
function(target_get_properties target)

  if(NOT TARGET "${target}")
    creturn()
  endif()
  set(props
    DEBUG_OUTPUT_NAME
    DEBUG_POSTFIX
    RELEASE_OUTPUT_NAME
    RELEASE_POSTFIX
    ARCHIVE_OUTPUT_DIRECTORY
    ARCHIVE_OUTPUT_DIRECTORY_<CONFIG>
    ARCHIVE_OUTPUT_NAME
    ARCHIVE_OUTPUT_NAME_<CONFIG>
    AUTOMOC
    AUTOMOC_MOC_OPTIONS
    BUILD_WITH_INSTALL_RPATH
    BUNDLE
    BUNDLE_EXTENSION
    COMPILE_DEFINITIONS
    COMPILE_DEFINITIONS_<CONFIG>
    COMPILE_FLAGS
    DEBUG_POSTFIX
    RELEASE_POSTFIX
    DEFINE_SYMBOL
    ENABLE_EXPORTS
    EXCLUDE_FROM_ALL
    EchoString
    FOLDER
    FRAMEWORK
    Fortran_FORMAT
    Fortran_MODULE_DIRECTORY
    GENERATOR_FILE_NAME
    GNUtoMS
    HAS_CXX
    IMPLICIT_DEPENDS_INCLUDE_TRANSFORM
    IMPORTED
    IMPORTED_CONFIGURATIONS
    IMPORTED_IMPLIB
    IMPORTED_IMPLIB_<CONFIG>
    IMPORTED_LINK_DEPENDENT_LIBRARIES
    IMPORTED_LINK_DEPENDENT_LIBRARIES_<CONFIG>
    IMPORTED_LINK_INTERFACE_LANGUAGES
    IMPORTED_LINK_INTERFACE_LANGUAGES_<CONFIG>
    IMPORTED_LINK_INTERFACE_LIBRARIES
    IMPORTED_LINK_INTERFACE_LIBRARIES_<CONFIG>
    IMPORTED_LINK_INTERFACE_MULTIPLICITY
    IMPORTED_LINK_INTERFACE_MULTIPLICITY_<CONFIG>
    IMPORTED_LOCATION
    IMPORTED_LOCATION_<CONFIG>
    IMPORTED_NO_SONAME
    IMPORTED_NO_SONAME_<CONFIG>
    IMPORTED_SONAME
    IMPORTED_SONAME_<CONFIG>
    IMPORT_PREFIX
    IMPORT_SUFFIX
    INCLUDE_DIRECTORIES
    INTERFACE_INCLUDE_DIRECTORIES
    INTERFACE_SYSTEM_INCLUDE_DIRECTORIES
    INSTALL_NAME_DIR
    INSTALL_RPATH
    INSTALL_RPATH_USE_LINK_PATH
    INTERPROCEDURAL_OPTIMIZATION
    INTERPROCEDURAL_OPTIMIZATION_<CONFIG>
    LABELS
    LIBRARY_OUTPUT_DIRECTORY
    LIBRARY_OUTPUT_DIRECTORY_<CONFIG>
    LIBRARY_OUTPUT_NAME
    LIBRARY_OUTPUT_NAME_<CONFIG>
    LINKER_LANGUAGE
    LINK_DEPENDS
    LINK_FLAGS
    LINK_FLAGS_<CONFIG>
    LINK_INTERFACE_LIBRARIES
    LINK_INTERFACE_LIBRARIES_<CONFIG>
    LINK_INTERFACE_MULTIPLICITY
    LINK_INTERFACE_MULTIPLICITY_<CONFIG>
    LINK_SEARCH_END_STATIC
    LINK_SEARCH_START_STATIC
    #LOCATION
    #LOCATION_<CONFIG>
    MACOSX_BUNDLE
    MACOSX_BUNDLE_INFO_PLIST
    MACOSX_FRAMEWORK_INFO_PLIST
    MAP_IMPORTED_CONFIG_<CONFIG>
    OSX_ARCHITECTURES
    OSX_ARCHITECTURES_<CONFIG>
    OUTPUT_NAME
    OUTPUT_NAME_<CONFIG>
    POST_INSTALL_SCRIPT
    PREFIX
    PRE_INSTALL_SCRIPT
    PRIVATE_HEADER
    PROJECT_LABEL
    PUBLIC_HEADER
    RESOURCE
    RULE_LAUNCH_COMPILE
    RULE_LAUNCH_CUSTOM
    RULE_LAUNCH_LINK
    RUNTIME_OUTPUT_DIRECTORY
    RUNTIME_OUTPUT_DIRECTORY_<CONFIG>
    RUNTIME_OUTPUT_NAME
    RUNTIME_OUTPUT_NAME_<CONFIG>
    SKIP_BUILD_RPATH
    SOURCES
    SOVERSION
    STATIC_LIBRARY_FLAGS
    STATIC_LIBRARY_FLAGS_<CONFIG>
    SUFFIX
    TYPE
    VERSION
    VS_DOTNET_REFERENCES
    VS_GLOBAL_WHATEVER
    VS_GLOBAL_KEYWORD
    VS_GLOBAL_PROJECT_TYPES
    VS_KEYWORD
    VS_SCC_AUXPATH
    VS_SCC_LOCALPATH
    VS_SCC_PROJECTNAME
    VS_SCC_PROVIDER
    VS_WINRT_EXTENSIONS
    VS_WINRT_REFERENCES
    WIN32_EXECUTABLE
    XCODE_ATTRIBUTE_WHATEVER
    IS_TEST_EXECUTABLE
  )
  map()
  kv(name ${target})
  kv(project_name ${PROJECT_NAME})


  foreach(property ${props})
    if("${property}" MATCHES "<CONFIG>")
        foreach(config ${CMAKE_CONFIGURATION_TYPES})
            string(TOUPPER "${config}" config)
            string(REPLACE "<CONFIG>" "${config}" configProp "${property}" )
            get_property(isset TARGET ${target} PROPERTY ${configProp} SET)
            if(isset)
                get_property(value TARGET ${target} PROPERTY ${configProp})
                key("${configProp}")
                val("${value}")    
            endif()
        endforeach()
    else()
        get_property(isset TARGET ${target} PROPERTY ${property} SET)
        if(isset)
            get_property(value TARGET ${target} PROPERTY ${property})
            key("${property}")
            val("${value}")    
        endif()    
    endif()





    
  endforeach()
  end()
  
  ans(res)
  return_ref(res)
endfunction()

# File: source/core/ternary.cmake

## usefull to do ternary operatorion in expr syntax
function(ternary predicate trueResult falseResult)
    eval_predicate("${predicate}")        
    ans(res)
    if(res)
        return_ref(trueResult)
    else()
        return_ref(falseResult)
    endif()
endfunction()

# File: source/core/tick.cmake

function(tick)

  if(___ticking)
    return()
  endif()
  set(___ticking true)
  map_set(globaltick n 0)
  function(tick)
  if(___ticking)
    return()
  endif()
  set(___ticking true)
  map_set(globaltick val true)
  map_tryget(globaltick n)
  ans(n)
  math(EXPR n "${n} + 1")
  math(EXPR res "${n} % 600")
  math(EXPR donottick "${n} % 10")
  if(donottick STREQUAL 0)
    echo_append(".")
  endif()

  if("${res}" STREQUAL 0)
    _message("")
    set(n 0)
  endif()
  map_set(globaltick n "${n}")


  endfunction()
  tick()
endfunction()

# File: source/core/tock.cmake


function(tock)
  map_tryget(globaltick val)
  ans(res)
  if(res)
    _message("")
    map_set(globaltick val false)
  endif()
endfunction()

# File: source/core/topsort.cmake

# executes the topological sort for a list of nodes (passed as varargs)
# get_hash is a function to be provided which returns the unique id for a node
# this is used to check if a node was visited previously
# expand should take a node and return its successors
# this function will return nothing if there was a cycle or if no input was given
# else it will return the topological order of the graph
function(topsort get_hash expand)
  function_import("${get_hash}" as __topsort_get_hash REDEFINE)
  function_import("${expand}" as __topsort_expand REDEFINE)
  # visitor function
  function(topsort_visit result visited node)
    # get hash for current node
    __topsort_get_hash("${node}")
    ans(hash)

    map_tryget("${visited}" "${hash}")
    ans(mark)
    
    if("${mark}" STREQUAL "temp")
      #cycle found
      creturn(true)
    endif()
    if(NOT mark)
      map_set("${visited}" "${hash}" temp)
      __topsort_expand("${node}")
      ans(successors)
      # visit successors
      foreach(successor ${successors})
        topsort_visit("${result}" "${visited}" "${successor}")
        ans(cycle)
        if(cycle)
      #    message("cycle found")
          creturn(true)
        endif()
      endforeach()

      #mark permanently
      map_set("${visited}" "${hash}" permanent)

      # add to front of result
      address_push_front("${result}" "${node}")
    endif()
    creturn(false)
  endfunction()


  map_new()
  ans(visited)
  address_new()
  ans(result)

  # select unmarked node and visit
  foreach(node ${ARGN})
    # get hash for node
    __topsort_get_hash("${node}")
    ans(hash)
    
    # get marking      
    map_tryget("${visited}" "${hash}")
    ans(mark)
    if(NOT mark)
      topsort_visit("${result}" "${visited}" "${node}")
      ans(cycle)
      if(cycle)
       # message("stopping with cycle")
        creturn()
      endif()
    endif()

  endforeach()
#  message("done")
  address_get(${result})

  return_ans()
endfunction()

# File: source/core/value_descriptor_parse.cmake

# creates a value descriptor
# available options are
# REQUIRED
# available Single Value args
# DISPLAY_NAME
# DESCRIPTION
# MIN
# MAX
# Multi value args
# LABELS
# DEFAULT 

function(value_descriptor_parse id)
  set(ismap)
  set(descriptor)
  if(${ARGC} EQUAL 1)
    set(args ${ARGN})
    # it might be a map
    list_peek_front(args)
    ans(first)
    is_map("${first}" )
    ans(ismap)

    if(ismap)
      message(ismap)
      set(descriptor ${ARGV1})
    endif()
  endif()

  if(NOT descriptor)
    map_new()
    ans(descriptor)
  endif()
  
  # set default values
  map_navigate_set_if_missing("descriptor.labels" "${id}")
  map_navigate_set_if_missing("descriptor.displayName" "${id}")
  map_navigate_set_if_missing("descriptor.min" "0")
  map_navigate_set_if_missing("descriptor.max" "1")
  map_navigate_set_if_missing("descriptor.id" "${id}")
  map_navigate_set_if_missing("descriptor.description" "")
  map_navigate_set_if_missing("descriptor.default" "")
  if(ismap)
    creturn(${descriptor})
  endif()

  cmake_parse_arguments("" "REQUIRED" "DISPLAY_NAME;DESCRIPTION;MIN;MAX" "LABELS;DEFAULT" ${ARGN})

  if(_DISPLAY_NAME)
    map_navigate_set(descriptor.displayName "${_DISPLAY_NAME}")
  endif()

  if(_DESCRIPTION)
    map_navigate_set(descriptor.description "${_DESCRIPTION}")
  endif()
  #message("_MIN ${_MIN}")
  if("_${_MIN}" MATCHES "^_[0-9]+$")
    map_navigate_set(descriptor.min "${_MIN}")
  endif()


#  message("_MAX ${_MAX}")
  if("_${_MAX}" MATCHES "^_[0-9]+|\\*$")        
    map_navigate_set(descriptor.max "${_MAX}")
  endif()

  if(_LABELS)
    map_navigate_set(descriptor.labels "${_LABELS}")
  endif()

  if(_DEFAULT)
    map_navigate_set(descriptor.default "${_DEFAULT}")
  endif()

  creturn(${descriptor})

endfunction()

# File: source/core/vars_elevate.cmake


# pushes the specified vars to the parent scope
macro(vars_elevate)
  set(args ${ARGN})
  foreach(arg ${args})
    set("${arg}" ${${arg}} PARENT_SCOPE)
  endforeach()
endmacro()


# File: source/core/yield.cmake

#adds a values to parent_scopes __ans
function(yield)
    set(__yield_tmp ${__yield_tmp} ${ARGN} PARENT_SCOPE)

endfunction()

# File: source/core/yield_begin.cmake


function(yield_begin)
  set(__yield_tmp PARENT_SCOPE)
endfunction()

# File: source/core/yield_return.cmake


macro(yield_return)
    creturn(${__yield_tmp})
endmacro()

# File: source/cpp/cpp_class_generate.cmake


  function(cpp_class_generate class_def)
    data("${class_def}")
    ans(class_def)

    map_tryget(${class_def} namespace)
    ans(namespace)


    map_tryget(${class_def} type_name)
    ans(type_name)

    indent_level_push(0)

    set(source)

    string(REPLACE "::" ";" namespace_list "${namespace}")

    foreach(namespace ${namespace_list})
      string_append_line_indented(source "namespace ${namespace}{")
      indent_level_push(+1)
    endforeach()


    string_append_line_indented(source "class ${type_name}{")
    indent_level_push(+1)


    indent_level_pop()
    string_append_line_indented(source "};")


    foreach(namespace ${namespace_list})
      indent_level_pop()
      string_append_line_indented(source "}")
    endforeach()



    indent_level_pop()
    # namespace
    # struct/class
    # inheritance
    # fields
    # methods
    return_ref(source)

  endfunction()


# File: source/cpp/cpp_class_header_generate.cmake

## generates a header file from a class definition
  function(cpp_class_header_generate class_def)
    data("${class_def}")
    ans(class_def)
  

    indent_level_push(0)
    set(source)
    string_append_line_indented(source "#pragma once")
    string_append_line_indented(source "")

    cpp_class_generate("${class_def}")
    ans(class_source)
    set(source "${source}${class_source}")


    string_append_line_indented(source "")

    indent_level_pop()
    return_ref(source)
  endfunction()


# File: source/datetime/datetime.cmake



# queries the system for the current datetime
# returns a map containing all elements of the current date
# {yyyy: <>, MM:<>, dd:<>, hh:<>, mm:<>, ss:<>, ms:<>}

function(datetime)
  fwrite_temp("")
  ans(file)
  file_timestamp("${file}")
  ans(timestamp)
  rm("${file}")


  string(REGEX REPLACE "([0-9][0-9][0-9][0-9])\\-([0-9][0-9])\\-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9])"
   "\\1;\\2;\\3;\\4;\\5;\\6" 
   timestamp 
   "${timestamp}")
  
  list_extract(timestamp yyyy MM dd hh mm ss)
  set(ms 0)

  map_new()
  ans(dt)
  map_capture(${dt} yyyy MM dd hh mm ss ms)
  return_ref(dt)





  # old implementation
  shell_get()
  ans(shell)
  map_new()
  ans(dt)
  if("${shell}" STREQUAL cmd)
    shell_env_get("time")
    ans(time)
    shell_env_get("date")
    ans(date)
    
    string(REGEX REPLACE "([0-9][0-9])\\.([0-9][0-9])\\.([0-9][0-9][0-9][0-9]).*" "\\1;\\2;\\3" date "${date}")
    list_extract(date dd MM yyyy)
    

    string(REGEX REPLACE "([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9]).*" "\\1;\\2;\\3;\\4" time "${time}")
    list_extract(time hh mm ss ms)

    map_capture(${dt} yyyy MM dd hh mm ss ms)

    creturn("${dt}")
  else()

    message(WARNING "cmakepp's datetime is not implemented  for your system")
    set(yyyy)
    set(MM)
    set(dd)
    set(hh)
    set(mm)
    set(ss)
    set(ms)
    
    map_capture(${dt} yyyy MM dd hh mm ss ms)

    creturn("${dt}")

  endif()
endfunction()

# File: source/datetime/millis.cmake

## returns the number of milliseconds since epoch
function(millis)

  compile_tool(millis "
    #include <iostream>
    #include <chrono>
    int main(int argc, const char ** argv){
     //std::cout << \"message(whatup)\"<<std::endl;
     //std::cout << \"obj(\\\"{id:'1'}\\\")\" <<std::endl;
     auto now = std::chrono::system_clock::now();
     auto duration = now.time_since_epoch();
     auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
     std::cout<< \"set_ans(\" << millis << \")\";
     return 0;
    }"
    )
  millis(${ARGN})
  return_ans()
endfunction()



# File: source/debugging/breakpoint.cmake

# creates a breakpoint 
# usage: breakpoint(${CMAKE_CURRENT_LIST_FILE} ${CMAKE_CURRENT_LIST_LINE})
function(breakpoint file line) 
  if(NOT DEBUG_CMAKE)
    creturn()
  endif()
  message("breakpoint reached ${file}:${line}")
  while(1)
    echo_append("> ")
    read_line()
    ans(cmd)
    if("${cmd}" STREQUAL "")
      message("continuing execution")
      break()
    endif()

    
    if("${cmd}" MATCHES "^\\$.*")
      string(SUBSTRING "${cmd}" 1 -1 var)
      

      get_cmake_property(_variableNames VARIABLES)
      foreach(v ${_variableNames})
        if("${v}" MATCHES "${cmd}")
          dbg("${v}")

        endif()
      endforeach()

    endif()
    



  endwhile()
endfunction()


# File: source/debugging/performance_sample.cmake

function(performance_init)
  map_new()
  ans(perfmap)
  map_set(global __performance ${perfmap})

  function(performance_init)
      
  endfunction()

endfunction()

function(performance_sample file line)
  
  map_get(global __performance)

endfunction()

function(performance_report)

endfunction()

# File: source/debugging/print_call_counts.cmake


function(print_call_counts)
	get_property(props GLOBAL PROPERTY "function_calls")
	set(countfunc "(current) return_truth(\${current} STREQUAL \${it})")
	foreach(prop ${props})
		get_property(call_count GLOBAL PROPERTY "call_count_${prop}")
		get_property(callers GLOBAL PROPERTY "call_count_${prop}_caller")


		message("${prop}: ${call_count}")
	endforeach()
endfunction()

# File: source/debugging/print_commands.cmake

function(print_commands)

get_cmake_property(_variableNames COMMANDS)
foreach (_variableName ${_variableNames})
    message(STATUS "${_variableName}")
endforeach()

endfunction()

# File: source/debugging/print_function.cmake


function(print_function func)
	function_lines_get( "${func}")
  ans(lines)
	set(i "0")
	foreach(line ${lines})		
		message(STATUS "LINE ${i}: ${line}")
		math(EXPR i "${i} + 1")
	endforeach()
endfunction()

# File: source/debugging/print_locals.cmake

macro(print_locals)

  get_cmake_property(_variableNames VARIABLES)
  foreach (_variableName ${_variableNames})
      message(STATUS "${_variableName}=${${_variableName}}")
  endforeach()

endmacro()

# File: source/debugging/print_macros.cmake

function(print_macros)
get_cmake_property(_variableNames MACROS)
foreach (_variableName ${_variableNames})
    message(STATUS "${_variableName}")
endforeach()
endfunction()

# File: source/debugging/print_multi.cmake


 function(print_multi n)


  set(headers index ${ARGN})
  set(header_lengths )
  foreach(header ${headers})
    string(LENGTH "${header}" header_len)
    math(EXPR header_len "${header_len} + 1")
    list(APPEND header_lengths ${header_len})
  endforeach()

  string(REPLACE ";" " " headers "${headers}")
  message("${headers}")

  if(${n} LESS 0)
    creturn()
  endif()

  foreach(i RANGE 0 ${n})
    set(current_lengths ${header_lengths})
    list_pop_front(current_lengths )
    ans(current_length)
    echo_append_padded("${current_length}" "${i}")
    foreach(arg ${ARGN})

      list_pop_front(current_lengths )
      ans(current_length)
      is_map("${${arg}}")
      ans(ismap)
      if(ismap)
        map_tryget(${${arg}} ${i})
        ans(val)
      else()
        list(GET ${arg} ${i} val)
      endif()

      echo_append_padded("${current_length}" "${val}")
    endforeach()  
    message(" ")
  endforeach()
 endfunction()

# File: source/debugging/print_result.cmake


#prints result
function(print_result result)
  list(LENGTH argc "${result}" )
  if("${argc}" LESS 2)
    message("${result}")
  else()
    foreach(arg ${result})
      message("${arg}")
    endforeach()
  endif()
endfunction()


# File: source/debugging/print_var.cmake


# prints the variables name and value as a STATUS message
macro(print_var varname)
  message(STATUS "${varname}: ${${varname}}")
endmacro()


# File: source/debugging/print_vars.cmake

## prints the specified variables names and their values in a single line
## e.g.
## set(varA 1)
## set(varB abc)
## print_vars(varA varB)
## output:
##  varA: '1' varB: 'abc'
function(print_vars)
  set(__print_vars_args "${ARGN}")
  list_extract_flag(__print_vars_args --plain)
  ans(__print_vars_plain)
  set(__str)
  foreach(__print_vars_arg ${__print_vars_args})
    assign(____cur = ${__print_vars_arg})
    if(NOT __print_vars_plain)
      json("${____cur}")
      ans(____cur)
    else()
      set(____cur "'${____cur}'")
    endif()

    string_shorten("${____cur}" "300")
    ans(____cur)
    set(__str "${__str} ${__print_vars_arg}: ${____cur}")

  endforeach()
  message("${__str}")
endfunction()

# File: source/eval_predicate.cmake

##
##
##
function(eval_predicate)
  arguments_encoded_list(0 ${ARGC})
  ans(__eval_predicate_arguments)

  ## slower version that works
    encoded_list_to_cmake_string(${__eval_predicate_arguments})
    ans(__eval_predicate_predicate)

    set(__eval_predicate_code "
      if(${__eval_predicate_predicate})
        set(__ans true)
      else()
        set(__ans false)
      endif()
    ")
    eval("${__eval_predicate_code}")
    

    set(__ans "${__ans}" PARENT_SCOPE)
return()


  ##womething is wrong here
  is_encoded_list(${__eval_predicate_arguments})
  ans(__eval_predicate_is_encoded_list)
  if(NOT __eval_predicate_is_encoded_list)
    __eval_predicate_helper("${__eval_predicate_arguments}")
    ans(__eval_predicate_arguments)

    if(${__eval_predicate_arguments})
      set(__ans true PARENT_SCOPE)
    else()
      set(__ans false PARENT_SCOPE)
    endif()
  else()
    encoded_list_to_cmake_string(${__eval_predicate_arguments})
    ans(__eval_predicate_predicate)

    set(__eval_predicate_code "
      if(${__eval_predicate_predicate})
        set(__ans true)
      else()
        set(__ans false)
      endif()
    ")
    eval("${__eval_predicate_code}")
    set(__ans ${__ans} PARENT_SCOPE)
  endif()
  _message("${__eval_predicate_arguments} (${__eval_predicate_is_encoded_list}): ${__ans}")
endfunction()



macro(__eval_predicate_helper)
  set(__ans "${ARGN}")
endmacro()

# File: source/eval_predicate_cmake.cmake


function(eval_predicate_cmake code)
  address_new()
  ans(__temp_address)
  eval("if(${code})\naddress_set(${__temp_address} true)\nelse()\naddress_set(${__temp_address} false)\nendif()")
  #message("if(${code})\naddress_set(${__temp_address} true)\nelse()\naddress_set(${__temp_address} false)\nendif()")
  address_get(${__temp_address})
  return_ans()
endfunction()

# File: source/events/event.cmake

## `(<event-id>):<event>`
##
## tries to get the `<event>` identified by `<event-id>`
## if it does not exist a new `<event>` is created by  @markdown_see_function("event_new(...)")
function(event )
  set(event_id ${ARGN}) 
  set(event)
  if(event_id)
    event_get("${event_id}")
    ans(event)
  endif()
  if(NOT event)
    event_new(${event_id})
    ans(event)
  endif()
  return_ref(event)
endfunction()


# File: source/events/event_addhandler.cmake

## `event_addhandler(<~event> <~callable>)-><event handler>`
##
## adds an event handler to the specified event. returns an `<event handler>`
## which can be used to remove the handler from the event.
##
function(event_addhandler event handler)
  event("${event}")
  ans(event)

  event_handler("${handler}")
  ans(handler)

  ## then only append function 
  map_append_unique("${event}" handlers "${handler}")
 
  creturn(${handler})
endfunction()



# File: source/events/event_cancel.cmake

## `()-><null>`
##
## only usable inside event handlers. cancels the current event and returns
## after this handler.
function(event_cancel)
  address_set(${__current_event_cancel} true)
  creturn()
endfunction()

# File: source/events/event_clear.cmake

## `(<~event>)-><void>`
##
## removes all handlers from the specified event
function(event_clear event)
  event_get("${event}")
  ans(event)

  event_handlers("${event}")
  ans(handlers)

  foreach(handler ${handlers})
    event_removehandler("${event}" "${handler}")
  endforeach()  

  creturn()
endfunction()



# File: source/events/event_emit.cmake

## `(<~event> <args:<any...>>)-><any...>`
##
## emits the specified event. goes throug all event handlers registered to
## this event and 
## if event handlers are added during an event they will be called as well
##
## if a event calls event_cancel() 
## all further event handlers are disregarded
##
## returns the accumulated result of the single event handlers
function(event_emit event)
  is_event("${event}")
  ans(is_event)
  
  if(NOT is_event)
    event_get("${event}")
    ans(event)
  endif()


  if(NOT event)
    creturn()
  endif()


  set(result)

  set(previous_handlers)
  # loop aslong as new event handlers are appearing
  # 
  address_new()
  ans(__current_event_cancel)
  address_set(${__current_event_cancel} false)
  while(true)
    ## 
    map_tryget(${event} handlers)
    ans(handlers)
    list_remove(handlers ${previous_handlers} "")
    list(APPEND previous_handlers ${handlers})

    list_length(handlers)
    ans(length)
    if(NOT "${length}" GREATER 0) 
      break()
    endif()

    foreach(handler ${handlers})

      event_handler_call(${event} ${handler} ${ARGN})
      ans(success)
      list(APPEND result "${success}")
      ## check if cancel is requested
      address_get(${__current_event_cancel})
      ans(break)
      if(break)
        return_ref(result)
      endif()
    endforeach()
  endwhile()

  return_ref(result)
endfunction() 


# File: source/events/event_get.cmake

## `(<~event>)-><event>`
##  
## returns the `<event>` identified by `<event-id>` 
## if the event does not exist `<null>` is returned.
function(event_get event)
  events()
  ans(events)

  is_event("${event}")
  ans(is_event)

  if(is_event)
    return_ref(event)
  endif()
  
  map_tryget(${events} "${event}")
  return_ans()
endfunction()


# File: source/events/event_handler.cmake

## `(<~callable>)-><event handler>` 
##
## creates an <event handler> from the specified callable
## and returns it. a `event_handler` is also a callable
function(event_handler callable)
  callable("${callable}")
  ans(event_handler)
  return_ref(event_handler)
endfunction()


# File: source/events/event_handler_call.cmake

## `(<event> <event handler>)-><any>`
##
## calls the specified event handler for the specified event.
function(event_handler_call event event_handler)
  callable_call("${event_handler}" ${ARGN})
  ans(res)
  return_ref(res)
endfunction()


# File: source/events/event_handlers.cmake

## `(<event>)-><event handler...>`
##
## returns all handlers registered for the event
function(event_handlers event)
  event_get("${event}")
  ans(event)

  if(NOT event)
    creturn()
  endif()

  map_tryget(${event} handlers)
  return_ans()

endfunction()

# File: source/events/event_new.cmake

## `(<?event-id>)-><event>`
##
## creates an registers a new event which is identified by
## `<event-id>` if the id is not specified a unique id is generated
## and used.
## 
## returns a new <event> object: 
## {
##   event_id:<event-id>
##   handlers: <callable...> 
##   ... (psibbly cancellable, aggregations)
## }
## also defines a global function called `<event-id>` which can be used to emit the event
##
function(event_new)
  set(event_id ${ARGN})
  if(NOT event_id)
    identifier(event)
    ans(event_id)
  endif()

  if(COMMAND ${event_id})
    message(FATAL_ERROR "specified event already exists")
  endif()

  ## curry the event emit function and create a callable from the event
  curry3(${event_id}() => event_emit("${event_id}" /*))
  ans(event)

  callable("${event}")
  ans(event)  


  curry3(() => event_addhandler("${event_id}" /*))
  ans(add_handler)

  curry3(() => event_removehandler("${event_id}" /*))
  ans(remove_handler)

  curry3(() => event_clear("${event_id}" /*))
  ans(clear)



  ## set event's properties
  map_set(${event} event_id "${event_id}")
  map_set(${event} handlers)
  map_set(${event} add ${add_handler})
  map_set(${event} remove ${remove_handler})
  map_set(${event} clear ${clear})

  ## register event globally
  events()
  ans(events)
  map_set(${events} "${event_id}" ${event})

  creturn(${event})
endfunction()

## faster version (does not use curry but a custom implementation)
function(event_new)
  set(event_id ${ARGN})
  if(NOT event_id)
    identifier(event)
    ans(event_id)
  endif()

  if(COMMAND ${event_id})
    message(FATAL_ERROR "specified event already exists")
  endif()

  ## curry the event emit function and create a callable from the event

  function_new()
  ans(add_handler)
  function_new()
  ans(remove_handler)
  function_new()
  ans(clear)
  eval("
    function(${event_id})
      event_emit(\"${event_id}\" \${ARGN})
      return_ans()
    endfunction()
    function(${add_handler})
      event_addhandler(\"${event_id}\" \${ARGN})
      return_ans()
    endfunction()
    function(${remove_handler})
      event_removehandler(\"${event_id}\" \${ARGN})
      return_ans()
    endfunction()
    function(${clear})
      event_clear(\"${event_id}\" \${ARGN})
      return_ans()
    endfunction()

  ")

  callable("${event_id}")
  ans(event)  

  ## set event's properties
  map_set(${event} event_id "${event_id}")
  map_set(${event} handlers)
  map_set(${event} add ${add_handler})
  map_set(${event} remove ${remove_handler})
  map_set(${event} clear ${clear})

  ## register event globally
  events()
  ans(events)
  map_set(${events} "${event_id}" ${event})

  creturn(${event})
endfunction()





# File: source/events/event_removehandler.cmake

## `(<event handler>)-><bool>`
##
## removes the specified handler from the event idenfied by event_id
## returns true if the handler was removed
function(event_removehandler event handler)

  event("${event}")
  ans(event)
  
  if(NOT event)
    creturn(false)
  endif()


  event_handler("${handler}")
  ans(handler)


  map_remove_item("${event}" handlers "${handler}")
  ans(success)
  
  return_truth("${success}")
  
endfunction()



# File: source/events/events.cmake

## `()-> <event>`
##
## returns the global events map it contains all registered events.
function(events)

  function(events)
    map_get(global events)
    ans(events)
    return_ref(events)
  endfunction()

  map_new()
  ans(events)
  map_set(global events ${events})
  events(${ARGN})
  return_ans()
endfunction()


# File: source/events/events_track.cmake

## `(<event-id...>)-><event tracker>`
##
## sets up a function which listens only to the specified events
## 
function(events_track)
  function_new()
  ans(function_name)

  map_new()
  ans(map)

  eval("
    function(${function_name})
      map_new()
      ans(event_args)
      map_tryget(\${event} event_id)
      ans(event_id)
      map_set(\${event_args} id \${event_id})
      map_set(\${event_args} args \${ARGN})
      map_set(\${event_args} event \${event})
      map_append(${map} \${event_id} \${event_args})
      map_append(${map} event_ids \${event_id})
      creturn(\${event_args})
    endfunction()
  ")

  foreach(event ${ARGN})
    event_addhandler(${event} ${function_name})
  endforeach()

  creturn(${map})
endfunction()

# File: source/events/is_event.cmake

## `(<any>)-><bool>`
##
## returns true if the specified value is an event
## an event is a ref which is callable and has an event_id
##
function(is_event event)
  is_address("${event}")
  ans(is_ref)
  if(NOT is_ref)
    creturn()
  endif()
  is_callable("${event}")
  ans(is_callable)
  if(NOT is_callable)
    creturn(false)
  endif()

  map_has(${event} event_id)
  ans(has_event_id)
  if(NOT has_event_id)
    creturn(false)
  endif()

  creturn(true)
endfunction()

# File: source/expr/arguments_expression.cmake

## `(<begin index> <end index> <parameter definition>...)-><any>...`
##
##
## parses the arguments of the calling function cmakepp expressions
## expects `begin index` to be the index of first function parameters (commonly 0)
## and `end index` to be the index of the last function parameter to parse (commonly ${ARGC})
## var args are named arguments which will be set to be available in the function scope
##
## named arguments passed to function have a higher precedence than positional arguments 
##
## __sideffects__:
## * `arguments_expression_result` is a address of an object containing all parsed data
## * scope operations may modify the parent scope of the function
## 
##
macro(arguments_expression begin end)
  ## eval arguments expression
  ## see interpret_cmake_function_parameters 
  set(_argn_ ${ARGV})
  arguments_expression_eval_cached(
   interpret_cmake_function_parameters
   "" 
   "_argn_" 
   ${begin} 
   ${end}
  )
  ans(arguments_expression_result)

  ## set all positional values
  address_get(${arguments_expression_result})
  ans(__positionals)
  foreach(arg ${ARGN})
    map_has("${arguments_expression_result}" "${arg}")
    ans(has_named_value)
    if(has_named_value)
      map_tryget("${arguments_expression_result}" "${arg}")
      ans(${arg})
    else()
      list_pop_front(__positionals)
      encoded_list_decode("${__ans}")
      ans(${arg})  
    endif()

    
  endforeach()
  ## return the rest of the positional values which were not assign
  set(__ans ${__positionals})

endmacro()

# File: source/expr/arguments_expression_compile_cached.cmake


macro(arguments_expression_compile_cached type arguments argn start end)
    arguments_expression_parse_cached("${type}" "${arguments}" "${argn}" "${start}" "${end}")
    ans(ast)
    if (ast)
        map_tryget("${ast}" macro)
        ans(macro)
        if (NOT macro)
            ast_reduce_code("${ast}")
            ans(code)
            map_tryget("${ast}" value)
            ans(value)

            identifier(expr2)
            ans(identifier)

            set(macro "
                macro(${identifier})
                    ${code}
                    set(__ans ${value} PARENT_SCOPE)
                    set(__ans ${value})
                endmacro()
            ")
            eval("${macro}")
            map_set("${ast}" macro "${macro}")
            map_set("${ast}" macro_identifier "${identifier}")
        endif ()
        set(__ans "${ast}")
    endif ()
endmacro()


# File: source/expr/arguments_expression_eval_cached.cmake

## 
##
## sets __ans in parent scope
macro(arguments_expression_eval_cached type arguments argn start end)
    arguments_expression_compile_cached("${type}" "${arguments}" "${argn}" "${start}" "${end}")
    if (__ans)
        map_tryget("${__ans}" macro_identifier)
        set(__ans "${__ans}()")
        set(__code__code "${__ans}")
        eval_ref(__code__code)
    endif ()
endmacro()


# File: source/expr/arguments_expression_parse.cmake


macro(arguments_expression_parse type arguments start end)
    arguments_create_tokens("${start}" "${end}")
    ans(tokens)
    map_new()
    ans(context)
    map_set(${context} current_id 0)
    ## stupid variable expansion
    set(____code ${arguments})
    set(____code "${type}(\"${tokens}\" ${____code})")
    eval("${____code}")
endmacro()


# File: source/expr/arguments_expression_parse_cached.cmake


macro(arguments_expression_parse_cached type arguments argn start end)
    string(MD5 __cache_key "${ARGN}${arguments}${type}${${argn}}${start}${end}")
    map_tryget(cache "${__cache_key}")
    if (NOT __ans)
        arguments_expression_parse("${type}" "${arguments}" "${start}" "${end}")
        map_set(cache "${__cache_key}" "${__ans}")
    endif ()
endmacro()



# File: source/expr/cmakepp_compile_file.cmake

## `(<cmakepp code file>)-><cmake code file>`
##
## compiles the specified source file to enable expressions
## the target file can be specified. by default a temporary file is created
## todo:  cache result
function(cmakepp_compile_file source)
  set(target ${ARGN})

  fread("${source}")
  ans(content)
  cmakepp_expr_compile("${content}")
  ans(content)
  if(NOT target)
    fwrite_temp("${content}" cmakepp)
    ans(target)
  else()
    fwrite("${target}" "${content}")
    ans(target)
  endif()
  return_ref(target)
endfunction()


# File: source/expr/cmakepp_compile_scope_expressions.cmake

## `(<line number>)-><cmake code>`
##
## compiles all expressions in the current scope (file or function()...endfunction())
function(cmakepp_compile_scope_expressions line)
  ## read the current list file (calling file)
  fread("${CMAKE_CURRENT_LIST_FILE}")
  ans(cmake_code)

  ## convert code to tokens
  cmake_token_range("${cmake_code}")
  rethrow()
  ans_extract(begin end)

  ## get the invocation from which called this function
  cmake_invocation_filter_token_range("${begin};${end}" \${line} EQUAL ${line})
  ans(invocation)

  if(NOT invocation)
    throw("could not find invocation at ${CMAKE_CURRENT_LIST_FILE}:${line}")
  endif()

  ## get the first enabled token (after the invocation)
  map_tryget("${invocation}" arguments_end_token)
  ans(first_enabled_token)
  map_tryget("${first_enabled_token}" next)
  ans(first_enabled_token)



  set(current_begin ${first_enabled_token})  
  set(scope_depth 0)
  ## loop through all invocations. and count function/endfunctions
  ## break when end of scope found 
  while(true)
    cmake_invocation_filter_token_range("${current_begin};" \${invocation_identifier} MATCHES "^(endfunction)|(function)$" --take 1)
    ans(invocation)
    if(NOT invocation)
      break()
    endif()
    map_tryget("${invocation}" invocation_identifier)
    ans(invocation_identifier)
    ## extendable:  macro/endmacro while/endwhile (begin/end)
    if("${invocation_identifier}" STREQUAL "function" )
      math(EXPR scope_depth "${scope_depth} + 1")
    elseif("${invocation_identifier}" STREQUAL "endfunction" )
      math(EXPR scope_depth "${scope_depth} - 1")
      if(${scope_depth} LESS 0)
        map_tryget("${invocation}" invocation_token)
        ans(last_enabled_token)
        break()
      endif()
    endif()
    map_tryget("${invocation}" arguments_end_token)
    ans(current_begin)
  endwhile()

  ## get the code in the expression enabled range and compile it
  cmake_token_range_serialize("${first_enabled_token};${last_enabled_token}")
  ans(enabled_code)
  cmakepp_expr_compile("${enabled_code}")
  ans(result)

  ## return the compiled code
  return_ref(result)
endfunction()

# File: source/expr/cmakepp_enable_expressions.cmake

## `(${CMAKE_CURRENT_LIST_LINE})-><any>`
##
## you need to pass `${CMAKE_CURRENT_LIST_LINE}` for this to work
##
## this macro enables all expressions in the current scope
## it will only work in a CMake file scioe or inside a cmake function scope.
## You CANNOT use it in a loop, if statement, macro etc (everything that has a begin/end)
## Every expression inside that scope (and its subscopes) will be evaluated.  
##
## **Implementation Note**:
## This is achieved by parsing the while cmake file (and thus potentially takes very long)
## Afterwards the line which you pass as an argument is used to find the location of this macro
## every argument for every following expression in the current code scope is scanned for
## `$[...]` brackets which are in turn lexed,parsed and compiled (see `expr()`) and injected
## into the code which is in turn included
macro(cmakepp_enable_expressions line)
  cmakepp_compile_scope_expressions("${line}")
  rethrow(true)
  ans(__cmakepp_enable_expressions_code)
  eval_ref(__cmakepp_enable_expressions_code)
  unset(__cmakepp_enable_expressions_code)
  return()
endmacro()




# File: source/expr/cmakepp_eval.cmake

## `(<cmakepp code>)-><any>`
##
## evaluates the specified cmakepp code
function(cmakepp_eval input)
  cmakepp_expr_compile("${input}")
  ans(____code____)
  eval_ref(____code____)
  return_ans()
endfunction()


# File: source/expr/cmakepp_expr_compile.cmake

## `(<cmakepp code>)-><cmake code>`
##
## `<cmakepp code> ::= superset of cmake code with added expression syntax in $[...] `
## 
## compiles the specified cmakepp code to pure cmake code
## replacing `$[...]` with the result of the cmakepp expression syntax (see `expr(...)`)
## e.g.
## ```
## function(my_name)
##  creturn("tobi")
## endfunction()
##  message("hello $[my_name()]::string_to_upper()") # prints `hello TOBI`
## ```
##
function(cmakepp_expr_compile content)
  cmake_token_range(" ${content}")##prepend whitespace (because of replace edgecase)
  ans(range)

  cmake_invocation_filter_token_range("${range}")
  ans(invocations)

  string_codes()
  set(regex "[\\$${bracket_open_code}${bracket_close_code}]|[^\\$${bracket_open_code}${bracket_close_code}]+")

  foreach(invocation ${invocations})
    map_tryget("${invocation}" arguments_begin_token)
    ans(args_begin)
    map_tryget("${invocation}" arguments_end_token)
    ans(args_end)
    map_tryget("${invocation}" invocation_token)
    ans(invocation_token)


    cmake_token_range_filter("${args_begin};${args_end}" NOT type MATCHES "(comment)")
    ans(argument_tokens)


    set(invocation_string)
    foreach(token ${argument_tokens})
      map_tryget("${token}" value)
      ans(value)
      set(invocation_string "${invocation_string}${value}")
    endforeach()
    encoded_list("${invocation_string}")
    ans(invocation_string)



    string(REGEX MATCHALL "${regex}"  tokens "${invocation_string}")
    set(compiled_code)
    set(is_expression 0)
    set(depth 0)
    set(current_arguments)

    while(true)
      set(expression_end false)
      set(expression_begin false)
      list(LENGTH tokens token_count)
      if(NOT token_count)
        break()
      endif()

      list(GET tokens 0 token)
      list(REMOVE_AT tokens 0)

      if("${token}_" STREQUAL "${bracket_open_code}_")
        math(EXPR depth "${depth} + 1")
        
      elseif("${token}_" STREQUAL "${bracket_close_code}_")
        if(${depth} EQUAL ${is_expression})
          set(expression_end true)
          set(is_expression 0)
        endif()
        math(EXPR depth "${depth} - 1")

      elseif("${token}_" STREQUAL "$_" AND NOT is_expression AND ${token_count} GREATER 1)
        list(GET tokens 0 next_token)
        if("${next_token}_" STREQUAL "${bracket_open_code}_")
          list(REMOVE_AT tokens 0)
          math(EXPR depth "${depth} + 1")
          set(is_expression "${depth}")
          set(expression_begin true)
          set(token "$(")
        endif()
      endif()


      if(is_expression AND NOT expression_end AND NOT expression_begin)
        set(current_expression "${current_expression}${token}")
      elseif(NOT expression_end AND NOT expression_begin)
        set(current_arguments "${current_arguments}${token}")
      endif()

      if(expression_begin)
        set(current_expression)
      endif()
      if(expression_end)
         encoded_list_decode("${current_expression}")
         ans(current_code)
         eval("expr_parse(interpret_expression \"\" ${current_code})")
         ans(ast)
         ast_reduce_code("${ast}")
         ans(current_compiled_code)
         map_tryget("${ast}" value)
         ans(value)
         next_id()
         ans(ref)
        
         set(argument_value "\${${ref}}")
         set(compiled_code "${compiled_code}${current_compiled_code}set(${ref} ${value})\n")
         set(current_arguments "${current_arguments}${argument_value}")
      endif()


     endwhile()

       if(compiled_code)
        cmake_token_range_insert("${invocation_token}" "${compiled_code}")
       endif()
       if(current_arguments)
         cmake_token_range_replace("${args_begin};${args_end}" "${current_arguments}")
       endif()

  endforeach()



  cmake_token_range_serialize("${range}")
  ans(result)
  return_ref(result)
endfunction()


# File: source/expr/cmakepp_include.cmake

## `()->`
##
## includes the specified cmakepp file (compiling it)
macro(cmakepp_include path)
  cmakepp_compile_file("${path}")
  include("${__ans}")
endmacro()

# File: source/expr/compiler/ast_compile.cmake



# {
#  pre_code
#  code
#  post_code
#  children
# }

function(ast_reduce_code ast)
    ast_reduce_code_inner("${ast}")
    ans(result)
    map_tryget("${result}" pre_code)
    ans(code)
    map_tryget("${result}" code)
    ans(next)
    set(code "${code}${next}")
    map_tryget("${result}" post_code)
    ans(next)
    set(code "${code}${next}")

  #_message("###\n${code}\n")
    return_ref(code)
endfunction()

function(ast_reduce_code_inner ast)
    map_tryget("${ast}" pure_value)
    ans(is_pure_value)

    ## pure values do not produce any code
    if (is_pure_value)
        creturn()
    endif ()

    set(pre_code)
    set(code)
    set(post_code)

    ## get code for all children
    map_tryget("${ast}" children)
    ans(children)
    foreach (child ${children})
        ast_reduce_code_inner("${child}")
        ans(current_result)

        map_tryget("${current_result}" pre_code)
        ans(current_pre_code)
        set(pre_code "${pre_code}${current_pre_code}")
        map_tryget("${current_result}" code)
        ans(current_code)
        set(code "${code}${current_code}")
        map_tryget("${current_result}" post_code)
        ans(current_post_code)
        set(post_code "${post_code}${current_post_code}")
    endforeach ()

    #print_vars(--plain  pre_code code post_code )

    map_tryget("${ast}" code)
    ans(current_code)

    set(code "${pre_code}${code}${current_code}${post_code}")


    map_tryget("${ast}" pre_code)
    ans(pre_code)
    map_tryget("${ast}" post_code)
    ans(post_code)

    map_new()
    ans(result)
    map_set(${result} pre_code "${pre_code}")
    map_set(${result} code "${code}")
    map_set(${result} post_code "${post_code}")

    return_ref(result)
endfunction()



# File: source/expr/decode.cmake

  function(decode str)
    string(REPLACE "" ";"  str "${str}")
    string(REPLACE ""  "(" str "${str}")
    string(REPLACE ""  ")" str "${str}")
    string(REPLACE ""  "[" str "${str}")
    string(REPLACE ""  "]" str "${str}")
    set(__ans "${str}" PARENT_SCOPE)
  endfunction()

# File: source/expr/expr.cmake

## `(<expression>)-><any>`
##
## parses, compiles and evaluates the specified expression. The compilation result
## is cached (per cmake run)
##
function(expr)
  set(argn "${ARGN}")
  arguments_expression_eval_cached("interpret_expression" "" argn 0 ${ARGC})
  rethrow()
endfunction()

# File: source/expr/expr_eval.cmake

## `(<expression type> <arguments:<any>...> <expression>)-><any> 
##
## evaluets the specified expression using as the type of expression 
## specified.  also passes allong arguments to the parser
function(expr_eval type arguments)
  set(argn "${ARGN}")
  arguments_expression_eval_cached("${type}" "${arguments}" argn 2 ${ARGC})
  
  rethrow()

endfunction()


# File: source/expr/expr_parse.cmake

## `(<expression type> <arguments:<any...>> <expression>)-><expr ast>`
##
##
## parsers and caches the expression. returns the AST for the specified
## expression.  See `ast_new`
function(expr_parse type arguments)
  
  set(argn "${ARGN}")
  arguments_expression_parse_cached("${type}" "${arguments}" "argn" 2 ${ARGC})
  return_ans()
endfunction()



# File: source/expr/expressions/compile_indexation.cmake


## sets ast.ref, ast.value, ast.code
function(compile_indexation ast)
  map_tryget("${ast}" indexation_lhs)
  ans(lhs)

  map_tryget("${ast}" indexation_elements)
  ans(elements)

  map_tryget("${lhs}" value)
  ans(lhs_value)

  map_tryget("${lhs}" expression_type)
  ans(lhs_expression_type)


  next_id()
  ans(ref)

  set(code "set(${ref})\n")



  set(value_type any)

  list(LENGTH elements element_count)
  if("${element_count}" GREATER 1)
    set(value_type list)
  endif()

  foreach(element ${elements})

    map_tryget("${element}" expression_type)
    ans(expression_type)


    map_tryget("${element}" value)
    ans(element_value)

    if("${expression_type}" STREQUAL "range")
      set(value_type list)
      set(code "${code}
value_range_get(\"${lhs_value}\" \"${element_value}\")
list(APPEND ${ref} \${__ans} )
")
    elseif("${lhs_expression_type}" STREQUAL "ellipsis")
      set(code "${code}foreach(local ${lhs_value})
        get_property(__ans GLOBAL PROPERTY \"\${local}.__object__\" SET)
        if(__ans)
          message(FATAL_ERROR object_get_not_supported_currently)
        else()
          get_property(__ans GLOBAL PROPERTY \"\${local}.${element_value}\")
          list(APPEND ${ref} \${__ans})
        endif()
      endforeach()
        ")
    else()

      set(code "${code}get_property(__ans GLOBAL PROPERTY \"${lhs_value}.__object__\" SET)
                if(__ans)
                  message(FATAL_ERROR object_get_not_supported_currently)
                else()
                  get_property(__ans GLOBAL PROPERTY \"${lhs_value}.${element_value}\")
                  list(APPEND ${ref} \${__ans})
                endif()\n")
    endif()

  endforeach()

#  _message("${code}")
  
  map_set("${ast}" ref "${ref}")
  map_set("${ast}" value "\${${ref}}")
  map_set("${ast}" code "${code}")
endfunction()


# File: source/expr/expressions/interpret_assign.cmake

function(interpret_assign tokens)
  set(rhs_tokens)
  set(lhs_tokens ${tokens})
  set(equals_token)

  while(lhs_tokens)
    list_pop_back(lhs_tokens)
    ans(token)
    map_tryget("${token}" type)
    ans(token_type)
    if("${token_type}" STREQUAL "equals")
      set(equals_token "${token}")
      break()
    endif()
    list(APPEND rhs_tokens ${token})
  endwhile()

  if(NOT equals_token)
    throw("missing equals token" --function interpret_assign)
  endif()

  if(NOT lhs_tokens)
    throw("missing left hand side" --function interpret_assign)
  endif()

  if(NOT rhs_tokens)
    throw("missing right hand side" --function interpret_assign)
  endif()

  interpret_rvalue("${rhs_tokens}")
  rethrow()
  ans(rhs)

  map_tryget("${rhs}" value)
  ans(rhs_value)

  interpret_lvalue("${lhs_tokens}")
  rethrow()
  ans(lhs)


  map_tryget("${lhs}" value)
  ans(value)

  map_tryget("${lhs}" ref)
  ans(ref)


  map_tryget("${lhs}" value_type)
  ans(value_type)

  map_tryget("${lhs}" const)
  ans(const)


  set(code "set(${ref} ${rhs_value})\n")
  # tokens 
  # expression_type 
  # value_type 
  # ref 
  # code
  # value 
  # const 
  # pure_value
  # children

  ast_new(
    "${tokens}"
    "assign"
    "${value_type}"
    "${ref}"
    "${code}"
    "${value}"
    "${const}"
    "false"
    "${rhs};${lhs}"
    )
  ans(ast)

  return_ref(ast)
endfunction()




# File: source/expr/expressions/interpret_bind_call.cmake



  ##
  ## 
  ## <lhs rvalue>::<rhs rvalue>(<parameter>...)  
  ##  => calls the function pointed to by rvalue  using lhs_ rvalue as its first argument
  ## then appending the other parameters
  ## e.g  `'123'::string_length()->3`
  function(interpret_bind_call tokens)
    set(lhs_tokens ${tokens})

    list_pop_back(lhs_tokens)
    ans(paren_token)
    list_pop_back(lhs_tokens)
    ans(callable_token)
    list_pop_back(lhs_tokens)
    ans(colon1)
    list_pop_back(lhs_tokens)
    ans(colon2)


    if(NOT paren_token)
      throw("invalid token count, expected at least 5 got 0" --function interpret_bind_call)
    endif()
    map_tryget("${paren_token}" type)
    ans(paren_type)


    if(NOT "${paren_type}" STREQUAL "paren")
      throw("expected paren token, got ${paren_type}" --function interpret_bind_call)
    endif()


    if(NOT callable_token)
      throw("invalid token count, expected at least 5 got 1" --function interpret_bind_call)
    endif()

    if(NOT colon1)
      throw("invalid token count, expected at least 5 got 2" --function interpret_bind_call)
    endif()
    if(NOT colon2)
      throw("invalid token count, expected at least 5 got 3" --function interpret_bind_call)
    endif()

    if(NOT lhs_tokens)
      throw("invalid token count, expected at least 5 got 4" --function interpret_bind_call)
    endif()

    map_tryget("${colon1}" type)
    ans(colon1_type)
    if(NOT "${colon1_type}" STREQUAL "colon" )
      throw("expected colon" --function interpret_bind_call)
    endif()

    map_tryget("${colon2}" type)
    ans(colon2_type)
    if(NOT "${colon2_type}" STREQUAL "colon" )
      throw("expected second colon" --function interpret_bind_call)
    endif()


    interpret_rvalue("${lhs_tokens}")
    rethrow()
    ans(lhs)


    interpret_rvalue("${callable_token}")
    rethrow()
    ans(callable)

    map_tryget("${paren_token}" tokens)
    ans(parameter_tokens)

    interpret_elements("${parameter_tokens}" "comma" "interpret_ellipsis;interpret_reference_parameter;interpret_expression")
    ans(parameters)

    next_id()
    ans(ref)

    interpret_call_create_code("${ref}" "${callable}" "${lhs};${parameters}")
    ans(code)

    ast_new(
      "${tokens}"
      "bind_call"
      "any"
      "${ref}"
      "${code}"
      "\${${ref}}"   #value
      "false"         # const
      "false"          #pure value
      "${lhs};${callable};${parameters}" #"${lhs};${callable};${parameters}"
      )
    ans(ast)
    return_ref(ast)    

  endfunction()

# File: source/expr/expressions/interpret_call.cmake


function(interpret_call tokens)
  set(callable_tokens ${tokens})
  ## no tokens
  if(NOT callable_tokens)
    throw("no tokens specified" --function interpret_call)
  endif()


  list_pop_back(callable_tokens)
  ans(paren_token)

  ## call must end with a invocation "("  ")"
  map_tryget("${paren_token}" type)
  ans(type)
  if(NOT "${type}" STREQUAL "paren")
    throw("no value for left hand side" --function interpret_call)
  endif()

  ## call must have callable
  if(NOT callable_tokens)
    throw("no value for left hand side" --function interpret_call)
  endif()

  interpret_rvalue("${callable_tokens}")
  ans(callable_ast)
  if(NOT callable_ast)
    throw("could not parse rvalue" --function interpret_call)
  endif()

  ## get parameters
  map_tryget(${paren_token} tokens)
  ans(parameter_tokens)

  interpret_elements("${parameter_tokens}" "comma" "interpret_ellipsis;interpret_reference_parameter;interpret_expression")
  ans(parameter_asts) 

  ## create code for calling the function
  next_id()
  ans(ref)
  interpret_call_create_code("${ref}" "${callable_ast}" "${parameter_asts}")
  ans(code)

  ## return the ast
  ast_new(
    "${tokens}"
    call
    any
    "${ref}"
    "${code}"
    "\${${ref}}"
    false
    false
    "${rvalue};${parameter_asts}"
    )
  ans(ast)


  return_ref(ast)
endfunction()







# File: source/expr/expressions/interpret_call_create_code.cmake


function(interpret_call_create_code output_ref callable_ast parameter_asts)

  set(parameters_string)
  ## insert parameters passed as argn
  foreach(parameter ${parameter_asts})

    map_tryget("${parameter}" expression_type)
    ans(parameter_expression_type)
    #print_Vars(parameter.expression_type parameter.value)
    if("${parameter_expression_type}" STREQUAL "ellipsis")
      map_tryget("${parameter}" children)
      ans(parameter)
      map_tryget("${parameter}" value)
      ans(parameter_value)
      set(parameters_string "${parameters_string} ${parameter_value}")
    else()
      map_tryget("${parameter}" value)
      ans(parameter_value)
      set(parameters_string "${parameters_string} \"${parameter_value}\"")
    endif()   
  endforeach()

  ## remove initial space
  if(parameter_asts)
    string(SUBSTRING "${parameters_string}" 1 -1 parameters_string)
  endif()


  map_tryget("${callable_ast}" const)
  ans(callable_is_const)

  map_tryget("${callable_ast}" value)
  ans(callable_value)

  if(callable_is_const)
    set(code "${callable_value}(${parameters_string})\nans(${output_ref})\n")
  else()

function(cmake_string_escape3 str)
  if("${str}" MATCHES "[ \"\\(\\)#\\^\t\r\n\\]")
    ## encoded list encode cmake string...
    #string(REPLACE "\\" "\\\\" str "${str}")
    string(REGEX REPLACE "([ \"\\(\\)#\\^])" "\\\\\\1" str "${str}")
    string(REPLACE "\t" "\\t" str "${str}")
    string(REPLACE "\n" "\\n" str "${str}")
    string(REPLACE "\r" "\\r" str "${str}")  
  endif()
  return_ref(str)
endfunction()

    cmake_string_escape3("${parameters_string}")
    ans(parameters_string)
    set(code "eval(\"${callable_value}(${parameters_string})\")\nans(${output_ref})\n")
  endif()


  ## set this if a this value is present
  map_tryget("${callable_ast}" this)
  ans(this)
  if(this)
    map_tryget("${this}" value)
    ans(this_value)
    set(code "set(this ${this_value})\n${code}")
  endif()



  return_ref(code)

endfunction()

# File: source/expr/expressions/interpret_cmake_function_parameters.cmake


function(interpret_cmake_function_parameters tokens)
  

  interpret_elements("${tokens}" "comma" "interpret_key_value;interpret_rvalue")
  ans(members)


  next_id()
  ans(ref)
  set(value "\${${ref}}")
  set(code "map_new()\nans(${ref})\n")
  foreach(member ${members})
    map_tryget("${member}" expression_type)
    ans(member_type)
    if("${member_type}" STREQUAL "key_value")
      map_tryget("${member}" key_ast)
      ans(member_key_ast)
      map_tryget("${member_key_ast}" value )
      ans(member_key_ast_value)
      map_tryget("${member}" value_ast)
      ans(member_value_ast)
      map_tryget("${member_value_ast}" value)
      ans(member_value_ast_value)
      set(code "${code}map_set(${value} \"${member_key_ast_value}\" \"${member_value_ast_value}\")\n")
    elseif("${member_type}" STREQUAL "ellipsis")
      map_tryget("${member}" value)
      ans(member_value)
      set(code "${code}address_append(${value} \"${member_value}\")\n")      
    else() ## normal rvalue      
      map_tryget("${member}" value)
      ans(member_value)
      set(code "${code}encoded_list(\"${member_value}\")\naddress_append(${value} \"\${__ans}\")\n")      
    endif()

  endforeach()


  ast_new(
    "${tokens}"          # tokens
    "object"            # expression_type
    "object"            # value_type
    "${ref}"            # ref
    "${code}"           # code
    "${value}"          # value
    "false"             # const
    "false"             # pure_value
    "${members}"        # children
    )
  ans(ast)

  return_ref(ast)

endfunction()



# File: source/expr/expressions/interpret_default_value.cmake

 function(interpret_default_value tokens)
    set(lhs_tokens ${tokens})

    list_pop_back(lhs_tokens)
    ans(question_mark_token)

    if(NOT question_mark_token)
      throw("no tokens" --function interpret_default_value)
    endif()


    map_tryget("${question_mark_token}" type)
    ans(question_token_type)
    if(NOT "${question_token_type}" STREQUAL "question_mark")
      ans(question_mark_token)
      throw("expected an question token, got ${question_token_type}")
    endif()


    interpret_lvalue("${lhs_tokens}")
    rethrow()
    ans(lvalue)
      
    map_tryget("${lvalue}" ref)
    ans(lvalue_ref)
    map_tryget("${lvalue}" value)
    ans(lvalue_value)

    set(code "is_address(\"${lvalue_value}\")\nif(NOT __ans)\nmap_new()\nans(${lvalue_ref})\nendif()\n")

    ast_new(
      "${tokens}"
      "reference_coercion"
      "address"
      "${lvalue_ref}"
      "${code}"
      "\${${lvalue_ref}}"
      "false"
      "false"
      "${lvalue}"
      )
    ans(ast)
    map_set("${ast}" post_code "${post_code}")
    return_ref(ast)
  endfunction()


# File: source/expr/expressions/interpret_elements.cmake

function(interpret_elements tokens separator_type element_types)
    
  
  ## initialize variables
  set(elements)         # stores all single elements
  set(current_tokens)   # set list of current tokens


  ## loop through all tokens 
  ## and collection non-separators inside `current_tokens`
  ## if a separator or `end` is reached parse the `current_tokens`
  ## to obtain an element
  if(tokens)
    list(APPEND tokens end)
    foreach(token ${tokens})
      map_tryget("${token}" type)
      ans(type)

      if("${token}" STREQUAL "end" OR "${type}" MATCHES "^(${separator_type})$")

        interpret_expression_types("${current_tokens}" "${element_types}")
        ans(element)

        if(NOT element)
            throw("failed to interpret element" --function interpret_elements)
        endif() 

        set(current_tokens)
        list(APPEND elements "${element}")

        if("${token}" STREQUAL "end")
          break()
        endif()
      else()
        list(APPEND current_tokens "${token}")
      endif()
    endforeach()
  endif()

  return_ref(elements)  
endfunction()





# File: source/expr/expressions/interpret_ellipsis.cmake


function(interpret_ellipsis tokens)
  set(dots)
  list_pop_back(tokens)
  ans_append(dots)
  list_pop_back(tokens)
  ans_append(dots)
  list_pop_back(tokens)
  ans_append(dots)

  list_select_property(dots type)
  ans(dot_types)

  if(NOT "${dot_types}" STREQUAL "dot;dot;dot")    
    throw("not ellipsis: ${dot_types}")
  endif()

  if(NOT tokens)
    throw("no left hand rvalue")
  endif()
  

  interpret_rvalue("${tokens}")
  rethrow()
  ans(rvalue)




  map_tryget("${rvalue}" ref)
  ans(rvalue_ref)

  map_tryget("${rvalue}" value_type)
  ans(rvalue_value_type)

  map_tryget("${rvalue}" value)
  ans(rvalue_value)

  map_tryget("${rvalue}" const)
  ans(rvalue_const)

  map_tryget("${rvalue}" pure_value)
  ans(rvalue_pure_value)


  ast_new(
    "${tokens}"
    ellipsis
    "${rvalue_value_type}"
    "${rvalue_ref}"
    ""                      # code
    "${rvalue_value}"
    "${rvalue_const}"
    "${rvalue_pure_value}"
    "${rvalue}"
    )


  ans(ast)
  return_ref(ast)
endfunction()

# File: source/expr/expressions/interpret_expression.cmake


function(interpret_expression tokens)
  set(inner_exceptions)

  interpret_assign("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_rvalue("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)



  throw("could not intepret expression" ${inner_exceptions} --function interpret_expression)
endfunction()

# File: source/expr/expressions/interpret_expression_types.cmake


function(interpret_expression_types tokens types)
  foreach(type ${types})
    eval("${type}(\"${tokens}\")")    
    ans(ast)
    if(ast)
      creturn(${ast})
    endif()
  endforeach()
  throw("no expression could be interpreted" --function interpret_expression_types)
endfunction()

# File: source/expr/expressions/interpret_indexation.cmake

function(interpret_indexation tokens)
  set(lhs_tokens ${tokens})
  list(LENGTH lhs_tokens token_count)
  if(NOT "${token_count}" GREATER 1)
    throw("invalid token count, expected more than one token, got ${token_count}" --function interpret_indexation)
  endif()

  list_pop_back(lhs_tokens)
  ans(indexation_token)

  map_tryget("${indexation_token}" type)
  ans(token_type)


  if(NOT "${token_type}" STREQUAL "bracket")
    throw("invalid token type, expected bracket but got ${token_type}" --function interpret_indexation)
  endif()

  map_tryget("${indexation_token}" tokens)
  ans(inner_tokens)


  interpret_elements("${inner_tokens}" "comma" "interpret_range;interpret_rvalue")
  rethrow()
  ans(elements)

  #print_vars(lhs_tokens)
  interpret_rvalue("${lhs_tokens}")
  rethrow()
  ans(lhs)



  ast_new(
    "${tokens}"         # tokens
    "indexation"        # expression_type
    "${value_type}"                  # value_type
    "${ref}"                  # ref
    "${code}"                  # code
    "\${${ref}}"                  # value
    "false"                  # const
    "false"                  # pure_value
    "${lhs};${elements}"                  # children
    )
  ans(ast)

  map_set(${ast} indexation_lhs ${lhs})
  map_set(${ast} indexation_elements ${elements})
  compile_indexation("${ast}")  
  return_ref(ast)
endfunction()



# File: source/expr/expressions/interpret_interpolation.cmake

## parse elements with whitespace/newline as delimiter
function(interpret_interpolation tokens)
  if(NOT tokens)
    throw("expected at least one token" --function interpret_interpolation)
  endif()
  set(code)
  set(literals)
  set(value)

  foreach(token ${tokens})
    interpret_literal("${token}")
    ans(literal)
    if(NOT literal)
      ## something other than a literal 
      ## causes this not to be a literal
      throw("tokens contained an invalid token: {token}" --function interpret_interpolation)
    endif()

    #print_vars(literal.type literal.value literal.code)

    list(APPEND literals "${literal}")

    map_tryget("${literal}" code)
    ans(literal_code)
    map_tryget("${literal}" value)
    ans(literal_value)
    set(value "${value}${literal_value}")    
  endforeach()
 #   print_vars(value )

  ## single literal is retunred directly
  ## 
  list(LENGTH literals length)
  if("${length}" LESS 2)
    return_ref(literals)
  endif()


  next_id()
  ans(ref)
  
  set(code "set(${ref} \"${value}\")\n")


  ast_new(
    "${tokens}"
    literals            # expression type
    composite_string    # value type
    "${ref}"            # ref
    "${code}"           # code
    "${value}"          # value
    "true"              # const
    "true"              # pure value
    "${literals}"       # children
    )
  ans(ast)
  return_ref(ast)
endfunction()



# File: source/expr/expressions/interpret_key_value.cmake


function(interpret_key_value tokens)
  set(rhs_tokens)
  set(colon_token)
  set(key_tokens ${tokens})
  while(key_tokens)
    list_pop_back(key_tokens)
    ans(token)

    map_tryget("${token}" type)
    ans(token_type)

    if("${token_type}" STREQUAL "colon")
      set(colon_token "${token}")
      break()
    endif()

    list(APPEND rhs_tokens ${token})
  endwhile()

  if(NOT colon_token)
    throw("missing colon" --function interpret_key_value)
  endif()

  if(NOT rhs_tokens)
    throw("missing tokens for the value" --function interpret_key_value)
  endif()

  if(NOT key_tokens)
    throw("no key specified" --function interpret_key_value)
  endif()

  interpret_rvalue("${rhs_tokens}")
  rethrow()
  ans(rhs)

  interpret_rvalue("${key_tokens}")
  rethrow()
  ans(key)



  ast_new(
    "${tokens}"         # tokens
    "key_value"         # expression_type
    "key_value"         # value_type
    ""                  # ref
    ""                  # code
    ""                  # value
    "false"             # const
    "false"             # pure_value
    "${key};${rhs}"     # children
    )
  ans(ast)

  map_set("${ast}" key_ast ${key})
  map_set("${ast}" value_ast ${rhs})

  return_ref(ast)
endfunction()


# File: source/expr/expressions/interpret_list.cmake



function(interpret_list list_token)
  list(LENGTH list_token count)
  if(NOT "${count}" EQUAL 1)
    throw("expected single token, got ${count}" --function interpret_list)
  endif()


  map_tryget("${list_token}" type)
  ans(type)
  if(NOT "${type}" STREQUAL "bracket")
    throw("expected a bracket token, got ${type}")
  endif()

  map_tryget("${list_token}" tokens)
  ans(tokens)

  interpret_elements("${tokens}" "comma" "interpret_expression")
  ans(elements)


  set(value)
  set(const true)
  foreach(element ${elements})
    map_tryget("${element}" value)
    ans(element_value)
    set(value "${value};${element_value}")
    map_tryget("${element}" const)
    ans(is_const)
    if(NOT is_const)
      set(const false)
    endif()
  endforeach()

  ## remove prepending semicolon
  if(elements)
    string(SUBSTRING "${value}" 1 -1 value)
  endif()
  
  next_id()
  ans(ref)
  set(code "set(${ref} \"${value}\")\n")

## expression_type value_type value ref code is_const)
   ast_new(
    "${list_token}"
    list   # expr type
    list   # value type
    "${ref}"  # ref
    "${code}" # code
    "${value}"
    "${const}"
    "false"      # pure_value
    "${elements}"
    )
  ans(ast)
  return_ref(ast)
endfunction()


# File: source/expr/expressions/interpret_literal.cmake

##
##
##
function(interpret_literal token)
 # json_print(${token})
  list(LENGTH token length)
  if(NOT "${length}" EQUAL 1)
    throw("only one token is acceptable, got ${length}" --function interpret_literal)  
  endif()
  map_tryget("${token}" type)
  ans(type)
  if(NOT "${type}" MATCHES "^((unquoted)|(quoted)|(number)|(separated))$")
    throw("invalid type for `literal`: `${type}`" --function interpret_literal)  
  endif()

  map_tryget("${token}" value)
  ans(result_value)
  if("${type}" MATCHES "^((unquoted)|(separated))$")
    if("${type}" STREQUAL "separated")
      string(REGEX MATCH ".(.*)." match "${result_value}")
      set(result_value "${CMAKE_MATCH_1}")
    endif()
    if("${result_value}" MATCHES "^(true)|(false)$")
      set(result_type bool)
    elseif("${result_value}" MATCHES "^0|([1-9][0-9]*)$")
      set(result_type number)
    elseif("${result_value}" STREQUAL "null")
      set(result_type null)
      set(result_value)
    else()
      set(result_type unquoted_string)
    endif()
  elseif("${result_value}" MATCHES "^([\"'])(.*)[\"']$")
    if("${CMAKE_MATCH_1}" STREQUAL "'")
      set(result_type single_quoted_string)
    else()
      set(result_type double_quoted_string)
    endif()
    string(REGEX REPLACE "(\\\\)([\"'])" "\\2" result_value "${CMAKE_MATCH_2}")  
  elseif("${type}" STREQUAL "number")
    set(result_type number)
  endif()

  decode("${result_value}")
  ans(decoded_value)


  cmake_string_escape("${decoded_value}")
  ans(value)

  next_id()
  ans(ref)

  set(code "set(${ref} \"${value}\")\n")


  ast_new(
    "${token}"
    literal             # expression_type
    "${result_type}"    # value_type
    "${ref}"            # ref
    "${code}"           # code
    "${value}"          # value
    "true"              # const
    "true"
    ""                  # children
    )
  ans(ast)

  creturn(${ast})
endfunction()

# File: source/expr/expressions/interpret_lvalue.cmake

function(interpret_lvalue tokens )
  set(exceptions)
  interpret_scope_lvalue("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(exceptions)
  interpret_navigation_lvalue("${tokens}" )
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(exceptions)


  throw("could not interpret lvalue" ${exceptions} --function interpret_lvalue)
endfunction()

# File: source/expr/expressions/interpret_navigation_lvalue.cmake

function(interpret_navigation_lvalue tokens)
  list(LENGTH tokens token_count)
  if(${token_count} LESS 2)
    throw("expected at least two tokens (got {token_count})" --function interpret_navigation_rvalue)
  endif()

  set(lhs_tokens ${tokens})

  list_pop_back(lhs_tokens)
  ans(rhs_token)

  list_pop_back(lhs_tokens)
  ans(dot)

  map_tryget("${dot}" type)
  ans(type)
  if(NOT "${type}" STREQUAL "dot")
    throw("expected second to last token to be a `.`" --function interpret_navigation_rvalue)
  endif()  
  
  if(NOT lhs_tokens)
    throw("no lvalue tokens" --function interpret_navigation_rvalue)
  endif()

  interpret_literal("${rhs_token}")
  ans(rhs)

  map_tryget("${rhs}" value)
  ans(rhs_value)


  interpret_rvalue("${lhs_tokens}")
  ans(lhs)


  map_tryget("${lhs}" expression_type)
  ans(lhs_type)



  map_tryget("${lhs}" value)
  ans(lhs_value)

  next_id()
  ans(ref)

  set(pre_code)
  set(code "map_tryget(${lhs_value} \"${rhs_value}\")\nans(${ref})\n")
  if("${lhs_type}" STREQUAL ellipsis)
    set(post_code "foreach(v ${lhs_value})\nmap_set(\"\${v}\" \"${rhs_value}\" \${${ref}})\nendforeach()\n")
  else()
    set(post_code "map_set(${lhs_value} \"${rhs_value}\" \${${ref}})\n")
  endif()


  ast_new(
    "${tokens}"  # tokens 
    "navigation_lvalue"      # expression_type 
    "any"         # value_type 
    "${ref}"      # ref 
    "${code}"     # code
    "\${${ref}}"  # value 
    "false"      # const 
    "false"          # pure_value
    "${rhs};${lhs}"    # children
    )
  ans(ast)
  map_set("${ast}" pre_code "${pre_code}")
  map_set("${ast}" post_code "${post_code}")
  return_ref(ast)
endfunction()

# File: source/expr/expressions/interpret_navigation_rvalue.cmake

function(interpret_navigation_rvalue tokens)
  list(LENGTH tokens token_count)
  if(${token_count} LESS 2)
    throw("expected at least two tokens (got {token_count})" --function interpret_navigation_rvalue)
  endif()

  list_pop_back(tokens)
  ans(rhs_token)

  if(NOT tokens)
    throw("expected at least two tokens (got {token_count})" --function interpret_navigation_rvalue)
  endif()

  map_tryget("${rhs_token}" type)
  ans(type)

  list_pop_back(tokens)
  ans(dot)
  map_tryget("${dot}" type)
  ans(type)
  if(NOT "${type}" STREQUAL "dot")
    throw("expected second to last token to be a `.`" --function interpret_navigation_rvalue)
  endif()  
  
  if(NOT tokens)
    throw("no lvalue tokens" --function interpret_navigation_rvalue)
  endif()

  interpret_literal("${rhs_token}")
  ans(rhs)

  interpret_rvalue("${tokens}")
  ans(lhs)

  #print_vars(rhs.type rhs.argument rhs.code lhs.type lhs.argument lhs.code --plain)

  map_tryget("${rhs}"  value)
  ans(rhs_value)

  map_tryget("${lhs}"  value)
  ans(lhs_value)

  next_id()
  ans(ref)

  set(code "get_property(__ans GLOBAL PROPERTY \"${lhs_value}.__object__\" SET)
if(__ans)
  message(FATAL_ERROR object_get_not_supported_currently)
else()
  get_property(${ref} GLOBAL PROPERTY \"${lhs_value}.${rhs_value}\")
endif()    
")

  ast_new(
    "${tokens}"
    "navigation_rvalue"  
    "any"           # return type
    "${ref}"        # ref
    "${code}"       # code
    "\${${ref}}"    #value
    "false"         #const
    "false"
    "${rhs};${lhs}"
    )
  ans(ast)

  map_set("${ast}" this_ref "${lhs_argument}")

  return_ref(ast)
endfunction()

# File: source/expr/expressions/interpret_object.cmake


function(interpret_object brace)
  list(LENGTH brace token_count)
  if(NOT "${token_count}" EQUAL 1)
    throw("expected single token, got {token_count}")
  endif()

  map_tryget("${brace}" type)
  ans(brace_token_type)

  if(NOT "${brace_token_type}" STREQUAL "brace")
    throw("expected brace token, got {brace_token_type}")
  endif()

  map_tryget("${brace}" tokens)
  ans(member_tokens)

  interpret_elements("${member_tokens}" "comma" "interpret_key_value;interpret_rvalue")
  ans(members)



  next_id()
  ans(ref)
  set(value "\${${ref}}")
  set(code "map_new()\nans(${ref})\n")
  foreach(member ${members})
    map_tryget("${member}" expression_type)
    ans(member_type)
    if("${member_type}" STREQUAL "key_value")
      map_tryget("${member}" key_ast)
      ans(member_key_ast)
      map_tryget("${member_key_ast}" value )
      ans(member_key_ast_value)
      map_tryget("${member}" value_ast)
      ans(member_value_ast)
      map_tryget("${member_value_ast}" value)
      ans(member_value_ast_value)
      set(code "${code}map_set(${value} \"${member_key_ast_value}\" \"${member_value_ast_value}\")\n")
    else() ## normal rvalue
      map_tryget("${member}" value)
      ans(member_value)
      set(code "${code}address_append(${value} \"${member_value}\")\n")
    endif()
  endforeach()


  ast_new(
    "${brace}"          # tokens
    "object"            # expression_type
    "object"            # value_type
    "${ref}"            # ref
    "${code}"           # code
    "${value}"          # value
    "false"             # const
    "false"             # pure_value
    "${members}"        # children
    )
  ans(ast)
  return_ref(ast)

endfunction()



# File: source/expr/expressions/interpret_paren.cmake

function(interpret_paren paren_token)
  list(LENGTH paren_token count)
  if(NOT "${count}" EQUAL 1)
    throw("expected single paren nesting token got ${count} tokens instread")
  endif()
  map_tryget("${paren_token}" type)
  ans(type)
  if(NOT "${type}" STREQUAL "paren")
    throw("expected paren nesting token got '${type}' type token instead")
  endif()

  map_tryget("${paren_token}" tokens)
  ans(tokens) 

  interpret_expression("${tokens}")
  rethrow() ## rethrow if inner is invalid
  ans(inner_expression)

  map_tryget("${inner_expression}" ref)
  ans(ref)
  
  map_tryget("${inner_expression}" value)
  ans(value)

  map_tryget("${inner_expression}" const)
  ans(const)

  map_tryget("${inner_expression}" value_type)
  ans(value_type)
  
  map_tryget("${inner_expression}" pure_value)
  ans(pure_value)

  map_tryget("${inner_expression}" this)
  ans(this)

  ast_new(
    "${paren_token}"
    "paren"
    "${value_type}"
    "${ref}"
    "${code}"
    "${value}" #value
    "${const}" # const
    "${pure_value}" # pure value
    "${inner_expression}" # children
    )
  ans(ast)
  map_set("${ast}" this "${this}")

  return_ref(ast)

endfunction()




# File: source/expr/expressions/interpret_range.cmake



function(interpret_range tokens)
  interpret_literal("${tokens}")
  ans(index)
  map_tryget("${index}" value_type)
  ans(value_type)
  if(NOT "${value_type}" STREQUAL "number")
    throw("invalid range")
  endif()

  map_tryget("${index}" value)
  ans(value)
  set(code)
  ast_new(
    "${tokens}"
    "range"
    "range"
    ""
    "${code}"
    "${value}"
    "true"
    "true"
    ""
    )
  ans(ast)
  return_ref(ast)
endfunction()




# File: source/expr/expressions/interpret_reference_parameter.cmake


  function(interpret_reference_parameter tokens)
    throw("not implemented" --function interpret_reference_parameter)

    ## interpret $  as __ans which allows custom values
  endfunction()


# File: source/expr/expressions/interpret_rvalue.cmake


## maybe use some kind of quick heuristic?
function(interpret_rvalue tokens)
  set(inner_exceptions)
  interpret_paren("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_rvalue_dereference("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_rvalue_reference("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_default_value("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_ellipsis("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)



  interpret_literal("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_interpolation("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)
  
  interpret_bind_call("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_call("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_list("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_object("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)


  ## needs to come before navigation rvalue because $ needs to bind
  ## stronger
  interpret_scope_rvalue("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_indexation("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)

  interpret_navigation_rvalue("${tokens}")
  ans(ast)
  if(ast)
    creturn(${ast})
  endif()
  ans_append(inner_exceptions)




  throw("could not interpret rvalue" ${inner_exceptions} --function interpret_rvalue )
endfunction()





# File: source/expr/expressions/interpret_rvalue_dereference.cmake


  function(interpret_rvalue_dereference tokens)
    if(NOT tokens)
      throw("no tokens given" --function interpret_rvalue_dereference)
    endif() 



    throw("not implemented" --function interpret_rvalue_dereference)
  endfunction()

# File: source/expr/expressions/interpret_rvalue_reference.cmake

## todo rename ref_of or address_of or....
function(interpret_rvalue_reference tokens)
  if(NOT tokens)
    throw("no tokens given" --function interpret_rvalue_reference)
  endif() 


  set(rvalue_tokens ${tokens})


  throw("not implemented exception" --function interpret_rvalue_reference)
  creturn()
endfunction()

# File: source/expr/expressions/interpret_scope_lvalue.cmake

## interpret an lvalue
## needs a rvalue
function(interpret_scope_lvalue tokens)
  
  if(NOT tokens)
    throw("missing tokens" --function interpret_scope_lvalue)
  endif()

  list(GET tokens 0 dollar_token)
  map_tryget("${dollar_token}" type)
  ans(dollar_token_type)


  if(NOT "${dollar_token_type}" STREQUAL "dollar")
    throw("first token is not the dollar token" --function interpret_scope_lvalue)
  endif()

  set(identifier_token ${tokens})
  list(REMOVE_AT identifier_token 0)
  list(LENGTH identifier_token identifier_token_count)
  if(NOT "${identifier_token_count}" EQUAL 1)
    throw("expected one identifier token got ${identifier_token_count}" --function interpret_scope_lvalue)
  endif()

  
  interpret_rvalue("${identifier_token}")
  rethrow()
  ans(identifier)

  map_tryget("${identifier}" expression_type)
  ans(expression_type)
  if(NOT "${expression_type}" MATCHES "(literal)|(paren)|(bracket)")
    throw("invalid identifier : expected a literal|paren|bracket as an identifier but got ${expression_type}")
  endif()

  map_tryget("${identifier}" value)
  ans(identifier_value)


  set(code)

  ## set both in scope and in parent scope
  set(post_code "set(\"${identifier_value}\" \${${identifier_value}} PARENT_SCOPE)\n")

  # tokens 
  # expression_type 
  # value_type 
  # ref 
  # code
  # value 
  # const 
  # pure_value
  # children


  ast_new(
    "${tokens}"
    "scope_lvalue"
    "any"
    "${identifier_value}"
    "${code}"
    "\${${identifier_value}}"
    "false"
    "false"
    "${identifier}"
    )
  ans(ast)
  map_set("${ast}" post_code "${post_code}")
  return_ref(ast)
endfunction()


# File: source/expr/expressions/interpret_scope_rvalue.cmake


function(interpret_scope_rvalue tokens)
  #print_vars(tokens)
  list(LENGTH tokens count)
  if(NOT ${count} EQUAL 2)
    throw("expected 2 tokens (got {count}) " --function interpret_scope_rvalue)    
  endif()

  list(GET tokens 0 dollar)
  list(GET tokens 1 identifier_token)


  map_tryget("${dollar}" type)
  ans(type)
  if(NOT "${type}" STREQUAL "dollar")
    throw("expected a `$` as first token " --function interpret_scope_rvalue)
  endif()


  if(NOT identifier_token)
    throw("could find identifier" --function interpret_scope_rvalue)
  endif()


  map_tryget("${identifier_token}" type)
  ans(type)

  set(identifier)
  if("${type}" MATCHES "^(quoted)|(unquoted)$")
    interpret_literal("${identifier_token}")
    ans(identifier)
  elseif("${type}" STREQUAL "paren")
    interpret_paren("${identifier_token}" )
    ans(identifier)
  elseif("${type}" STREQUAL "bracket")
    interpret_list("${identifier_token}")
    ans(identifier)
  endif()
  if(NOT identifier)
    throw("could interpret identifier" --function interpret_scope_rvalue)
  endif()


  map_tryget("${identifier}" code)
  ans(identifier_code)

  map_tryget("${identifier}" value)
  ans(value)

  map_tryget("${identifier}" pure_value)
  ans(pure_value)

  set(code)

  ast_new(
    "${tokens}"
    scope_rvalue
    any
    "${value}"
    "${code}"
    "\${${value}}" # value
    "false" # const
    "${pure_value}"
    "${identifier}" # children

    )
  
  ans(ast)

  return_ref(ast)
endfunction()

# File: source/expr/expressions/interpret_separation.cmake

function(interpret_separation tokens separator_type separator_char pre_element post_element)

    
    ## initialize variables
    set(elements)         # stores all single elements
    set(current_tokens)   # set list of current tokens
    set(const true)      # set if all elements are const
    set(argument)         # set derived argument
    set(code)             # set derived code


    ## loop through all tokens 
    ## and collection non-separators inside `current_tokens`
    ## if a separator or `end` is reached parse the `current_tokens`
    ## to obtain an element
    list(APPEND tokens end)
    foreach(token ${tokens})
      map_tryget("${token}" type)
      ans(type)
     # print_vars(type)
      if("${token}" STREQUAL "end" OR "${type}" MATCHES "^(${separator_type})$")

        interpret_expression("${current_tokens}" ${ARGN})
        ans(element)

        if(NOT element)
            throw("failed to interpret element")
        endif() 
        set(current_tokens)
        list(APPEND elements "${element}")

        map_tryget("${element}" const)
        ans(is_const)

        if(NOT is_const)
          set(const false)
        endif()

        map_tryget("${element}" code)
        ans(element_code)

        map_tryget("${element}" argument)
        ans(element_argument)

        set(code "${code}${element_code}")
        set(argument "${argument}${separator_char}${pre_element}${element_argument}${post_element}")

        if("${token}" STREQUAL "end")
          break()
        endif()
      else()
        list(APPEND current_tokens "${token}")
      endif()
    endforeach()
    string(LENGTH argument argument_length)
    if(argument_length)
        # remove leading whitespace
        string(SUBSTRING "${argument}" 1 -1 argument)
    endif()
    map_new()
    ans(ast)
    map_set("${ast}" type separation)
    map_set("${ast}" elements "${elements}")
    map_set("${ast}" code "${code}")
    map_set("${ast}" argument "${argument}")
    map_set("${ast}" const "${const}")
    creturn(${ast})
endfunction()




# File: source/expr/expressions/interpret_statements.cmake

function(interpret_statements tokens)
  interpret_separation("${tokens}" "semicolon" " " "" "")
  ans(separation)

  if(NOT separation)
    creturn(${separation})
  endif()

  map_peek_back("${separation}" elements)
  ans(last)

  map_tryget("${last}" argument)
  ans(last_argument)


  
  set(ast ${separation})
  map_set(${ast} argument "${last_argument}")


  creturn(${ast})
endfunction()

# File: source/expr/lexer/arguments_create_tokens.cmake

macro(arguments_create_tokens __start_idx __end_idx)
  arguments_tokenize("${__start_idx}" "${__end_idx}")
  tokens_create("${token_strings}" "${token_types}")
endmacro()
 

# File: source/expr/lexer/arguments_tokenize.cmake


macro(arguments_tokenize first last)

  math(EXPR _last "${last} - 1")
  #_message("first ${first} last ${last} _last ${_last}")
  if(NOT ${first} GREATER ${_last})
    set(input)
    foreach(i RANGE ${first} ${_last})
      set(input "${input}${ARGV${i}}")
    endforeach()
    string(REPLACE ";" "" input "${input}")
    string(REPLACE "(" "" input "${input}")
    string(REPLACE ")" "" input "${input}")
    string(REPLACE "[" "" input "${input}")
    string(REPLACE "]" "" input "${input}")

   # _message("input '${input}'")
    ## tokenize the string
   # string(REPLACE "" ";;" input "${input}")
    set(token_chars "{},:=&\\*\\$\\.\\-\\+\\|\\^%#@!\\?\\/~<>")

    set(token_regex "([^\"';${token_chars}]*)|||([\"']([^\"'\\]|([\\]['\"])|([\\][\\])|([\\]))*[\"'])|('.?')|[ \t]+||||||{|}|,|:|=|&|\\*|\\$|\\.|\\-|\\+|\\||\\^|%|#|@|!|\\?|\\/|~|\n|<|>|([^ \t{},:=&\\*\\$\\.\\-\\+\\|\\^%#@!\\?\\/~<>\n]+)")
    
    
    string(REGEX MATCHALL "${token_regex}" token_strings "${input}")
    string(REGEX REPLACE "${token_regex}" "" error "${input}")
   # messaGE("${token_strings}")
    if(NOT error)

      set(type_list 
        invalid         # 0
        number          # 1
        quoted          # 2
        char            # 3
        bracket_open    # 4
        bracket_close   # 5
        paren_open      # 6
        paren_close     # 7
        semicolon       # 8 
        brace_open      # 9
        brace_close     # 10
        comma           # 11
        colon           # 12
        equals          # 13
        ampersand       # 14
        asterisk        # 15
        dollar          # 16
        dot             # 17
        minus           # 18
        plus            # 19
        pipe            # 20
        zirkumflex      # 21
        modulo          # 22
        hash            # 23
        at              # 24
        exclamation_mark# 25
        question_mark   # 26
        slash           # 27
        tilde           # 28
        new_line        # 29
        angular_open    # 30
        angular_close   # 31
        separated       # 32
        separation_open # 33
        separation_close# 34
        white_space     # 35
        unquoted        # 36
        )
      
      ## replace the token_strings with their respective indices in the type_list
      ## use the index indicator  so that normal numbers are not confused
      ## with token indices 
      set(token_codes ${token_strings})
      string(REGEX REPLACE  ";[0-9]+;" ";1;"  token_codes "${token_codes}" )
      string(REGEX REPLACE "[\"']([^\"'\\]|([\\][\"'])|([\\][\\])|([\\]))*[\"']" "2" token_codes "${token_codes}")  
      string(REGEX REPLACE "'.?'" "3" token_codes "${token_codes}")
      string(REGEX REPLACE "" "4" token_codes "${token_codes}")
      string(REGEX REPLACE "" "5" token_codes "${token_codes}")
      string(REGEX REPLACE "" "6" token_codes "${token_codes}")
      string(REGEX REPLACE "" "7" token_codes "${token_codes}")
      string(REGEX REPLACE "" "8" token_codes "${token_codes}")
      string(REGEX REPLACE "{" "9" token_codes "${token_codes}")
      string(REGEX REPLACE "}" "10" token_codes "${token_codes}")
      string(REGEX REPLACE "," "11" token_codes "${token_codes}")
      string(REGEX REPLACE ":" "12" token_codes "${token_codes}")
      string(REGEX REPLACE "=" "13" token_codes "${token_codes}")
      string(REGEX REPLACE "&" "14" token_codes "${token_codes}")
      string(REGEX REPLACE "\\*" "15" token_codes "${token_codes}")
      string(REGEX REPLACE "\\$" "16" token_codes "${token_codes}")
      string(REGEX REPLACE "\\." "17" token_codes "${token_codes}")
      string(REGEX REPLACE "\\-" "18" token_codes "${token_codes}")
      string(REGEX REPLACE "\\+" "19" token_codes "${token_codes}")
      string(REGEX REPLACE "\\|" "20" token_codes "${token_codes}")
      string(REGEX REPLACE "\\^" "21" token_codes "${token_codes}")
      string(REGEX REPLACE "%" "22" token_codes "${token_codes}")
      string(REGEX REPLACE "#" "23" token_codes "${token_codes}")
      string(REGEX REPLACE "@" "24" token_codes "${token_codes}")
      string(REGEX REPLACE "!" "25" token_codes "${token_codes}")
      string(REGEX REPLACE "\\?" "26" token_codes "${token_codes}")
      string(REGEX REPLACE "\\/" "27" token_codes "${token_codes}")
      string(REGEX REPLACE "~" "28" token_codes "${token_codes}")
      string(REGEX REPLACE "\n" "29" token_codes "${token_codes}")
      string(REGEX REPLACE "<" "30" token_codes "${token_codes}")
      string(REGEX REPLACE ">" "31" token_codes "${token_codes}")
      string(REGEX REPLACE "[^;${token_chars}]*" "32" token_codes "${token_codes}")
      string(REGEX REPLACE "" "33" token_codes "${token_codes}")
      string(REGEX REPLACE "" "34" token_codes "${token_codes}")
      string(REGEX REPLACE "[ \t]+" "35" token_codes "${token_codes}")
      string(REGEX REPLACE ";[^][^;]*;" ";36;" token_codes "${token_codes}" )

      ## remove token type index indicator to obtain pure indices
      string(REPLACE "" "" token_codes "${token_codes}")

      if(token_codes)
        list(GET type_list ${token_codes} token_types)
      else()
        set(token_types)
      endif()
      list(LENGTH token_strings token_count)
    else()
      set(error "could not tokenize '${error}'")
    endif()
  else()
    set(error invalid_input_args)
  endif()
endmacro()


# File: source/expr/lexer/tokenize.cmake



function(tokenize)
  arguments_tokenize("0" "${ARGC}")
  set(type_list ${type_list} PARENT_SCOPE)
  set(error ${error} PARENT_SCOPE)
  set(token_types ${token_types} PARENT_SCOPE)
  set(tokens ${tokens} PARENT_SCOPE)
endfunction()


# File: source/expr/lexer/tokens_create.cmake



  function(tokens_create tokenlist typelist)
    list(LENGTH typelist token_count)
    math(EXPR last_index "${token_count} - 1")

    if(NOT token_count)
      creturn()
    endif()

    map_new()
    ans(current_nesting)
    map_set("${current_nesting}" nesting_type root)
    set(nesting_stack)
    foreach(i RANGE 0 ${last_index})
      list(GET typelist ${i} type)
      list(GET tokenlist ${i} value)
    
      map_new()
      ans(token)
      map_set("${token}" value "${value}")
      map_set("${token}" type "${type}")


      if("${type}" MATCHES "^((paren_close)|(brace_close)|(bracket_close))$")
        list(GET nesting_stack 0 parent_nesting)
        list(REMOVE_AT nesting_stack 0)
        map_append("${parent_nesting}" tokens ${current_nesting})
        map_set(${current_nesting} end_token ${token})
        set(current_nesting "${parent_nesting}")
      elseif("${type}" STREQUAL "paren_open")
        list(INSERT nesting_stack 0 ${current_nesting})
        map_new()
        ans(current_nesting)
        map_set(${current_nesting} type paren)
        map_set(${current_nesting} begin_token ${token})
      elseif("${type}" STREQUAL "bracket_open")
        list(INSERT nesting_stack 0 ${current_nesting})
        map_new()
        ans(current_nesting)
        map_set(${current_nesting} type bracket)
        map_set(${current_nesting} begin_token ${token})
      elseif("${type}" STREQUAL "brace_open")
        list(INSERT nesting_stack 0 ${current_nesting})
        map_new()
        ans(current_nesting)
        map_set(${current_nesting} type brace)
        map_set(${current_nesting} begin_token ${token})
      elseif(NOT "${type}" MATCHES "^((white_space)|(separation_close)|(separation_open))$")
        map_append("${current_nesting}" tokens "${token}")
      endif()
    endforeach()

    map_tryget("${current_nesting}" tokens)
    ans(tokens)



    return_ref(tokens)
  endfunction()


# File: source/expr/parser/ast_new.cmake


function(ast_new 
  tokens 
  expression_type 
  value_type 
  ref 
  code
  value 
  const 
  pure_value
  children

  )
  map_new()
  ans(ast)
  map_set(${ast} expression_type "${expression_type}")
  map_set(${ast} value_type "${value_type}")
  map_set(${ast} value "${value}")
  map_set(${ast} const "${const}")
  map_set(${ast} pure_value "${pure_value}")
  map_set(${ast} ref "${ref}")
  map_set(${ast} code "${code}")
  map_set(${ast} tokens "${tokens}")

  if(children)
    foreach(child ${children})
      map_set("${child}" parent "${ast}")
    endforeach()
    map_set("${ast}" children ${children})
  endif()

  creturn(${ast})
endfunction()


# File: source/expr/parser/next_id.cmake

function(next_id)
  address_new()
  ans(global_ref)
  address_set("${global_ref}" 0)
  eval("
  function(next_id)
    address_get(${global_ref})
    math(EXPR __ans \"\${__ans} + 1\")
    address_set(${global_ref} \${__ans})
    set(__ans \"_\${__ans}\" PARENT_SCOPE)
  endfunction()
  ")
  next_id()
  return_ans()
endfunction()


# File: source/expr/value_range_get.cmake


function(value_range_get value range)
  list(LENGTH value length)
  if("${range}" MATCHES "^(0|([1-9][0-9]*))$")
    if(NOT length)
      throw("index out of range: ${range}")
    endif()
    list(GET value "${range}" result)
    return_ref(result)
  endif()

  list_range_get(value "${range}")
  return_ans()
endfunction()



# File: source/filesystem/archive/archive_isvalid.cmake

## `archive_isvalid(<path>)-> <bool>`
##
## returns true if the specified path identifies an archive 
## file
function(archive_isvalid file)
  mime_type("${file}")
  ans(types)

  list_contains(types "application/x-gzip")
  ans(is_archive)


  return_ref(is_archive)
endfunction()

# File: source/filesystem/archive/archive_ls.cmake


function(archive_ls archive)
  path_qualify(archive)


  mime_type("${archive}")
  ans(types)


  if("${types}" MATCHES "application/x-gzip")
    checksum_file("${archive}")
    ans(key)
    string_cache_return_hit(archive_ls_cache "${key}")


    tar_lean(tf "${archive}")
    ans_extract(erro)
    ans(files)

    tar_lean(tf "${archive}")
    ans_extract(error)
    ans(files)

    if(error)
      error("tar exited with {result.error}")
      creturn()
    endif()


    string(REGEX MATCHALL "(^|\n)([^\n]+)(\n|$)" files "${files}")
    string(REGEX REPLACE "(\r|\n)" "" files "${files}")
    
    string_cache_update(archive_ls_cache "${key}" "${files}")
    return_ref(files)

  else()
    message(FATAL_ERROR "${archive} unsupported compression: '${types}'")
  endif()

 endfunction()


# File: source/filesystem/archive/archive_match_files.cmake

## returns all files which match the specified regex
## the regex must match the whole filename
function(archive_match_files archive regex)
  set(args ${ARGN})

  list_extract_flag(args --single)
  ans(single)
  list_extract_flag(args --first)
  ans(first)

  path_qualify(archive)

  mime_type("${archive}")
  ans(types)


  if("${types}" MATCHES "application/x-gzip")

    archive_ls("${archive}")
    ans(files)
    string(REGEX MATCHALL "(^|;)(${regex})(;|$)" files "${files}")
    set(files ${files}) # necessary because of leading and trailing ;
  else()
    message(FATAL_ERROR "${archive} unsupported compression: '${types}'")
  endif()

  if(single)
    list(LENGTH files len)
    if(NOT "${len}" EQUAL 1)
      set(files)
    endif()
  endif()

  if(first)
    list_pop_front(files)
    ans(files)
  endif()

  return_ref(files)
endfunction()

# File: source/filesystem/archive/archive_read_file.cmake



function(archive_read_file archive file)
  path_qualify(archive)
  mktemp()
  ans(temp_dir)
  uncompress_file("${temp_dir}" "${archive}" "${file}")
  fread("${temp_dir}/${file}")
  ans(content)
  rm("${temp_dir}")
  return_ref(content) 
endfunction()



# File: source/filesystem/archive/archive_read_file_match.cmake


function(archive_read_file_match archive regex)
  path_qualify(archive)
  archive_match_files("${archive}" "${regex}")
  ans(file_path)
  list(LENGTH file_path count)
  if(NOT "${count}" EQUAL 1)
    creturn()
  endif()

  archive_read_file("${archive}" "${file_path}")
  return_ans()
endfunction()



# File: source/filesystem/archive/compress.cmake

# compresses all files specified in glob expressions (relative to pwd) into ${target_file} tgz file
# usage: compress(<file> [<glob> ...]) - 
# 
function(compress target_file)
  set(args ${ARGN})
  
  list_extract_labelled_value(args --format)
  ans(format)

  ## try to resolve format by extension
  if("${format}_" STREQUAL "_")
    mime_type_from_filename("${target_file}")
    ans(format)
  endif()

  ## set default formt to application/x-gzip
  if("${format}_" STREQUAL "_")
    set(format "application/x-gzip")
  endif()

  if(format STREQUAL "application/x-gzip")
    compress_tgz("${target_file}" ${args})
    return_ans()
  else()
    message(FATAL_ERROR "format not supported: ${format}, target_file: ${target_file}")
  endif()
endfunction()



# File: source/filesystem/archive/compress_tgz.cmake


function(compress_tgz target_file)
  set(args ${ARGN})
  # target_file file
  path_qualify(target_file)

  # get all files to compress
  glob(${args} --relative)
  ans(paths)

  # compress all files into target_file using paths relative to pwd()
  tar_lean(cvzf "${target_file}" ${paths})
  ans_extract(error)
  return_ans()
endfunction()

# File: source/filesystem/archive/file_istarfile.cmake

## returns true if the specified file is a tar archive 
function(file_istarfile file)
	path_qualify(file)
	if(NOT EXISTS "${file}")
		creturn(false)
	endif()
	if(IS_DIRECTORY "${file}")
		creturn(false)
	endif()
	tar_lean(ztvf "${file}")
	ans_extract(res)
	ans(rest)

	if(res)
		creturn(false)
	endif()

	creturn(true)
	
endfunction()






# File: source/filesystem/archive/tar.cmake

# tar command 
# use cvzf to compress files relative to pwd() to a tgz file 
# use xzf to uncompress a tgz file to the pwd()
function(tar)
  cmake(-E tar ${ARGN})
  return_ans()
endfunction()



# File: source/filesystem/archive/tar_lean.cmake

function(tar_lean)
  cmake_lean(-E tar ${ARGN})
  return_ans()
endfunction()

# File: source/filesystem/archive/uncompress.cmake

## uncompresses the file specified into the current pwd()
function(uncompress file)
  mime_type("${file}")
  ans(types)

  if("${types}" MATCHES "application/x-gzip")
    dir_ensure_exists(".")  
    path_qualify(file)
    tar_lean(xzf "${file}" ${ARGN})
    ans_extract(error)
    return_ans()
  else()
    message(FATAL_ERROR "unsupported compression: '${types}'")
  endif()
endfunction()







# File: source/filesystem/archive/uncompress_file.cmake

#uncompresses specific files from archive specified by varargs and stores them in target_dir directory
function(uncompress_file target_dir archive)
  set(files ${ARGN})

  path_qualify(archive)

  mime_type("${archive}")
  ans(types)


  if("${types}" MATCHES "application/x-gzip")
    pushd("${target_dir}" --create)
      tar_lean(-zxvf "${archive}" ${files})
      ans_extract(error)
      ans(result)
    popd()
    return_ref(result)
  else()
    message(FATAL_ERROR "unsupported compression: '${types}'")
  endif()

endfunction()


# File: source/filesystem/dir_ensure_exists.cmake


## ensures that the directory specified exists 
## the directory is qualified with path()
function(dir_ensure_exists path)
  path("${path}")
  ans(path)
  if(EXISTS "${path}")
    if(IS_DIRECTORY "${path}")
      creturn("${path}")
    endif()
    creturn()
  endif()
  mkdir("${path}")
  return_ans()
endfunction()

# File: source/filesystem/dir_isempty.cmake

## returns true iff specified path does not contain any files
function(dir_isempty path)
  ls("${path}")
  ans(files)
  list(LENGTH files len)
  if(len)
    creturn(false)
  endif()
  creturn(true)
endfunction()

# File: source/filesystem/file/fappend.cmake

function(fappend path)
  path("${path}")
  ans(path)
  file(APPEND "${path}" ${ARGN})
  creturn()
endfunction()

# File: source/filesystem/file/fequal.cmake

  ## compares the specified files
  ## returning true if their content is the same else false
  function(fequal lhs rhs)
    path_qualify(lhs)
    path_qualify(rhs)

    cmake(-E compare_files "${lhs}" "${rhs}" --exit-code)
    ans(error)
    
    if(error)
      creturn(false)
    endif()
    creturn(true)
  endfunction()


# File: source/filesystem/file/fexists.cmake


function(fexists)
  path("${ARGN}")
  ans(path)

  if(NOT EXISTS "${path}")
    creturn(false)
  endif()

  if(IS_DIRECTORY "${path}")
    creturn(false)
  endif()
  creturn(true)
endfunction()


# File: source/filesystem/file/fopen_data.cmake

##
##
## tries to deserialize a file file.*  
function(fopen_data file)
  glob_path("${file}")
  ans(file)

  if(NOT EXISTS "${file}" OR IS_DIRECTORY "${file}")
    glob("${file}.*") 
    ans(file)
    list(LENGTH file len)
    if(NOT ${len} EQUAL 1)
      creturn()
    endif()
    if(IS_DIRECTORY "${file}")
      creturn()
    endif()
  endif()

  fread_data("${file}" ${ARGN})
  return_ans()
endfunction()

# File: source/filesystem/file/fprint.cmake

## prints the specified file to the console
function(fprint path)
  fread("${path}")
  ans(res)
  _message("${res}")
  creturn()
endfunction()


function(fprint_try path)
  path_qualify(path)
  if(EXISTS "${path}")
    fprint("${path}")
  endif()
  creturn()
endfunction()

# File: source/filesystem/file/fread.cmake

# reads the file specified and returns its content
function(fread path)
  path("${path}")
  ans(path)
  file(READ "${path}" res)
  return_ref(res)
endfunction()

# File: source/filesystem/file/fread_data.cmake



## tries to read the spcified file format
function(fread_data path)
  set(args ${ARGN})

  path_qualify(path)
  
  list_pop_front(args)
  ans(mime_type)

  if(NOT mime_type)

    mime_type("${path}")
    ans(mime_type)

    if(NOT mime_type)
      creturn()
    endif()

  endif()
  set(result)
  if("${mime_type}" MATCHES "application/json")
    json_read("${path}")
    ans(result)
  elseif("${mime_type}" MATCHES "application/x-quickmap")
    qm_read("${path}")
    ans(result)
  elseif("${mime_type}" MATCHES "application/x-serializedcmake")
    cmake_read("${path}")
    ans(result)
  else()
    creturn()
  endif()

  ## set target file property which allows identification of where the map was read
  ## if it was a single map
  map_source_file_set("${result}" "${path}")      

  creturn(${result})

endfunction()


# File: source/filesystem/file/fread_lines.cmake

# reads the file specified and returns its content
function(fread_lines path)
  path_qualify(path)
  set(args ${ARGN})

  list_extract_labelled_keyvalue(args --regex REGEX)
  ans(regex)
  list_extract_labelled_keyvalue(args --limit-count LIMIT_COUNT)
  ans(limit_count)
  list_extract_labelled_keyvalue(args --limit-input LIMIT_INPUT)
  ans(limit_input)
  list_extract_labelled_keyvalue(args --limit-output LIMIT_OUTPUT)
  ans(limit_output)
  list_extract_labelled_keyvalue(args --length-minimum LENGTH_MINIMUM)
  ans(length_minimum)
  list_extract_labelled_keyvalue(args --length-maximum LENGTH_MAXIMUM)
  ans(length_maximum)
  list_extract_flag_name(args --newline-consume NEWLINE_CONSUME)
  ans(newline_cosume)
  list_extract_flag_name(args --no-hex-conversion NO_HEX_CONVERSION)
  ans(no_hex_conversion)


  file(STRINGS "${path}" res 
    ${limit_count} 
    ${limit_input} 
    ${limit_output} 
    ${length_minimum} 
    ${length_maximum}
    ${newline_cosume}
    ${regex}
    ${no_hex_conversion}
  )

  return_ref(res)
endfunction()

# File: source/filesystem/file/fread_unicode16.cmake



  ## this is a hard hack to read unicode 16 files
  ##  it reads the file by lines and concatenates the result which removes all linebreaks  
  ## please don't use this :)
  function(fread_unicode16 path)
    path("${path}")
    ans(path)
    file(STRINGS "${path}" lines)  
    string(REPLACE ";" "" res "${lines}")
   # string(CONCAT res ${lines})
    return_ref(res)
  endfunction()


# File: source/filesystem/file/ftime.cmake


## returns the timestamp for the specified path
function(ftime path)
  path_qualify(path)

  if(NOT EXISTS "${path}")
    creturn()
  endif()

  file(TIMESTAMP "${path}" res)

  return_ref(res)
endfunction()

# File: source/filesystem/file/fwrite.cmake

# writs argn to the speicified file creating it if it does not exist and 
# overwriting it if it does.
function(fwrite path)
  path_qualify(path)
  file(WRITE "${path}" "${ARGN}")
  event_emit(on_fwrite "${path}")
  return_ref(path)
endfunction()

# File: source/filesystem/file/fwrite_data.cmake

  ## fwrite_data(<path> ([--mimetype <mime type>]|[--json]|[--qm]) <~structured data?>) -> <structured data>
  ##
  ## writes the specified data into the specified target file (overwriting it if it exists)
  ##
  ## fails if no format could be chosen
  ##
  ## format:  if you do not specify a format by passing a mime-type
  ##          or type flag the mime-type is chosen by analysing the 
  ##          file extension - e.g. *.qm files serialize to quickmap
  ##          *.json files serialize to json
  ##
  function(fwrite_data target_file)
    
    set(args ${ARGN})

    ## check first arg is a map with a stored $target_file hidden property
    ## then we can use this as the target file
    ## this field only exists if fread_data was used to read data
    map_source_file_get("${target_file}")
    ans(new_target_file)
    if(new_target_file)
      set(args ${target_file})
      set(target_file "${new_target_file}")      
    endif()   




    ## choose mime type
    list_extract_labelled_value(args --mime-type)
    ans(mime_types)

    list_extract_flag(args --json)
    ans(json)

    list_extract_flag(args --qm)
    ans(quickmap)

    list_extract_flag(args --cmake)
    ans(cmake)

    if(cmake)
      set(mime_types application/x-serializedcmake)
    endif()

    if(json)
      set(mime_types application/json)
    endif()

    if(quickmap)
      set(mime_types application/x-quickmap)
    endif()


    if(NOT mime_types)
      mime_type_from_filename("${target_file}")
      ans(mime_types)
      if(NOT mime_types)
        set(mime_types "application/json")
      endif()
    endif()

    ## parse data
    data(${args})
    ans(data)


    ## serialize data
    if("${mime_types}" MATCHES "application/json")
      json_indented("${data}")
      ans(serialized)
    elseif("${mime_types}" MATCHES "application/x-serializedcmake")
      cmake_serialize("${data}")
      ans(serialized)
    elseif("${mime_types}" MATCHES "application/x-quickmap")
      qm_serialize("${data}")
      ans(serialized)
    else()
      message(FATAL_ERROR "serialization to '${mime_types}' is not supported")
    endif()

    ## write and return data
    fwrite("${target_file}" "${serialized}")

    map_source_file_set("${data}" "${target_file}")    

    return_ref(data)
  endfunction()


# File: source/filesystem/file/map_source_file_get.cmake


function(map_source_file_get)
  map_tryget("${ARGN}" $map_source_file)
  return_ans()
endfunction()


# File: source/filesystem/file/map_source_file_set.cmake


function(map_source_file_set map file_name)
  is_map("${map}")
  ans(is_map)
  if(is_map)
    path_qualify(file_name)
    map_set_hidden("${map}" $map_source_file "${file_name}")
    creturn("${file_name}")
  endif()
  creturn()
endfunction()

# File: source/filesystem/file_isjsonfile.cmake

function(file_isjsonfile file)
  creturn(false)
endfunction()

# File: source/filesystem/file_isqmfile.cmake


function(file_isqmfile file)
    path_qualify(file)
    if(NOT EXISTS "${file}" OR IS_DIRECTORY "${file}")
      creturn(false)
    endif()
  file(READ "${file}" result LIMIT 3)
  if(result STREQUAL "#qm")
    creturn(true)
  endif()

  creturn(false)

endfunction()

# File: source/filesystem/file_isserializedcmakefile.cmake


function(file_isserializedcmakefile file)
  path_qualify(file)
  if(NOT EXISTS "${file}" OR IS_DIRECTORY "${file}")
    creturn(false)
  endif()
  file(READ "${file}" result LIMIT 7)
  if("${result}" MATCHES "^#cmake")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/filesystem/file_map_write.cmake


## writes a file_map to the pwd.
## empty directories are not created
## fm is parsed according to obj()
function(file_map_write fm)


  # define callbacks for building result
  function(fmw_dir_begin)
    map_tryget(${context} current_key)
    ans(key)
    if("${map_length}" EQUAL 0)
      creturn()
    endif()
    if(key)
      pushd("${key}" --create)
    else()
      pushd()
    endif()
  endfunction()
  function(fmw_dir_end)
    if(NOT "${map_length}" EQUAL 0)    
      popd()
    endif()
  endfunction()
  function(fmw_path_change)
    map_set(${context} current_key "${map_element_key}")
  endfunction()

  function(fmw_file)
    map_get(${context} current_key) 
    ans(key)
    fwrite("${key}" "${node}")
  endfunction()

   map()
    kv(value              fmw_file)
    kv(map_begin          fmw_dir_begin)
    kv(map_end            fmw_dir_end)
    kv(list_begin         fmw_file)
    kv(map_element_begin  fmw_path_change)
  end()
  ans(file_map_write_cbs)
  function_import_table(${file_map_write_cbs} file_map_write_callback)

  # function definition
  function(file_map_write fm)            
    obj("${fm}")
    ans(fm)

    map_new()
    ans(context)
    dfs_callback(file_map_write_callback ${fm} ${ARGN})
    map_tryget(${context} files)
    return_ans()  
  endfunction()
  #delegate
  file_map_write(${fm} ${ARGN})
  return_ans()
endfunction()

function(file_map_read)
  path("${ARGN}")
  ans(path)
  message("path ${path}")
  
  file(GLOB_RECURSE paths RELATIVE "${path}" ${path}/**)

  message("paths ${paths}")



  return_ans()

endfunction()

# File: source/filesystem/fwrite_temp.cmake

##
## 
## creates a temporary file containing the specified content
## returns the path for that file 
function(fwrite_temp content)
    set(ext ${ARGN})

    if (NOT ext)
        set(ext ".txt")
    endif ()

    cmakepp_config(temp_dir)
    ans(temp_dir)

    path_vary("${temp_dir}/fwrite_temp${ext}")
    ans(temp_path)

    fwrite("${temp_path}" "${content}")

    return_ref(temp_path)
endfunction()


# File: source/filesystem/globbing/glob.cmake

## `(<glob expression...> [--relative] [--recurse]) -> <qualified path...>|<relative path...>`
##
## **flags**:
## * `--relative` causes the output to be paths realtive to current `pwd()`
## * `--recurse` causes the glob expression to be applied recursively
## **scope**
## * `pwd()` influences the relative paths
## **returns**
## * list of files matching the specified glob expressions 
function(glob)
    set(args ${ARGN})
    list_extract_flag(args --relative)
    ans(relative)

    list_extract_flag(args --recurse)
    ans(recurse)

    glob_paths(${args})
    ans(globs)

    if (recurse)
        set(glob_command GLOB_RECURSE)
    else ()
        set(glob_command GLOB)
    endif ()

    if (relative)
        pwd()
        ans(pwd)
        set(relative RELATIVE "${pwd}")
    else ()
        set(relative)
    endif ()

    set(paths)

    if (globs)
        file(${glob_command} paths ${relative} ${globs})
        list_remove_duplicates(paths)
    endif ()

    return_ref(paths)
endfunction()


# File: source/filesystem/globbing/glob_expression_parse.cmake


  ## glob_expression_parse(<glob ignore path...>) -> {include:<glob path>, exclude:<glob path>}
  ##
  ##
  function(glob_expression_parse)
    set(args ${ARGN})

    is_map("${args}")
    ans(ismap)
    if(ismap)
      return_ref(args)
    endif()

    string(REGEX MATCHALL "![^;]+" exclude "${args}")
    string(REGEX MATCHALL "[^!;]+" exclude "${exclude}")
    string(REGEX MATCHALL "(^|;)[^!;][^;]*" include "${args}")
    string(REGEX MATCHALL "[^;]+" include "${include}")


    map_capture_new(include exclude)
    ans(res)
    return_ref(res)

  endfunction()


# File: source/filesystem/globbing/glob_ignore.cmake

## `(<glob ignore expression...> [--relative] [--recurse]) -> <path...>`
##
## 
function(glob_ignore)
  set(args ${ARGN})
  list_extract_flag_name(args --relative)
  ans(relative)
  list_extract_flag_name(args --recurse)
  ans(recurse)


  glob_expression_parse(${args})
  ans(glob_expression)

  map_import_properties(${glob_expression} include exclude)

  glob(${relative} ${include} ${recurse})
  ans(included_paths)

  glob(${relative} ${exclude} ${recurse})
  ans(excluded_paths)
  if(excluded_paths)
    list(REMOVE_ITEM included_paths ${excluded_paths})
  endif()
  return_ref(included_paths)
endfunction()



# File: source/filesystem/globbing/glob_parent_dir_containing.cmake

## `(<directory> <glob expression>)-><qualified director>`
## 
## 
## finds the closest parent dir (or dir itself)
## that contains any of the specified glob expressions
## (also see file_glob for syntax)
function(glob_parent_dir_containing )
  glob_up(0 ${ARGN})
  ans(matches)
  list_peek_front(matches)
  ans(first_match)
  if(NOT first_match)
    creturn()
  endif()

  path_component("${first_match}" PATH)
  ans(first_match)

  return_ref(first_match)
endfunction()

# File: source/filesystem/globbing/glob_path.cmake


  ## glob_paths(<unqualified glob path>) -> <qualified glob path.>
  ##
  ## 
  function(glob_path glob)
    string_take_regex(glob "[^\\*\\[{]+")
    ans(path)

    string(REGEX MATCH "[^/]+$" match "${path}")
    set(glob "${match}${glob}")
    string(REGEX REPLACE "[^/]+$" "" path "${path}")

    path_qualify(path)

    if(glob)
      set(path "${path}/${glob}")
    endif()
    return_ref(path)
 endfunction()


# File: source/filesystem/globbing/glob_paths.cmake


  ## glob_paths(<unqualified glob path...>) -> <qualified glob path...>
  ##
  ## 
 function(glob_paths)
  set(result)
  foreach(path ${ARGN})
    glob_path(${path})
    ans(res)
    list(APPEND result ${res})
  endforeach()
  return_ref(result)
 endfunction()


# File: source/filesystem/globbing/glob_up.cmake

# applies the glob expressions (passed as varargs)
# to the first n parent directories starting with the current dir
# order of result is in deepest path first
# 0 searches parent paths up to root
# warning do not use --recurse and unlimited depth as it would probably take forever
# @todo extend to quit search when first result is found
function(glob_up n)
  set(args ${ARGN})

  # extract dir
  set(path)
  path("${path}")
  ans(path)

  set(globs ${args})

  # /tld is appended because only its parent dirs are gotten 
  path_parent_dirs("${path}/tld" ${n})
  ans(parent_dirs)

  set(all_matches)
  foreach(parent_dir ${parent_dirs})
    glob("${parent_dir}" ${globs})
    ans(matches)
    list(APPEND all_matches ${matches})
  endforeach()
  return_ref(all_matches)
endfunction()


# File: source/filesystem/globbing/ls.cmake

## `(<?path>)-> <qualified path...>`
##
## returns a list of files and folders in the specified directory
##
function(ls)
  path("${ARGN}")
  ans(path)

  if(IS_DIRECTORY "${path}")
    set(path "${path}/*")
  endif()

  file(GLOB files "${path}")
  return_ref(files)
endfunction()




# File: source/filesystem/home_dir.cmake

## `()-><qualified path>`
##
## returns the current users home directory on all OSs
## 
function(home_dir)
    shell_get()
    ans(shell)
    if ("${shell}" STREQUAL "cmd")
        shell_env_get("HOMEDRIVE")
        ans(dr)
        shell_env_get("HOMEPATH")
        ans(p)
        set(res "${dr}${p}")
        file(TO_CMAKE_PATH "${res}" res)
        path("${res}")
        ans(res)
    elseif ("${shell}" STREQUAL "bash")
        shell_env_get(HOME)
        ans(res)
    else ()
        message(FATAL_ERROR "supported shells: cmd & bash")
    endif ()
    eval("
    function(home_dir)
      set(__ans \"${res}\" PARENT_SCOPE)
    endfunction()
      ")
    return_ref(res)
endfunction()


# File: source/filesystem/is_temp_file.cmake

##
## 
## returns true if the specified file is a temp file (created by fwrite_temp)
function(is_temp_file file)
  if("${file}" MATCHES ".*\\/fwrite_temp[^ ]*")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/filesystem/ln.cmake

## `(<target:<path>> <link:<path>>?)-><bool>` 
##
## creates a symlink from `<link>` to `<target>` on all operating systems
## (Windows requires NTFS filesystem)
## if `<link>` is omitted then the link will be created in the local directory 
## with the same name as the target
##
function(ln)
  wrap_platform_specific_function(ln)
  ln(${ARGN})
  return_ans()
endfunction()



function(ln_Linux target)
   set(args ${ARGN})

  path_qualify(target)

  list_pop_front(args)
  ans(link)
  if("${link}_" STREQUAL "_")
    get_filename_component(link "${target}" NAME )
  endif()

  path_qualify(link)
  execute_process(COMMAND ln -s "${target}" "${link}" RESULT_VARIABLE error ERROR_VARIABLE stderr)
  if(error)
    creturn(false)
  endif() 
  creturn(true)
endfunction()


function(ln_Windows target)
  set(args ${ARGN})

  path_qualify(link)

  list_pop_front(args)
  ans(link)

  if("${link}_" STREQUAL "_")
    get_filename_component(link "${target}" NAME )
  endif()

  path_qualify(target)


  if(EXISTS "${target}" AND NOT IS_DIRECTORY "${target}")
    set(flags "/H")
  else()
    set(flags "/D" "/J")
  endif()
  string(REPLACE "/" "\\" link "${link}")
  string(REPLACE "/" "\\" target "${target}")

 # print_vars(link target flags)
  win32_cmd_lean("/C" "mklink" ${flags} "${link}" "${target}")
  ans_extract(error)
  if(error)
    creturn(false)
  endif()
  creturn(true)
endfunction()




# File: source/filesystem/mime_type/mime_type.cmake

## returns the file type for the specified file
## only existing files can have a file type
## if an existing file does not have a specialized file type
## the extension is returned
function(mime_type file)
  path_qualify(file)

  if(NOT EXISTS "${file}")
    #message("no file")
    creturn(false)
  endif()

  if(IS_DIRECTORY "${file}")
   # message("is dir")
    creturn(false)
  endif()


  mime_type_from_file_content("${file}")
  ans(mime_type)

  if(mime_type)
    return_ref(mime_type)
  endif()



  mime_type_from_filename("${file}")
  ans(mime_type)


  return_ref(mime_type)
  
endfunction()


# File: source/filesystem/mime_type/mime_type_from_extension.cmake

## mime_type_from_extension()->
##
## returns the mime type or types matching the specified file extension
##
function(mime_type_from_extension extension)

    if (${extension} MATCHES "\\.(.*)")
        set(extension "${CMAKE_MATCH_1}")
    endif ()

    string(TOLOWER "${extension}" extension)

    mime_type_map()
    ans(mime_types)

    map_tryget("${mime_types}" "${extension}")
    ans(mime_types)

    set(mime_type_names)
    foreach (mime_type ${mime_types})
        map_tryget("${mime_type}" name)
        ans(mime_type_name)
        list(APPEND mime_type_names "${mime_type_name}")
    endforeach ()

    return_ref(mime_type_names)
endfunction()



# File: source/filesystem/mime_type/mime_type_from_file_content.cmake



function(mime_type_from_file_content file)
  path_qualify(file)
  if(NOT EXISTS "${file}")
    creturn()
  endif()


  file_isserializedcmakefile("${file}")
  ans(is_serializedcmake)
  if(is_serializedcmake)
    creturn("application/x-serializedcmake")
  endif()


  file_isqmfile("${file}")
  ans(is_qm)
  if(is_qm)
    creturn("application/x-quickmap")
  endif()

  file_isjsonfile("${file}")
  ans(is_json)
  if(is_json)
    creturn("application/json")
  endif()



  file_istarfile("${file}")
  ans(is_tar)
  if(is_tar)
    creturn("application/x-gzip")
  endif()


  creturn()
endfunction()

# File: source/filesystem/mime_type/mime_type_from_filename.cmake

## mime_type_from_filename() -> 
##
## returns the mimetype for the specified filename
##
##
function(mime_type_from_filename file)
  get_filename_component(extension "${file}" EXT)  
  if("${extension}" MATCHES "([^\\.]+)$")
    set(extension "${CMAKE_MATCH_1}")
  endif()
  mime_type_from_extension("${extension}")
  return_ans()
endfunction()

# File: source/filesystem/mime_type/mime_type_get.cmake



## returns the mimetyoe object for the specified name or extension
function(mime_type_get name_or_ext)
  mime_type_map()
  ans(mm)
  map_tryget("${mm}" "${name_or_ext}")
  return_ans()
endfunction()

# File: source/filesystem/mime_type/mime_type_get_extension.cmake



function(mime_type_get_extension mime_type)
    mime_type_get("${mime_type}")
    ans(mt)
    map_tryget("${mt}" extensions)
    ans(extensions)
    list_pop_front(extensions)
    ans(res)
    return_ref(res)

creturn()
  if(mime_type STREQUAL "application/cmake")
    creturn("cmake")
  elseif(mime_type STREQUAL "application/json")
    creturn("json")
  elseif(mime_type STREQUAL "application/x-quickmap")
    creturn("qm")
  elseif(mime_type STREQUAL "application/x-gzip")
    creturn("tgz")
  elseif(mime_type STREQUAL "text/plain")
    creturn("txt")
  endif()

  creturn()
endfunction()

# File: source/filesystem/mime_type/mime_type_map.cmake



## returns a map of known mime types
function(mime_type_map)
  map_new()
  ans(mime_type_map)
  map_set(global mime_types "${mime_type_map}")

  function(mime_type_map)
    map_tryget(global mime_types)
    return_ans()
  endfunction()

  mime_types_register_default()



  mime_type_map()
  return_ans()
endfunction()

# File: source/filesystem/mime_type/mime_type_register.cmake



## https://www.ietf.org/rfc/rfc2045.txt
function(mime_type_register mime_type)
  data("${mime_type}")
  ans(mime_type)

  map_tryget("${mime_type}" name)
  ans(name)
  if(name STREQUAL "")
    creturn()
  endif()

  mime_type_map()
  ans(mime_types)

  map_tryget("${mime_types}" "${name}")
  ans(existing_mime_type)
  if(existing_mime_type)
    message(FATAL_ERROR "mime_type ${name} already exists")
  endif()

  map_tryget("${mime_type}" extensions)
  ans(extensions)


  foreach(key ${name} ${extensions})
    map_append(${mime_types} "${key}" "${mime_type}")
  endforeach()

  return_ref(mime_type)

endfunction()



# File: source/filesystem/mime_type/mime_type_register_default.cmake


function(mime_types_register_default)
  mime_type_register("{
      name:'application/x-gzip',
      description:'',
      extensions:['tgz','gz','tar.gz']
  }")
  mime_type_register("{
      name:'application/zip',
      description:'',
      extensions:['zip']
  }")

  mime_type_register("{
      name:'application/x-serializedcmake',
      description:'',
      extensions:['cmake','scmake']
  }")

  mime_type_register("{
      name:'application/x-7z-compressed',
      description:'',
      extensions:['7z']
  }")

  mime_type_register("{
      name:'text/plain',
      description:'',
      extensions:['txt','asc']
  }")


  mime_type_register("{
      name:'application/x-quickmap',
      description:'CMake Quickmap Object Notation',
      extensions:['qm']
  }")



  mime_type_register("{
      name:'application/json',
      description:'JavaScript Object Notation',
      extensions:['json']
  }")



  mime_type_register("{
      name:'application/x-cmake',
      description:'CMake Script File',
      extensions:['cmake']
  }")



  mime_type_register("{
      name:'application/xml',
      description:'eXtensible Markup Language',
      extensions:['xml']
  }")


endfunction()

# File: source/filesystem/navigation/cd.cmake

# changes the current directory 
function(cd)
  set(args ${ARGN})
  list_extract_flag(args --create)
  ans(create)
  list_extract_flag(args --force)
  ans(force)
  path("${args}")
  ans(path)
 # message("cd ${path}")
  if(NOT IS_DIRECTORY "${path}" AND NOT force)
    if(NOT create)
      message(FATAL_ERROR "directory '${path}' does not exist")
      creturn()
    endif()
    mkdir("${path}")
  endif()
  address_set(__global_cd_current_directory "${path}")

  return_ref(path)
endfunction()

# File: source/filesystem/navigation/dirs.cmake

# returns all directories currently on directory stack
# also see pushd popd
function(dirs)
  stack_enumerate(__global_push_d_stack)
  ans(res)
  return_ref(res)
endfunction()

# File: source/filesystem/navigation/popd.cmake

# replaces the current working directory with
# the top element of the directory stack_pop and
# removes the top element
function(popd)
  stack_pop(__global_push_d_stack)
  ans(pwd)

  cd("${pwd}" ${ARGN})
  return_ans()
endfunction()


# File: source/filesystem/navigation/poptmp.cmake

##
##
## removes the current path from the path stack
## delets the temporary directory
function(poptmp)
  pwd()
  ans(pwd)
  if(NOT "${pwd}" MATCHES "mktemp")
    message(FATAL_ERROR "cannot poptmp - path ${pwd} is not temporary ")
  endif() 
  rm(-r "${pwd}")
  popd()
  return_ans()
endfunction()

# File: source/filesystem/navigation/pushd.cmake

# pushes the specfied directory (or .) onto the 
# directory stack
function(pushd)
  pwd()
  ans(pwd)
  stack_push(__global_push_d_stack "${pwd}")
  if(ARGN)
    cd(${ARGN})
    return_ans()
  endif()
  return_ref(pwd)
endfunction()

# File: source/filesystem/navigation/pushtmp.cmake

## `(<?parent dir>)-><qualified path>, path_stack is pushed`
##
## pushes a temporary directory on top of the pathstack 
function(pushtmp)
  mktemp(${ARGN})
  ans(dir)
  pushd("${dir}")
  return_ans()
endfunction()


# File: source/filesystem/navigation/pwd.cmake

# returns the current working directory
  function(pwd)
    address_get(__global_cd_current_directory)
    return_ans()
  endfunction()


# File: source/filesystem/operations/cp.cmake

# copies the specified path to the specified target
# if last argument is a existing directory all previous files will be copied there
# else only two arguments are allow source and target
# cp(<sourcefile> <targetfile>)
# cp([<sourcefile> ...] <existing targetdir>)
function(cp)
    set(args ${ARGN})
    list_pop_back(args)
    ans(target)

    list_length(args)
    ans(len)
    path("${target}")
    ans(target)
    # single move

    if (NOT IS_DIRECTORY "${target}")
        if (NOT "${len}" EQUAL "1")
            message(FATAL_ERROR "wrong usage for cp() exactly one source file needs to be specified")
        endif ()
        path("${args}")
        ans(source)
        # this just has to be terribly slow...
        # i am missing a direct
        cmake_lean(-E "copy" "${source}" "${target}")
        ans_extract(error)
        if (error)
            message("failed to copy ${source} to ${target}")
        endif ()
        creturn()
    endif ()

    paths(${args})
    ans(paths)
    file(COPY ${paths} DESTINATION "${target}")

    creturn()
endfunction()



# File: source/filesystem/operations/cp_content.cmake

  ## cp_content(<source dir> <target dir> <glob ignore expression...>) -> <path...> 
  ## 
  ## copies the content of source dir to target_dir respecting 
  ## the globging expressions if none are given
  ## returns the copied paths if globbing expressiosnw were used
  ## else returns the qualified target_dir
  function(cp_content source_dir target_dir)

    path_qualify(target_dir)
    path_qualify(source_dir)
    set(content_globbing_expression ${ARGN})
    if(NOT content_globbing_expression)
      cp_dir("${source_dir}" "${target_dir}")
      ans(res)
    else()
        pushd("${source_dir}")
            cp_glob("${target_dir}" ${content_globbing_expression})
            ans(res)
        popd()
    endif()
    return_ref(res)
  endfunction()

# File: source/filesystem/operations/cp_dir.cmake

## copies the contents of source_dir to target_dir
function(cp_dir source_dir target_dir)
  path_qualify(source_dir)
  path_qualify(target_dir)
  cmake(-E copy_directory "${source_dir}" "${target_dir}" --exit-code)
  ans(error)
  if(error)
    message(FATAL_ERROR "failed to copy contents of '${source_dir}' to '${target_dir}' this often happens when file names are too long ")
  endif()
  return_ref(target_dir)
endfunction()


# File: source/filesystem/operations/cp_glob.cmake


  ## cp_glob(<target dir> <glob. ..> )-> <path...>
  ##
  ## 
  function(cp_glob target_dir)
    set(args ${ARGN})
    
    list_extract_flag_name(args --recurse)
    ans(recurse)

    path_qualify(target_dir)

    glob_ignore(--relative ${args} ${recurse})
    ans(paths)

    pwd()
    ans(pwd)

    foreach(path ${paths})
      path_component(${path} --parent-dir)
      ans(relative_dir)
      file(COPY "${pwd}/${path}" DESTINATION "${target_dir}/${relative_dir}")
     
    endforeach()
    return_ref(paths)
  endfunction()

# File: source/filesystem/operations/mkdir.cmake

# creates a new directory
function(mkdir path)    
  path("${path}")
  ans(path)
  file(MAKE_DIRECTORY "${path}")
  event_emit(on_mkdir "${path}")
  return_ref(path)
endfunction()



# File: source/filesystem/operations/mkdirs.cmake

# creates all specified dirs
function(mkdirs)
  set(res)
  foreach(path ${ARGN})
    mkdir("${path}")
    ans(p)
    list(APPEND res "${p}")    
  endforeach()
  return_ref(res)
endfunction()




# File: source/filesystem/operations/mktemp.cmake

# creates a temporary directory 
# you can specify an optional parent directory in which it should be created
# usage: mktemp([where])-> <absoute path>
function(mktemp)
  path_temp(${ARGN})
  ans(path)
  mkdir("${path}")
  return_ref(path)
endfunction()


# File: source/filesystem/operations/mv.cmake

# moves the specified path to the specified target
# if last argument is a existing directory all previous files will be moved there
# else only two arguments are allow source and target
# mv(<sourcefile> <targetfile>)
# mv([<sourcefile> ...] <existing targetdir>)
function(mv)
  set(args ${ARGN})
  list_pop_back(args)
  ans(target)

  list_length(args)
  ans(len)
  path("${target}")
  ans(target)
  # single move
  if(NOT IS_DIRECTORY "${target}" )
    if(NOT "${len}" EQUAL "1")
      message(FATAL_ERROR "wrong usage for mv() exactly one source file needs to be specified")
    endif()
    path("${args}")
    ans(source)
    file(RENAME "${source}" "${target}")
    creturn()
  endif()

  foreach(source ${args})
    path_file_name("${source}")
    ans(fn)
    mv("${source}" "${target}/${fn}")
  endforeach()

  creturn()
endfunction()


# File: source/filesystem/operations/rm.cmake

# removes the specified paths if -r is passed it will also remove subdirectories
# rm([-r] [<path> ...])
# files names are qualified using pwd() see path()
function(rm)
  set(args ${ARGN})
  list_extract_flag(args -r)
  ans(recurse)
  paths("${args}")
  ans(paths)
  set(cmd)
  if(recurse)
    set(cmd REMOVE_RECURSE)
  else()
    set(cmd REMOVE)
  endif()

  file(${cmd} "${paths}")
  creturn()
endfunction()



# File: source/filesystem/operations/touch.cmake

# creates a file or updates the file access time
# *by appending an empty string
function(touch path)

  #if("${CMAKE_MAJOR_VERSION}" LESS 3)
    function(touch path)

      path("${path}")
      ans(path)

      set(args ${ARGN})
      list_extract_flag(args --nocreate)
      ans(nocreate)

      if(NOT EXISTS "${path}" AND nocreate)
        return_ref(path)
      elseif(NOT EXISTS "${path}")
        file(WRITE "${path}" "")        
      else()
        file(APPEND "${path}" "")
      endif()


      return_ref(path)

    endfunction()
  touch("${path}")
  return_ans()
endfunction()



# File: source/filesystem/path/path.cmake

## `(<path>)-><qualified path>`
##
## returns the fully qualified path name for path
## if path is a fully qualified name it returns path
## else path is interpreted as the relative path 
function(path path)
  pwd()
  ans(pwd)
  path_qualify_from("${pwd}" "${path}")
  return_ans()
endfunction()




# File: source/filesystem/path/path_combine.cmake


  # combines all dirs to a single path  
  function(path_combine )
    set(args ${ARGN})
    list_to_string(args "/")
    ans(path)
    return_ref(path)
  endfunction()

# File: source/filesystem/path/path_component.cmake

# returns the specified path component for the passed path
# posibble components are
# --file-name NAME_WE
# --file-name-ext NAME
# --parent-dir PATH
# @todo: create own components 
# e.g. parts dirs extension etc. consider creating an uri type
function(path_component path path_component)
  if("${path_component}" STREQUAL "--parent-dir")
    set(path_component PATH)
  elseif("${path_component}" STREQUAL "--file-name")
    set(path_component NAME_WE)
  elseif("${path_component}" STREQUAL "--file-name-ext")
    set(path_component NAME)
  endif()
  get_filename_component(res "${path}" "${path_component}")
  return_ref(res)
endfunction()





# File: source/filesystem/path/path_extension.cmake

## `(<path>)-><string>`
## 
## retuns the extension of the specified path
## 
function(path_extension path)
  path("${path}")
  ans(path)
  get_filename_component(res "${path}" EXT)
  return_ref(res)  
endfunction()

# File: source/filesystem/path/path_file_name.cmake

# returns the name of the file without the directory
# if -we is specified the extensions is dropped
function(path_file_name path)
  set(args ${ARGN})
  list_extract_flag(args -we)
  ans(without_extension)
  if(without_extension)
    set(cmd NAME_WE)
  else()
    set(cmd NAME)
  endif() 
  path("${path}")
  ans(path)
  get_filename_component(res "${path}" ${cmd})
  return_ref(res)
endfunction()

# File: source/filesystem/path/path_issubdir.cmake

## `(<subdir:<path>> <?path> )-><bool>`
##
## returns true iff subdir is or is below path
function(path_issubdir subdir path)
  set(path ${ARGN})
  path_qualify(path)
  path_qualify(subdir)
  string_starts_with("${subdir}" "${path}")
  return_ans()
endfunction()


# File: source/filesystem/path/path_parent_dir.cmake

## `(<path>)-><qualified path>` 
##
## returns the parent directory of the specified file or folder
## 
function(path_parent_dir path)
  path_qualify(path)
  get_filename_component(res "${path}" PATH)
  return_ref(res)
endfunction()

# File: source/filesystem/path/path_parent_dir_name.cmake

## `(<path>)-><segment>` 
## 
## returns the name of the directory in which the specified file or folder resides
function(path_parent_dir_name)
  path("${ARGN}")
  ans(path)
  path_parent_dir("${path}")
  ans(path)
  path_component("${path}" --file-name-ext)
  return_ans()
endfunction()

# File: source/filesystem/path/path_parent_dirs.cmake

# returns the specified max n (all if n = 0)
# parent directories of path
function(path_parent_dirs path)
  set(continue 99999)
  if(ARGN )
    set(continue "${ARGN}")

    if("${continue}" EQUAL 0)
      set(continue 99999)
    endif()
  endif()

  path("${path}")
  ans(path)

  set(isrooted false)
  if("_${path}" MATCHES "^_[/]")
    set(isrooted true)
  endif()

  path_split("${path}")
  ans(parts)


  set(parent_dirs)
  while(true)
    if(NOT parts OR ${continue} LESS 1)
      break()
    endif()
    list_pop_back(parts)
    path_combine(${parts})
    ans(current)      

    if(isrooted)
      set(current "/${current}")
    endif()
    
    if("_${current}" STREQUAL "_")
      break()
    endif()
    list(APPEND parent_dirs "${current}")
    math(EXPR continue "${continue} - 1")

  endwhile()
  return_ref(parent_dirs)
endfunction()



# File: source/filesystem/path/path_qualify.cmake


## qualifies the specified variable as a path and sets it accordingly
macro(path_qualify __path_ref)
  path("${${__path_ref}}")
  ans(${__path_ref})
endmacro()


# File: source/filesystem/path/path_qualify_from.cmake

## `(<base_dir:<qualified path>> <~path>) -> <qualified path>`
##
## @todo realpath or abspath?
## qualfies a path using the specified base_dir
##
## if path is absolute (starts with / or under windows with <drive letter>:/) 
## it is returned as is
##
## if path starts with a '~' (tilde) the path is 
## qualfied by prepending the current home directory (on all OSs)
##
## is neither absolute nor starts with ~
## the path is relative and it is qualified 
## by prepending the specified <base dir>
function(path_qualify_from base_dir path)
    string(REPLACE \\ / path "${path}")
    get_filename_component(realpath "${path}" ABSOLUTE)

#!!!
    
    if (CMAKE_HOST_WIN32)
        ## windows absolute path
        if("_${path}" MATCHES "^_[a-zA-Z]:\\/")
            return_ref(realpath)
        endif ()
    else()
        ## posix absolute path
        if ("_${path}" MATCHES "^_\\/")
            return_ref(realpath)
        endif ()
    endif()

    

    ## home path
    if ("_${path}" MATCHES "^_~\\/?(.*)")
        home_dir()
        ans(base_dir)
        set(path "${CMAKE_MATCH_1}")
    endif ()

    set(path "${base_dir}/${path}")

    ## relative path
    get_filename_component(realpath "${path}" ABSOLUTE)

#!!!

    return_ref(realpath)
endfunction()

# File: source/filesystem/path/path_relative.cmake

# returns the path specified by path_rel relative to 
# path_base using parent dir path syntax (../../path/to/x)
# if necessary
# e.g. path_rel(c:/dir1/dir2 c:/dir1/dir3/dir4)
# will result in ../dir3/dir4
# returns nothing if transformation is not possible
function(path_relative path_base path_rel)
    set(args ${ARGN})

    path_qualify(path_base)
    path_qualify(path_rel)

    if ("${path_base}" STREQUAL "${path_rel}")
        creturn(".")
    endif ()

    path_split("${path_base}")
    ans(base_parts)

    path_split("${path_rel}")
    ans(rel_parts)

    set(result_base)

    set(first true)

    while (true)
        list_peek_front(base_parts)
        ans(current_base)
        list_peek_front(rel_parts)
        ans(current_rel)

        if (NOT "${current_base}" STREQUAL "${current_rel}")
            if (first)
                return_ref(path_rel)
            endif ()
            break()
        endif ()
        set(first false)

        path_combine("${result_base}" "${current_base}")
        ans(result_base)
        list_pop_front(base_parts)
        list_pop_front(rel_parts)
    endwhile ()

    set(result_path)

    foreach (base_part ${base_parts})
        path_combine(${result_path} "..")
        ans(result_path)
    endforeach ()

    path_combine(${result_path} ${rel_parts})
    ans(result_path)

    if ("${result_path}" MATCHES "^\\/")
        string_substring("${result_path}" 1)
        ans(result_path)
    endif ()

    return_ref(result_path)
endfunction()

# transforms a path to a path relative to base_dir
#function(path_relative base_dir path)
#  path("${base_dir}")
#  ans(base_dir)
#  path("${path}")
#  ans(path)
#  string_take(path "${base_dir}")
#  ans(match)
#
#  if(NOT match)
#    return_ref(path)
#    #message(FATAL_ERROR "${path} is  not relative to ${base_dir}")
#  endif()
#
#  if("${path}" MATCHES "^\\/")
#    string_substring("${path}" 1)
#    ans(path)
#  endif()
#
#
#  if(match AND NOT path)
#    set(path ".")
#  endif()
#
#  return_ref(path)
#endfunction()
#

# File: source/filesystem/path/path_replace_relative.cmake


# replaces all fully qualified paths with a path relative to 
# specified path (using .. to navigate upward)
function(path_replace_relative path)
    set(args ${ARGN})

    set(parentDirs ".")
    path("${path}")
    ans(current_path)
    
    while(true)            
        string(REPLACE "${current_path}" "${parentDirs}" args ${args})
        path_parent_dir("${current_path}")
        ans(next_path)

        if("${current_path}_" STREQUAL "${next_path}_")
            return_ref(args)
        endif()

        set(current_path "${next_path}")


        if("${parentDirs}" STREQUAL ".")
            set(parentDirs "..")
        else()
            set(parentDirs "${parentDirs}/..")
        endif()
    endwhile()
    
endfunction()

# File: source/filesystem/path/path_split.cmake


  # splits the speicifed path into its directories and files
  # e.g. c:/dir1/dir2/file.ext -> ['c:','dir1','dir2','file.ext'] 
  function(path_split path)
    if("_${path}" MATCHES "^_[\\/]")
      string_substring("${path}" 1)
      ans(path)
    endif()
    string_split("${path}" "[/]")
    ans(parts)

    return_ref(parts)
  endfunction()

# File: source/filesystem/path/path_temp.cmake

## returns a temporary path in the specified directory
## if no directory is given the global temp_dir is used isntead
function(path_temp)
  set(args ${ARGN})

  if("${args}_" STREQUAL "_")
    cmakepp_config(temp_dir)
    ans(tmp_dir)
    set(args "${tmp_dir}")
  else()
    path("${args}")
    ans(args)
  endif()

  path_vary("${args}/mktemp")
  ans(path)

  return_ref(path)
endfunction()

# File: source/filesystem/path/path_to_map.cmake


# writes the path the map creating submaps for every directory

function(path_to_map map path)
  
  path_split("${path}")
  ans(path_parts)

  set(current ${map})
  while(true)
    list_pop_front(path_parts)
    ans(current_part)


    
    map_tryget(${current} "${current_part}")
    ans(current_map)

    if(NOT path_parts)
      if(NOT current_map)
      map_set(${current} "${current_part}" "${path}")
      endif()
      creturn()
    endif()

    is_map("${current_map}")
    ans(ismap)

    if(NOT ismap)
      map_new()
      ans(current_map)
    endif()

    map_set(${current} "${current_part}" ${current_map})
    set(current ${current_map})
  endwhile()
endfunction()

# File: source/filesystem/path/path_vary.cmake

## `(<path>)-><qualified path>`
##
## varies the specified path until it does not exist
## this is done  by inserting a random string into the path and doing so until 
## a path is vound whic does not exist
function(path_vary path)
  path_qualify(path)
  get_filename_component(ext "${path}" EXT)
  get_filename_component(name "${path}" NAME_WE)
  get_filename_component(base "${path}" PATH)
  set(rnd)
  while(true)
    set(path "${base}/${name}${rnd}${ext}")
    
    if(NOT EXISTS "${path}")
      creturn("${path}")
    endif()


    ## alternatively count up
    string(RANDOM rnd)
    set(rnd "_${rnd}")

  endwhile()
endfunction()

# File: source/filesystem/path/paths.cmake


# qualify multiple paths (argn)
function(paths)
  set(res)
  foreach(path ${ARGN})
    path("${path}")
    ans(path)
    list(APPEND res ${path})
  endforeach()
  return_ref(res)
endfunction()

# File: source/filesystem/path/paths_make_relative.cmake

# makes all paths passed as varargs into paths relative to base_dir
function(paths_make_relative base_dir)
  set(res)
  get_filename_component(base_dir "${base_dir}" ABSOLUTE)

  foreach(path ${ARGN})
    path_qualify(path)
    file(RELATIVE_PATH path "${base_dir}" "${path}")
    list(APPEND res "${path}")
  endforeach()

  return_ref(res)
endfunction()





# File: source/filesystem/path/paths_relative.cmake



function(paths_relative path_base)
  set(res)
  foreach(path ${ARGN})
    path_relative("${path_base}" "${path}")
    ans(c)
    list(APPEND res "${c}")
  endforeach()
  return_ref(res)
endfunction()

# File: source/filesystem/path/paths_to_map.cmake


# converts the varargs list of pahts to a map
function(paths_to_map )
  map_new()
  ans(map)
  foreach(path ${ARGN})
    path_to_map("${map}" "${path}")
  endforeach()
  return_ref(map)
endfunction()


# File: source/filesystem/unlink.cmake

## `(<path>)-><bool>`
## 
## unlinks the specified link without removing the links content.
function(unlink)
  wrap_platform_specific_function(unlink)
  unlink(${ARGN})
  return_ans()
endfunction()



function(unlink_Windows symlink)
  path_qualify(symlink)
  string(REPLACE "/" "\\" symlink "${symlink}") 
  win32_cmd_lean("/C" "rmdir" "${symlink}")
  ans_extract(res)
  if(res)
    creturn(false)
  endif()
  creturn(true)
endfunction()


function(unlink_Linux symlink)
  path_qualify(symlink)
  if("${symlink}" MATCHES "(.*)\\/$")
    set(symlink "${CMAKE_MATCH_1}")
  endif()
  execute_process(COMMAND "unlink" "${symlink}" RESULT_VARIABLE res)
  if(res)
    creturn(false)
  endif()

  creturn(true)
endfunction()

# File: source/formats/cmake/cmake_deserialize.cmake



  function(cmake_deserialize serialized)
     fwrite_temp("" ".cmake")
  ans(tmp)

    eval("
        function(cmake_deserialize serialized)
            file(WRITE \"${tmp}\" \"\${serialized}\")
            cmake_deserialize_file(\"${tmp}\")
            set(__ans \${__ans} PARENT_SCOPE)
        endfunction()
    ")
    cmake_deserialize("${serialized}")
    return_ans()
  endfunction()


# File: source/formats/cmake/cmake_deserialize_file.cmake

function(cmake_deserialize_file file)
  if(NOT EXISTS "${file}")
    creturn()
  endif()
   address_new()
   ans(result)
   include("${file}")
   address_get(${result})
   return_ans()
endfunction()

# File: source/formats/cmake/cmake_read.cmake


function(cmake_read path)
  path_qualify(path)
  cmake_deserialize_file("${path}")
  return_ans()
endfunction()

# File: source/formats/cmake/cmake_serialize.cmake


  function(cmake_serialize)
      function(cmake_ref_format)
        set(prop)
        if(ARGN)
          set(prop ".${ARGN}")
        endif()
        set(__ans ":\${ref}${prop}" PARENT_SCOPE)
      endfunction()

     # define callbacks for building result
    function(cmake_obj_begin)
      map_tryget(${context} ${node})
      ans(ref)
      map_push_back(${context} refstack ${ref})
      map_append_string(${context} qm 
"math(EXPR ref \"\${base} + ${ref}\")
set_property(GLOBAL PROPERTY \":\${ref}.__keys__\" \"\")
")
    endfunction()

    function(cmake_obj_end)
      map_pop_back(${context} refstack)
      map_peek_back(${context} refstack)
      ans(ref)

      map_append_string(${context} qm 
"math(EXPR ref \"\${base} + ${ref}\")
")
    endfunction()
    
    function(cmake_obj_keyvalue_begin)
      cmake_ref_format()
      ans(keystring)
      cmake_ref_format(${map_element_key})
      ans(refstring)
      
      map_append_string(${context} qm 
"set_property(GLOBAL APPEND PROPERTY \"${keystring}.__keys__\" \"${map_element_key}\")
set_property(GLOBAL PROPERTY \"${refstring}\")
")
    endfunction()

    function(cmake_literal)
      cmake_ref_format(${map_element_key})
      ans(refstring)
      cmake_string_escape("${node}")
      ans(node)
      map_append_string(${context} qm 
"set_property(GLOBAL APPEND PROPERTY \"${refstring}\" \"${node}\")
")
      creturn()
    endfunction()

    function(cmake_unvisited_reference)
      map_tryget(${context} ref_count)
      ans(ref_count)
      math(EXPR ref "${ref_count} + 1")
      map_set_hidden(${context} ref_count ${ref})
      map_set_hidden(${context} ${node} ${ref})

      cmake_ref_format(${map_element_key})
      ans(refstring)

      map_append_string(${context} qm
"math(EXPR value \"\${base} + ${ref}\")
set_property(GLOBAL PROPERTY \":\${value}.__type__\" \"map\")
set_property(GLOBAL APPEND PROPERTY \"${refstring}\" \":\${value}\")
")
    endfunction()
    function(cmake_visited_reference)
map_tryget(${context} "${node}")
ans(ref)

  cmake_ref_format(${map_element_key})
  ans(refstring)
map_append_string(${context} qm
"#revisited node
math(EXPR value \"\${base} + ${ref}\")
set_property(GLOBAL APPEND PROPERTY \"${refstring}\" \":\${value}\")
# end of revisited node
")


    endfunction()
     map()
      kv(value              cmake_literal)
      kv(map_begin          cmake_obj_begin)
      kv(map_end            cmake_obj_end)
      kv(map_element_begin  cmake_obj_keyvalue_begin)
      kv(visited_reference  cmake_visited_reference)
      kv(unvisited_reference  cmake_unvisited_reference)
    end()
    ans(cmake_cbs)
    function_import_table(${cmake_cbs} cmake_callback)

    # function definition
    function(cmake_serialize)        
      map_new()
      ans(context)
      map_set(${context} refstack 0)
      map_set(${context} ref_count 0)
  
      dfs_callback(cmake_callback ${ARGN})
      map_tryget(${context} qm)
      ans(res)
      map_tryget(${context} ref_count)
      ans(ref_count)

      set(res "#cmake/1.0
get_property(base GLOBAL PROPERTY \":0\")
set(ref \${base})
${res}math(EXPR base \"\${base} + ${ref_count} + 1\")
set_property(GLOBAL PROPERTY \":0\" \${base})
")

      return_ref(res)  
    endfunction()
    #delegate
    cmake_serialize(${ARGN})
    return_ans()
  endfunction()


# File: source/formats/cmake/cmake_write.cmake


function(cmake_write path )
    cmake_serialize(${ARGN})
    ans(serialized)
    fwrite("${path}" "${serialized}")
    return_ans()
endfunction()

# File: source/formats/csv/csv_deserialize.cmake

# deserializes a csv string 
# currently expects the first line to be the column headers
# rows are separated by \n or \r\n
# every value is delimited by double quoutes ""
function(csv_deserialize csv) 
  set(args ${ARGN})
  list_extract_flag(args --headers)
  ans(first_line_headers)
  string(REPLACE "\r" "" csv "${csv}")

  string_split("${csv}" "\n")
  ans(lines)
  string(STRIP "${lines}" lines)

  set(res)
  set(headers)
  set(first true)
  set(i 0)
  foreach(line ${lines})
    map_new()
    ans(current_line)
    set(current_headers ${headers})
    while(true)
      string_take_delimited(line)
      ans(val)
      if("${line}_" STREQUAL "_")
        break()
      endif()

      string_take(line ",")
      ans(comma)
        
      if(first)
        if(first_line_headers)
          list(APPEND headers "${val}")
        else()
          list(APPEND headers ${i})            
        endif()
        math(EXPR i "${i} + 1")
      else()
        list_pop_front(current_headers)
        ans(current_header)
        map_set(${current_line} "${current_header}" "${val}")
      endif()

    endwhile()
    if(NOT first)
      list(APPEND res ${current_line})
    elseif(NOT  first_line_headers)
      list(APPEND res ${current_line})
    endif()
    if(first)        
      set(first false)
    endif()

  endforeach()
  return_ref(res)
endfunction()

# File: source/formats/csv/csv_serialize.cmake



  function(csv_serialize )
    set(args ${ARGN})
    message(FATAL_ERROR)

  endfunction()

# File: source/formats/json/json.cmake


function(json)
# define callbacks for building result
  function(json_obj_begin)
    map_append_string(${context} json "{")
  endfunction()
  function(json_obj_end)
    map_append_string(${context} json "}")
  endfunction()
  function(json_array_begin)
    map_append_string(${context} json "[")
  endfunction()
  function(json_array_end)
    map_append_string(${context} json "]")
  endfunction()
  function(json_obj_keyvalue_begin)
    cmake_string_to_json("${map_element_key}")
    ans(map_element_key)
    map_append_string(${context} json "${map_element_key}:")
  endfunction()

  function(json_obj_keyvalue_end)
    math(EXPR comma "${map_length} - ${map_element_index} -1 ")
    if(comma)
      map_append_string(${context} json ",")
    endif()
  endfunction()

  function(json_array_element_end)
    math(EXPR comma "${list_length} - ${list_element_index} -1 ")
    if(comma)
      map_append_string(${context} json ",")
    endif()
  endfunction()
  function(json_literal)
    if(NOT content_length)
      map_append_string(${context} json "null")
    elseif("_${node}" MATCHES "^_((([1-9][0-9]*)([.][0-9]+([eE][+-]?[0-9]+)?)?)|true|false)$")
      map_append_string(${context} json "${node}")
    else()
      cmake_string_to_json("${node}")
      ans(node)
      map_append_string(${context} json "${node}")
    endif()
    creturn()

  endfunction()

   map()
    kv(value              json_literal)
    kv(map_begin          json_obj_begin)
    kv(map_end            json_obj_end)
    kv(list_begin         json_array_begin)
    kv(list_end           json_array_end)
    kv(map_element_begin  json_obj_keyvalue_begin)
    kv(map_element_end    json_obj_keyvalue_end)
    kv(list_element_end   json_array_element_end)
  end()
  ans(json_cbs)
  function_import_table(${json_cbs} json_callback)

  # function definition
  function(json)        
    map_new()
    ans(context)
    dfs_callback(json_callback ${ARGN})
    map_tryget(${context} json)
    return_ans()  
  endfunction()
  #delegate
  json(${ARGN})
  return_ans()
endfunction()

# File: source/formats/json/json2.cmake

function(json2 input)
  
  json2_definition()
  ans(lang)
  language_initialize(${lang})
  address_set(json2_language_definition "${lang}")
  function(json2 input) 
    checksum_string("${input}")   
    ans(ck)
    file_cache_return_hit("${ck}")
    address_get(json2_language_definition)
    ans(lang)
    map_new()
    ans(ctx)
    map_set(${ctx} input "${input}")
    map_set(${ctx} def "json")
    obj_setprototype(${ctx} "${lang}")

    #lang2(output json2 input "${input}" def "json")

    lang(output ${ctx})
    ans(res)
    file_cache_update("${ck}" ${res})
    return_ref(res)
  endfunction()
  json2("${input}")
  return_ans()
endfunction()

# File: source/formats/json/json2_definition.cmake

function(json2_definition)
map()
 key("name")
  val("json2")
 key("phases")
 map()
  key("name")
   val("parse")
  key("function")
   val("parse_string\(/0\ /1\ /2\ /3\ /4\)")
  key("input")
   val("input_ref")
   val("def")
   val("definitions")
   val("parsers")
   val("global")
  key("output")
   val("output")
 end()
 map()
  key("name")
   val("create\ input\ ref")
  key("function")
   val("address_set_new\(/0\)")
  key("input")
   val("input")
  key("output")
   val("input_ref")
 end()
 key("parsers")
 map()
  key("regex")
   val("parse_regex")
  key("match")
   val("parse_match")
  key("sequence")
   val("parse_sequence")
  key("any")
   val("parse_any")
  key("many")
   val("parse_many")
  key("object")
   val("parse_object")
 end()
 key("definitions")
 map()
  key("json")
  map()
   key("parser")
    val("any")
   key("any")
    val("value")
  end()
  key("value")
  map()
   key("parser")
    val("any")
   key("any")
    val("string")
    val("number")
    val("null")
    val("boolean")
    val("object")
    val("array")
  end()
  key("object")
  map()
   key("parser")
    val("object")
   key("begin")
    val("brace_open")
   key("keyvalue")
    val("keyvalue")
   key("end")
    val("brace_close")
   key("separator")
    val("comma")
  end()
  key("keyvalue")
  map()
   key("parser")
    val("sequence")
   key("sequence")
   map()
    key("key")
     val("string")
    key("colon")
     val("/colon")
    key("value")
     val("value")
   end()
  end()
  key("array")
  map()
   key("parser")
    val("many")
   key("begin")
    val("bracket_open")
   key("element")
    val("value")
   key("separator")
    val("comma")
   key("end")
    val("bracket_close")
  end()
  key("string")
  map()
   key("parser")
    val("regex")
   key("regex")
   regex_escaped_string(\" \")
   ans(regex)
   val("${regex}")
    #val("\"\(\([\^\\\"]|\\\\|\(\\\\([\"tnr]\)\)\)*\)\"")
   #key("replace")
   # val("\\\\1")
   key("transform")
    val("json_string_ref_to_cmake")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("number")
  map()
   key("parser")
    val("regex")
   key("regex")
    val("0|[1-9][0-9]*")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("boolean")
  map()
   key("parser")
    val("regex")
   key("regex")
    val("(true|false)")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("null")
  map()
   key("parser")
    val("regex")
   key("regex")
    val("(null)")
   key("replace")
    val("")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("whitespace")
  map()
   key("parser")
    val("regex")
   key("regex")
    val("[\ \n\r\t]+")
  end()
  key("colon")
  map()
   key("parser")
    val("match")
   key("search")
    val(":")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("comma")
  map()
   key("parser")
    val("match")
   key("search")
    val(",")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("brace_open")
  map()
   key("parser")
    val("match")
   key("search")
    val("{")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("brace_close")
  map()
   key("parser")
    val("match")
   key("search")
    val("}")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("bracket_open")
  map()
   key("parser")
    val("match")
   key("search")
    val("[")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
  key("bracket_close")
  map()
   key("parser")
    val("match")
   key("search")
    val("]")
   key("ignore_regex")
    val("[\ \n\r\t]+")
  end()
 end()
end()
return_ans()
endfunction()

# File: source/formats/json/json3.cmake

function(json3_cached)
  define_cache_function(json3_cached json3)
  json3_cached("${ARGN}")
  return_ans()
endfunction()
## 
##
## fast json parser
function(json3 input)
  string_encode_list("${input}")
  ans(input)
  string_codes()
  regex_json()
  string(REGEX MATCHALL "${regex_json_literal}" literals "${input}")
  string(REGEX REPLACE "${regex_json_literal}" "${free_token}" input "${input}" )
  string(REGEX REPLACE "(.)" "\\1;" tokens "${input}")
  address_new()
  ans(base)
  set(ref ${base})
  set(ref_stack)
  #address_new()
  #ans(cmake_serialized)
  while(true)
    list(LENGTH tokens len)
    if(NOT len)
      break()
    endif()
    list(GET tokens 0 token)
    list(REMOVE_AT tokens 0)
    if("${token}" STREQUAL "{")
      list(INSERT ref_stack 0 ${ref})
      map_new()
      ans(value)
      set_property(GLOBAL APPEND_STRING PROPERTY "${ref}" "${value}")
      set(ref ${value})
    elseif("${token}" STREQUAL "}")
      if("${ref}" MATCHES ".[0-9]+\\..+")
        list(GET ref_stack 0 ref)
        list(REMOVE_AT ref_stack 0)
      endif()
      list(GET ref_stack 0 ref)
      list(REMOVE_AT ref_stack 0)
    elseif("${token}" STREQUAL "${free_token}")
      list(GET literals 0 value)
      list(REMOVE_AT literals 0)
      list(GET tokens 0 next_token)
      if("${next_token}" STREQUAL ":" AND NOT "${value}" MATCHES "\".*\"")
        message(FATAL_ERROR "expected key to be a string instead got '${value}'")
      elseif("${next_token}" STREQUAL ":")
        list(REMOVE_AT tokens 0)
        json_string_to_cmake("${value}")
        ans(key)
        list(INSERT ref_stack 0 ${ref})
        set_property(GLOBAL APPEND PROPERTY "${ref}" "${key}")
        set(ref "${ref}.${key}")
      else()
        if("${value}" MATCHES \".*\")
          json_string_to_cmake("${value}")
          ans(value)
          string_decode_list("${value}")
          ans(value)
        elseif("${value}" STREQUAL "null")
          set(value)
        endif()
        set_property(GLOBAL APPEND_STRING PROPERTY "${ref}" "${value}")
      endif()
    elseif("${token}" STREQUAL ":")
      messaGE(FATAL_ERROR "unexpected ':'")
    elseif("${token}" STREQUAL ",")
      if("${ref}" MATCHES ".[0-9]+\\..+")
        list(GET ref_stack 0 ref)
        list(REMOVE_AT ref_stack 0)
      else()
        set_property(GLOBAL APPEND_STRING PROPERTY "${ref}" ";")
      endif()
    elseif("${token}" STREQUAL "${bracket_open_code}")  
      list(INSERT ref_stack 0 ${ref})
      address_new()
      ans(ref)
    elseif("${token}" STREQUAL "${bracket_close_code}")  
      get_property(values GLOBAL PROPERTY "${ref}")
      list(GET ref_stack 0 ref)
      list(REMOVE_AT ref_stack 0)
      set_property(GLOBAL APPEND_STRING PROPERTY "${ref}" "${values}")
    endif()
  endwhile()
  address_get(${base})
  return_ans()
endfunction()



# File: source/formats/json/json4.cmake


function(json4 input)
  string_encode_list("${input}")
  ans(input)
  regex_json()
  string(REGEX MATCHALL "${regex_json_token}" tokens "${input}")
  string(REGEX REPLACE "${regex_json_token}" "" input "${input}" )
  if(NOT "${input}_" STREQUAL "_")
    message(FATAL_ERROR "invalid json - the following could no be tokenized : '${input}'")
  endif()

  map_new()
  ans(result)
  map_set("${result}" value)
  set(current_key value)
  set(is_array object)
  set(current_ref "${result}")
  set(ref_stack)
  set(key_stack)
  set(is_array_stack)
  while(true)
    list(LENGTH tokens length)
    if(NOT length)
      break()
    endif()
    list(GET tokens 0 token)
    list(REMOVE_AT tokens 0)


    if("${token}" MATCHES "^\"(.*)\"$")
      json_string_to_cmake("${token}")
      string_decode_bracket("${__ans}") ## semicolons will stay encoded...
      set_property(GLOBAL APPEND_STRING PROPERTY "${current_ref}.${current_key}" "${__ans}")
    elseif("${token}" MATCHES "^${regex_json_number_token}$")
      ## todo validate number correclty
      set_property(GLOBAL APPEND_STRING PROPERTY "${current_ref}.${current_key}" "${token}")
    elseif("${token}" MATCHES "^${regex_json_bool_token}$")
      set_property(GLOBAL APPEND_STRING PROPERTY "${current_ref}.${current_key}" "${token}")
    elseif("${token}" MATCHES "^${regex_json_null_token}$")
      ## do nothing because json null is empty string in cmake
    elseif("${token}" MATCHES "^(${regex_json_array_begin_token})|(${regex_json_object_begin_token})$")
      list(INSERT ref_stack 0 "${current_ref}")
      list(INSERT key_stack 0 "${current_key}")
      list(INSERT is_array_stack 0 "${is_array}")
      if("${token}" STREQUAL "${regex_json_array_begin_token}")
        set(is_array true)
      else() ## ${token} STREQUAL "${regex-json_object_begin_token}"
        map_new()
        ans(new_ref)
        set_property(GLOBAL APPEND_STRING PROPERTY "${current_ref}.${current_key}" "${new_ref}")
        set(current_key "${free_token}")
        set(current_ref "${new_ref}")
        set(is_array false)
      endif()
    elseif("${token}" MATCHES "^(${regex_json_array_end_token})|(${regex_json_object_end_token})$")
      list(GET ref_stack 0 current_ref)
      list(REMOVE_AT ref_stack 0)
      list(GET key_stack 0 current_key)
      list(REMOVE_AT key_stack 0)
      list(GET is_array_stack 0 is_array)
      list(REMOVE_AT is_array_stack 0)
    elseif("${token}" MATCHES "^${regex_json_separator_token}$")
      if(is_array)
        set_property(GLOBAL APPEND_STRING PROPERTY "${current_ref}.${current_key}" ";")
      else()
        set(current_key "${free_token}")
      endif()
    elseif("${token}" MATCHES "^${regex_json_keyvalue_token}$")
      if("${current_key}" STREQUAL "${free_token}")
        get_property(current_key GLOBAL PROPERTY "${current_ref}.${free_token}")
        set_property(GLOBAL PROPERTY "${current_ref}.${free_token}")
        map_set("${current_ref}" "${current_key}")
      endif()
    #elseif("${token}" MATCHES "^${regex_json_whitespace_token}$") # ignored
    # else()  #error
    endif()



  endwhile()
  map_tryget("${result}" value)
  return_ans()

endfunction()

# File: source/formats/json/json_deserialize.cmake

## `(<json code>)->{}`
##
## deserializes the specified json code. In combination with json there are a few things
## that need mention:
## * semicolons.  If you use semicolons in json then they will be deserialized as
##   ASCII 31 (Unit Separator) which allows cmake to know the difference to the semicolons in a list
##   if you want semicolons to appear in cmake then use a json array. You can always use `string_decode_semicolon()`
##   to obtain the string as it was in json
##   eg. `[1,2,3] => 1;2;3`  `"1;2;3" => 1${semicolon_code}2${semicolon_code}3`
## 
function(json_deserialize json)
  json4("${json}")
  return_ans()
endfunction()

# File: source/formats/json/json_escape.cmake

# function to escape json
function(json_escape value)
	string(REGEX REPLACE "\\\\" "\\\\\\\\" value "${value}")
	string(REGEX REPLACE "\\\"" "\\\\\"" value "${value}")
	string(REGEX REPLACE "\n" "\\\\n" value "${value}")
	string(REGEX REPLACE "\r" "\\\\r" value "${value}")
	string(REGEX REPLACE "\t" "\\\\t" value "${value}")
	string(REGEX REPLACE "\\$" "\\\\$" value "${value}")	
	string(REGEX REPLACE ";" "\\\\\\\\;" value "${value}")
	return_ref(value)
endfunction()

# File: source/formats/json/json_extract_string_value.cmake


## quickly extracts string properties values from a json string
## useful for large json files with unique property keys
function(json_extract_string_value key data)
    regex_escaped_string("\"" "\"")
    ans(regex)

    set(key_value_regex "\"${key}\" *: ${regex}")
    string(REGEX MATCHALL "${key_value_regex}" matches "${data}")
    set(values)
    foreach (match ${matches})
        string(REGEX REPLACE "${key_value_regex}" "\\1" match "${match}")
        list(APPEND values "${match}")
    endforeach ()
    return_ref(values)
endfunction()

# File: source/formats/json/json_format_tokens.cmake

function(json_format_tokens result tokens)
	set(spacing "  ")
	set(level 0)
	set(indentation "")
	macro(set_indent)
		set(indentation)
		if("${level}" GREATER 0)
		math(EXPR range "${level} - 1")
		foreach(i RANGE "${range}")
			set(indentation "${indentation}${spacing}")
		endforeach()
		endif()
	endmacro()
	macro(increase_indent)
		math(EXPR level "${level} + 1")
		set_indent()
	endmacro()


	macro(decrease_indent)
		math(EXPR level "${level} - 1")
		set_indent()
	endmacro()
	set_indent()

	set(indented "${indentation}")
	foreach(token ${tokens})		
		if("${token}" STREQUAL "{")
			increase_indent()
			set(indented "${indented}{\n${indentation}")
		elseif("${token}" STREQUAL "<")
			increase_indent()
			set(indented "${indented}[\n${indentation}")
		elseif("${token}" STREQUAL ",")
			set(indented "${indented},\n${indentation}")
		elseif("${token}" STREQUAL "}")
			decrease_indent()
			set(indented "${indented}\n${indentation}}")
		elseif("${token}" STREQUAL ">")
			decrease_indent()
			set(indented "${indented}\n${indentation}]")
		elseif("${token}" STREQUAL ":")
			set(indented "${indented} : ")
		else()
			if(NOT  "${token}" MATCHES "^\".*")
				set(indented "${indented};")
			endif()

			json_escape( "${token}")
			ans(token)
			set(indented "${indented}${token}")
		endif()



	endforeach()
	return_value("${indented}")
endfunction()

# File: source/formats/json/json_indented.cmake


function(json_indented)
  # define callbacks for building result
  function(json_obj_begin_indented)
   # message(PUSH_AFTER "json_obj_begin_indented(${ARGN})")
    map_tryget(${context} indentation)
    ans(indentation)
    map_append_string(${context} json "{\n")
    map_append_string(${context} indentation " ")
  endfunction()
  function(json_obj_end_indented)
    #message(POP "json_obj_end_indented(${ARGN})")
    map_tryget(${context} indentation)
    ans(indentation)
    string(SUBSTRING "${indentation}" 1 -1 indentation)
    map_set(${context} indentation "${indentation}")
    map_append_string(${context} json "${indentation}}")

  endfunction()
  function(json_array_begin_indented)
    #message(PUSH_AFTER "json_array_begin_indented(${ARGN}) ${context}")
    map_tryget(${context} indentation)
    ans(indentation)
    map_append_string(${context} json "[\n")
    map_append_string(${context} indentation " ")
    
  endfunction()
  function(json_array_end_indented)
   # message(POP "json_array_end_indented(${ARGN}) ${context}")
    map_tryget(${context} indentation)
    ans(indentation)
    string(SUBSTRING "${indentation}" 1 -1 indentation)
    map_set(${context} indentation "${indentation}")
    map_append_string(${context} json "${indentation}]")
  endfunction()
  function(json_obj_keyvalue_begin_indented)
   # message("json_obj_keyvalue_begin_indented(${key} ${ARGN}) ${context}")
    map_tryget(${context} indentation)
    ans(indentation)
    map_append_string(${context} json "${indentation}\"${map_element_key}\":")
  endfunction()

  function(json_obj_keyvalue_end_indented)
    #message("json_obj_keyvalue_end_indented(${ARGN}) ${context}")
    math(EXPR comma "${map_length} - ${map_element_index} -1 ")
    if(comma)
      map_append_string(${context} json ",")
    endif()
    
    map_append_string(${context} json "\n")
  endfunction()

  function(json_array_element_begin_indented)
   # message("json_array_element_begin_indented(${ARGN}) ${context}")
    map_tryget(${context} indentation)
    ans(indentation)
    map_append_string(${context} json "${indentation}")
  endfunction()
  function(json_array_element_end_indented)
   #message("json_array_element_end_indented(${ARGN}) ${context}")
    math(EXPR comma "${list_length} - ${list_element_index} -1 ")
    if(comma)
      map_append_string(${context} json ",")
    endif()
    map_append_string(${context} json "\n")
  endfunction()
  function(json_literal_indented)
    if(NOT content_length)
      map_append_string(${context} json "null")
    elseif("_${node}" MATCHES "^_(0|(([1-9][0-9]*)([.][0-9]+([eE][+-]?[0-9]+)?)?)|(true)|(false))$")
      map_append_string(${context} json "${node}")
    else()
      cmake_string_to_json("${node}")
      ans(node)
      map_append_string(${context} json "${node}")
    endif()
    creturn()
  endfunction()

   map()
    kv(value              json_literal_indented)
    kv(map_begin          json_obj_begin_indented)
    kv(map_end            json_obj_end_indented)
    kv(list_begin         json_array_begin_indented)
    kv(list_end           json_array_end_indented)
    kv(map_element_begin  json_obj_keyvalue_begin_indented)
    kv(map_element_end    json_obj_keyvalue_end_indented)
    kv(list_element_begin json_array_element_begin_indented)
    kv(list_element_end   json_array_element_end_indented)
  end()
  ans(json_cbs)
  function_import_table(${json_cbs} json_indented_callback)

  # function definition
  function(json_indented)        
    map_new()
    ans(context)
    dfs_callback(json_indented_callback ${ARGN})
    map_tryget(${context} json)
    return_ans()  
  endfunction()
  #delegate
  json_indented(${ARGN})
  return_ans()
endfunction()

# File: source/formats/json/json_print.cmake

function(json_print)
  json_indented(${ARGN})
  ans(res)
  _message("${res}")
endfunction()

# File: source/formats/json/json_read.cmake

# reads a json file from the specified location
# the location may be relative (see explanantion of path() function)
# returns a map or nothing if reading fails 
function(json_read file)
    path("${file}")
    ans(file)
    if(NOT EXISTS "${file}")
      creturn()
    endif()
    checksum_file("${file}")
    ans(cache_key)
    file_cache_return_hit("${cache_key}")

    file(READ "${file}" data)
    json_deserialize("${data}")
    ans(data)

    file_cache_update("${cache_key}" "${data}")

    return_ref(data)
endfunction()

# File: source/formats/json/json_string_to_cmake.cmake


  function(json_string_to_cmake str)
    # remove trailing and leading quotation marks
    if("${str}" MATCHES "\"(.*)\"")
      set(str "${CMAKE_MATCH_1}")
      ## escape semicolon
      string(REPLACE "\\\\;" ";" str "${CMAKE_MATCH_1}")
    endif()

    string(ASCII 8 char)
    string(REPLACE  "\\b" "${char}" str "${str}")
    string(ASCII 12 char)
    string(REPLACE  "\\f" "${char}" str "${str}")

    
    string(REPLACE "\\n" "\n" str "${str}")
    string(REPLACE "\\t" "\t" str "${str}")
    string(REPLACE "\\t" "\t" str "${str}")
    string(REPLACE "\\r" "\r" str "${str}")
    string(REPLACE "\\\"" "\"" str "${str}")

    string(REPLACE "\\\\" "\\" str "${str}")

    return_ref(str)
      
  endfunction()
  # converts the json-string & to a cmake string
  function(json_string_ref_to_cmake __json_string_ref_to_cmake_ref)
    json_string_to_cmake("${${__json_string_ref_to_cmake_ref}}")
    return_ans()
      
  endfunction()

# File: source/formats/json/json_tokenize.cmake

function(json_tokenize result json)

	set(regex "(\\{|\\}|:|,|\\[|\\]|\"(\\\\.|[^\"])*\")")
	string(REGEX MATCHALL "${regex}" matches "${json}")


	# replace brackets with angular brackets because
	# normal brackes are not handled properly by cmake
	string(REPLACE  ";[;" ";<;" matches "${matches}")
	string(REPLACE ";];" ";>;" matches "${matches}")
	string(REPLACE "[" "" matches "${matches}")
	string(REPLACE "]" "" matches "${matches}")

	set(tokens)
	foreach(match ${matches})
		string_char_at("${match}" 0)
		ans(char)
		if("${char}" STREQUAL "[")
			string_char_at("${match}" -2)
			ans(char)
			if(NOT "${char}" STREQUAL "]")
				message(FATAL_ERROR "json syntax error: no closing ']' instead: '${char}' ")
			endif()
			string(LENGTH "${match}" len)
			math(EXPR len "${len} - 2")
			string(SUBSTRING ${match} 1 ${len} array_values)
			set(tokens ${tokens} "<")
			foreach(submatch ${array_values})
				set(tokens ${tokens} ${submatch} )
			endforeach()
			set(tokens ${tokens} ">")
		else()
			set(tokens ${tokens} ${match})
		endif()
	endforeach()

	set(${result} ${tokens} PARENT_SCOPE)
endfunction()

# File: source/formats/json/json_write.cmake

# write the specified object reference to the specified file
## todo rename to fwrite_json(path data)
  function(json_write file obj)
    path("${file}")
    ans(file)
    json_indented(${obj})
    ans(data)
    file(WRITE "${file}" "${data}")
    creturn()
  endfunction()

# File: source/formats/quick_map/qm_deserialize.cmake


function(qm_deserialize quick_map_string)
  set_ans("")
  eval("${quick_map_string}")
  ans(res)
  address_get($"{res}")
#  map_tryget(${res} data)
  return_ans()
endfunction()



# File: source/formats/quick_map/qm_deserialize_file.cmake



# deserializes the specified file
function(qm_deserialize_file quick_map_file)
  if(NOT EXISTS "${quick_map_file}")
    creturn()
  endif()
  include(${quick_map_file})
  ans(res)
  address_get(${res})
  return_ans()
endfunction()

# File: source/formats/quick_map/qm_print.cmake

function(qm_print)
  qm_serialize(${ARGN})
  ans(res)

  message("${res}")
  creturn()
endfunction()

# File: source/formats/quick_map/qm_read.cmake

# reads the qualifies and reads the specified <unqualified path>
# returns a <map>
function(qm_read path)
  path("${path}")
  ans(path)

  qm_deserialize_file("${path}")
  return_ans()
  
endfunction()

# File: source/formats/quick_map/qm_serialize.cmake


function(qm_serialize)
  # define callbacks for building result
  function(qm_obj_begin_indented)
   # message(PUSH_AFTER "qm_obj_begin_indented(${ARGN})")
    map_tryget(${context} indentation)
    ans(indentation)
    map_append_string(${context} qm "${indentation}map()\n")
    map_append_string(${context} indentation " ")
  endfunction()
  function(qm_obj_end_indented)
    #message(POP "qm_obj_end_indented(${ARGN})")
    map_tryget(${context} indentation)
    ans(indentation)
    string(SUBSTRING "${indentation}" 1 -1 indentation)
    map_set(${context} indentation "${indentation}")
    map_append_string(${context} qm "${indentation}end()\n")

  endfunction()

  function(qm_obj_keyvalue_begin_indented)
   # message("qm_obj_keyvalue_begin_indented(${key} ${ARGN}) ${context}")
    map_tryget(${context} indentation)
    ans(indentation)
    map_append_string(${context} qm "${indentation}key(\"${map_element_key}\")\n")
  endfunction()

  function(qm_literal_indented)
    map_tryget(${context} indentation)
    ans(indentation)
    
    cmake_string_escape("${node}")
    ans(node)
    map_append_string(${context} qm "${indentation} val(\"${node}\")\n")
    
    creturn()
  endfunction()


   map()
    kv(value              qm_literal_indented)
    kv(map_begin          qm_obj_begin_indented)
    kv(map_end            qm_obj_end_indented)
    kv(map_element_begin  qm_obj_keyvalue_begin_indented)
  end()
  ans(qm_cbs)
  function_import_table(${qm_cbs} qm_indented_callback)

  # function definition
  function(qm_serialize)        
    map_new()
    ans(context)
    map_set(${context} qm "#qm/1.0\nref()\n")
    #map_new()
    #ans(data)
    #map_set(${data} data "${ARGN}")
    dfs_callback(qm_indented_callback ${ARGN})
    map_tryget(${context} qm)
    ans(res)
    set(res "${res}end()\n")
    return_ref(res)  
  endfunction()
  #delegate
  qm_serialize(${ARGN})
  return_ans()
endfunction()



function(qm_serialize_unindented)
  # define callbacks for building result
  function(qm_obj_begin_unindented)
    map_append_string(${context} qm "map()\n")
  endfunction()
  function(qm_obj_end_unindented)
    map_append_string(${context} qm "end()\n")

  endfunction()

  function(qm_obj_keyvalue_begin_unindented)
    map_append_string(${context} qm "key(\"${map_element_key}\")\n")
  endfunction()

  function(qm_literal_unindented)
    cmake_string_escape("${node}")
    ans(node)
    map_append_string(${context} qm "val(\"${node}\")\n")
    creturn()
  endfunction()


   map()
    kv(value              qm_literal_unindented)
    kv(map_begin          qm_obj_begin_unindented)
    kv(map_end            qm_obj_end_unindented)
    kv(map_element_begin  qm_obj_keyvalue_begin_unindented)
  end()
  ans(qm_cbs)
  function_import_table(${qm_cbs} qm_unindented_callback)

  # function definition
  function(qm_serialize_unindented)        
    map_new()
    ans(context)
    map_set(${context} qm "#qm/1.0\nref()\n")
    #map_new()
    #ans(data)
    #map_set(${data} data "${ARGN}")
    dfs_callback(qm_unindented_callback ${ARGN})
    map_tryget(${context} qm)
    ans(res)
    set(res "${res}end()\n")
    return_ref(res)  
  endfunction()
  #delegate
  qm_serialize_unindented(${ARGN})
  return_ans()
endfunction()


# File: source/formats/quick_map/qm_write.cmake

# writes the specified values to path as a quickmap file
# path is an <unqualified file>
# returns the <qualified path> were values were written to
function(qm_write path )
  path("${path}")
  ans(path)

  qm_serialize(${ARGN})
  ans(res)
  fwrite("${path}" "${res}")
  return_ref(path)
endfunction()

# File: source/formats/table/table_deserialize.cmake

# parses a table as is output by win32 commands like tasklist
# the format is
# header1 header2 header3
# ======= ======= =======
# val1    val2    val3
# val4    val5    val6
# not that the = below the header is used as the column width and must be the max length of any value in 
# column including the header
# returns a list of <row> where row is a map and the headers are the keys   (values are trimmed from whitespace)
# the example above results in 
# {
#   "header1":"val1",
#   "header2":"val2",
#   "header3":"val3"
# }
#
function(table_deserialize input)
  string_lines("${input}")
  ans(lines)
  list_pop_front(lines)
  ans(firstline)  
  list_pop_front(lines)    
  ans(secondline)
  list_pop_front(lines)    
  ans(thirdline)

  string(REPLACE "=" "." line_match "${thirdline}")
  string_split("${line_match}" " ")
  ans(parts)
  list(LENGTH parts cols) 
  set(linematch)
  set(first true)
  foreach(part ${parts})
    if(first)
      set(first false)
    else()
      set(linematch "${linematch} ")
    endif()
    set(linematch "${linematch}(${part})")
  endforeach()

  set(headers __empty) ## empty is there to buffer so that headers can be index 1 based instead of 0 based
  foreach(idx RANGE 1 ${cols})
    string(REGEX REPLACE "${linematch}" "\\${idx}" header "${secondline}")
    string(STRIP "${header}" header)
    list(APPEND headers ${header})
  endforeach()



  set(result)
  foreach(line ${lines})
    map_new()
    ans(l)
    foreach(idx RANGE 1 ${cols})
      string(REGEX REPLACE "${linematch}" "\\${idx}" col "${line}")
      string(STRIP "${col}" col)
      list_get(headers ${idx})
      ans(header)
      map_set(${l} "${header}" "${col}")        
    endforeach()
    list(APPEND result ${i})
  endforeach()

  return_ref(result)
endfunction()


# File: source/formats/table/table_serialize.cmake

# not finished
function(table_serialize)  
  objs(${ARGN})  
  ans(lines)


  map_new()
  ans(column_layout)

  set(allkeys)

  # get column_layout and col sizes
  foreach(line ${lines})
    map_keys(${line})
    ans(keys)
    
    foreach(key ${keys})  
      map_tryget(${column_layout} ${key})
      ans(res)
      
      map_tryget(${line} ${key})
      ans(val)
      string(LENGTH "${val}" len)
        
      if(${len} GREATER "0${res}")
        map_set(${column_layout} ${key} "${len}")
      endif()
    endforeach()
  endforeach()


  map_keys(${column_layout})
  ans(headers)
  set(res)
  set(separator)
  set(layout)
  set(first true)
  foreach(header ${headers})
    if(first)
      set(first false)
    else()
      set(res "${res} ")
      set(separator "${separator} ")
    endif()

    map_tryget(${column_layout} "${header}")
    ans(size)
    string_pad("${header}" "${size}")
    ans(header)    
    set(res "${res}${header}")
    string_repeat("=" "${size}")
    ans(sep)
    set(separator "${separator}${sep}")
  endforeach()

  set(res "${res}\n${separator}\n")
  

  foreach(line ${lines})
    set(first true)    
    foreach(header ${headers})
      if(first)
        set(first false)
      else()
        set(res "${res} ")      
      endif()
      map_tryget(${column_layout} "${header}")
      ans(size)
      map_tryget(${line} "${header}")
      ans(val)
      string_pad("${val}" ${size})
      ans(val)
      set(res "${res}${val}")
    endforeach()
    set(res "${res}\n")
  endforeach()

  return_ref(res)
endfunction()

# File: source/formats/xml/xml_node.cmake

# creates a new xml node
# {
#   tag:'tag string'
#   //child_nodes:[xml_node, ...]
#   //parent:xml_node
#   attrs: {  }
#   value: 'string'
#   
# }
function(xml_node tag value attrs)
  obj("${attrs}")
  ans(attrs)
  map()
    kv(tag "${tag}")
    kv(value "${value}")
    kv(attrs "${attrs}")
  end()
  ans(res)
  return_ref(res)
endfunction()

# File: source/formats/xml/xml_parse_attrs.cmake


  function(xml_parse_attrs xml tag attr)
    xml_parse_tags("${xml}" "${tag}")
    ans(nodes)
    set(res)
    foreach(node ${nodes})
      map_tryget(${node} attrs)
      ans(attrs)
      map_tryget("${attrs}" "${attr}")
      ans(it)
      list(APPEND res "${it}")
    endforeach()
    return_ref(res)
  endfunction()

# File: source/formats/xml/xml_parse_tags.cmake

## naive way of parsing xml tags
## returns a list of all matched xml nodes
## warning: does not supported nested nodes of same name!! and no tag whithout closing tag: <test/>
## {
##  value:"content",
##  attrs:{
##    key:"val",
##    key:"val",
##    ...
##  }
## }
function(xml_parse_tags xml tag)
  set(regex_str "\\\"([^\\\"]*)\\\"")
  set(regex_attrs "([a-zA-Z_-][a-zA-Z0-9_-]*) *= *${regex_str}")
  set(regex "< *${tag}([^>]*)>(.*)</ *${tag} *>")
  string(REGEX MATCHALL "${regex}"  output "${xml}")

  set(res)
  foreach(match ${output})
    string(REGEX REPLACE "${regex}" "\\1" attrs "${match}") 
    string(REGEX REPLACE "${regex}" "\\2" match "${match}") 


    map()
      kv(tag "${tag}")
      kv(value "${match}")    
      map(attrs)
        string(REGEX MATCHALL "${regex_attrs}" attrs "${attrs}")
        foreach(attr ${attrs})
          string(REGEX REPLACE "${regex_attrs}" "\\1" key "${attr}")
          string(REGEX REPLACE "${regex_attrs}" "\\2" val "${attr}")
          kv("${key}" "${val}")
        endforeach()
      end()
    end()
    ans(t)
    list(APPEND res ${t})

  endforeach()

  return_ref(res)

endfunction()

# File: source/formats/xml/xml_parse_values.cmake


  function(xml_parse_values xml tag)
    xml_parse_tags("${xml}" "${tag}")
    ans(nodes)
    set(res)
    foreach(node ${nodes})
      nav(node.value)
      ans(val)
      list(APPEND res "${val}")
    endforeach()
    return_ref(res)
  endfunction()

# File: source/function/anonymous_function.cmake


function(anonymous_function)
  is_anonymous_function(${ARGN})
  ans(is_anonymous_function)
  if(NOT is_anonymous_function)
    creturn()
  elseif("${is_anonymous_function}" STREQUAL "code")
    arguments_cmake_code(0 ${ARGC})
    ans(code)
    anonymous_function_new("${code}")
    return_ans()
  elseif("${is_anonymous_function}" STREQUAL "instance")
    set(func ${ARGN})
    return_ref(func)
  endif()
  message(FATAL_ERROR "unreachable code")
endfunction()

# File: source/function/anonymous_function_new.cmake

function(anonymous_function_new code)
  function_new()
  ans(function_name)
  set(function_name "anonymous_${function_name}")
  string(REGEX REPLACE "^\\(" "(${function_name}" code "${code}")
  eval("function${code}endfunction()")
  return_ref(function_name)
endfunction()



# File: source/function/arguments_anonymous_function.cmake

macro(arguments_anonymous_function __args_start __args_end)
  arguments_cmake_code(${__args_start} ${__args_end})
  anonymous_function_new("${__ans}")
endmacro()





# File: source/function/arguments_cmake_code.cmake

## `(<start index> <end index>)-> <cmake code>`
## 
## captures the cmake code for the calling function and returns it as a string  
macro(arguments_cmake_code __args_start __args_end)
    string_codes()
    set(__args_command_invocations)
    set(__args_level 0)
    set(__args_current_invocation)
    foreach (i RANGE ${__args_start} ${__args_end})
        set(__args_current_token "${ARGV${i}}")
        # _message("${__args_current_token}")
        set(__args_invocation_complete false)
        if ("${__args_current_token}_" STREQUAL "(_")
            math(EXPR __args_level "${__args_level} + 1")
        elseif ("${__args_current_token}_" STREQUAL ")_")
            math(EXPR __args_level "${__args_level} - 1")
            if (NOT __args_level)
                set(__args_invocation_complete true)
            endif ()
        else ()
            if ("${__args_current_token}" MATCHES "[ \\$\"\\(\\)#\\^\t\r\n\\\;]")
                ## encoded list encode cmake string...
                ## @ todo this has to be extracted however it does not work correctly because
                ## of macro evaluation when using cmake_string_escape2
                string(REPLACE ";" "${semicolon_code}" __args_current_token "${__args_current_token}")
                string(REPLACE "\\" "\\\\" __args_current_token "${__args_current_token}")
                string(REGEX REPLACE "([ \"\\(\\)#\\^])" "\\\\\\1" __args_current_token "${__args_current_token}")
                string(REPLACE "\t" "\\t" __args_current_token "${__args_current_token}")
                string(REPLACE "\n" "\\n" __args_current_token "${__args_current_token}")
                string(REPLACE "\r" "\\r" __args_current_token "${__args_current_token}")
                set(__args_current_token "\"${__args_current_token}\"")
                #  _message("arg ${__args_current_token}")
            endif ()
        endif ()
        list(APPEND __args_current_invocation "${__args_current_token} ")
        if (__args_invocation_complete)
            string(REPLACE ";" "" __args_current_invocation "${__args_current_invocation}")
            #string(CONCAT __args_current_invocation ${__args_current_invocation})
            list(APPEND __args_command_invocations "${__args_current_invocation}\n")
            set(__args_current_invocation)
        endif ()
    endforeach ()

    string(REPLACE ";" "" __ans "${__args_command_invocations}")
    #string(CONCAT __ans ${__args_command_invocations})
    string(REPLACE "${semicolon_code}" "\\;" __ans "${__ans}")
    # _message("--- ${__args_start} ${__args_end} -- ${__ans}")
endmacro()


# File: source/function/arguments_cmake_string.cmake

##
##
## recreates the invocation arguments which when evaluated are identical
## to the arguments passed to the function where this macro was invoked
macro(arguments_cmake_string __arg_begin __arg_end)
  set(__arg_res)   
  if(${__arg_end} GREATER ${__arg_begin})
    math(EXPR __last_arg_index "${__arg_end} - 1")
    foreach(i RANGE ${__arg_begin} ${__last_arg_index} )        
      cmake_string_escape("${ARGV${i}}")
      set(__arg_res "${__arg_res} \"${__ans}\"")
    endforeach()
    string(SUBSTRING "${__arg_res}" 1 -1 __ans)
  else()
    set(__ans)
  endif()
endmacro()

# File: source/function/arguments_encoded_list.cmake

##
##
## returns an encoded list for the specified arguments passed to
## current function invocation.
##
## you can only use this inside of a cmake function and not inside a macro
macro(arguments_encoded_list __arg_begin __arg_end)
    set(__ans)
    if(${__arg_end} GREATER ${__arg_begin})
        math(EXPR __last_arg_index "${__arg_end} - 1")
        foreach(i RANGE ${__arg_begin} ${__last_arg_index})

            string(REPLACE "[" "" __tmp_encoded_list "${ARGV${i}}")
            string(REPLACE "]" "" __tmp_encoded_list "${__tmp_encoded_list}")
            string(REPLACE ";" "" __tmp_encoded_list "${__tmp_encoded_list}")
            if("${__tmp_encoded_list}_" STREQUAL "_")
                set(__tmp_encoded_list "")
            endif()
            list(APPEND __ans "${__tmp_encoded_list}")
        endforeach()
    endif()
endmacro()

# File: source/function/arguments_extract.cmake


macro(arguments_extract __arg_begin __arg_end)
 set(__arg_refs ${ARGN})
  if(${__arg_end} GREATER ${__arg_begin})
    math(EXPR __last_arg_index "${__arg_end} - 1")
    foreach(i RANGE ${__arg_begin} ${__last_arg_index} )
      if(NOT __arg_refs)
        break()
      endif()
      list(GET __arg_refs 0 __arg_ref)
      list(REMOVE_AT __arg_refs 0)
      set("${__arg_ref}" "${ARGV${i}}")
    endforeach()
  endif()
endmacro()


# File: source/function/arguments_foreach.cmake

macro(arguments_foreach __arg_begin __arg_end __arg_callable)
  if(${__arg_end} GREATER ${__arg_begin})
    callable_function("${__arg_callable}")
    ans(__arg_callable)
    math(EXPR __last_arg_index "${__arg_end} - 1")
    set(__arg_res)   
    eval("
      macro(__arguments_foreach_func)
        foreach(i RANGE ${__arg_begin} ${__last_arg_index} )        
          ${__arg_callable}(\"\${ARGV\${i}}\")
          list(APPEND __arg_res \"\${__ans}\")
        endforeach()
      endmacro()
      ")
    __arguments_foreach_func("${__arg_begin}" "${__arg_end}")
    set(__ans "${__arg_res}")
  else()
    set(__ans)
  endif()
endmacro()

# File: source/function/arguments_function.cmake


macro(arguments_function __function_name __args_start __args_end)
  arguments_cmake_code(${__args_start} ${__args_end})
  ans(code)
  string(REGEX REPLACE "^\\(" "(${__function_name}" code "${code}")
  eval("function${code}\nendfunction()")
endmacro()



# File: source/function/arguments_sequence.cmake

macro(arguments_sequence __begin __end)
  arguments_encoded_list("${__begin}" "${__end}")
  ans(__list)
  sequence_new()
  ans(__result)
  foreach(__sublist ${__list})
    encoded_list_decode("${__sublist}")
    ans(__sublist)
    sequence_add("${__result}" "${__sublist}")
  endforeach()
  set(__ans "${__result}")
endmacro()


# File: source/function/arguments_string.cmake

## returns the argument string which was passed to the parent function
## it takes into considerations quoted arguments
## todo: start and endindex
macro(arguments_string __arg_begin __arg_end)
  set(__arg_res)   
  if(${__arg_end} GREATER 0)
    math(EXPR __last_arg_index "${__arg_end} - 1")
    foreach(i RANGE 0 ${__last_arg_index})
      set(__current "${ARGV${i}}")
      if("${__current}_" MATCHES "(^_$)|(;)|(\\\")")
        set(__current "\"${__current}\"")
      endif()
      set(__arg_res "${__arg_res} ${__current}")
    endforeach()
    string(SUBSTRING "${__arg_res}" "1" "-1" __ans)  
  else()
    set(__ans)
  endif()
endmacro()


# File: source/function/bind.cmake

# is the same as function_capture.
# deprecate one of the two
#
# binds variables to the function
# by caputring their current value and storing
# them
# let funcA : ()->res
# bind(funcA var1 var2)
# will store var1 and var2 and provide them to the funcA call
function(bind func )
  cmake_parse_arguments("" "" "as" "" ${ARGN})
  if(NOT _as)
    function_new()
    ans(_as)
  endif()

  # if func is not a command import it
  if(NOT COMMAND "${func}")
    function_new()
    ans(original_func)
    function_import("${func}" as ${original_func} REDEFINE)
  else()
    set(original_func "${func}")
  endif()

  set(args ${_UNPARSED_ARGUMENTS})

  set(bound_args)
  foreach(arg ${args})
    set(bound_args "${bound_args}\nset(${arg} \"${${arg}}\")")
  endforeach()

  set(evaluate "function(${_as})
${bound_args}
${original_func}(\${ARGN})    
return_ans()
endfunction()")
  set_ans("")
  eval("${evaluate}")
  return_ref(_as)
endfunction()

# File: source/function/call.cmake

# dynamic function call method
# can call the following
# * a cmake macro or function
# * a cmake file containing a single function
# * a lambda expression (see lambda())
# * a object with __call__ operation defined
# * a property reference ie this.method()
# CANNOT  call 
# * a navigation path
# no output except through return values or referneces
function(call __function_call_func __function_call_paren_open)

    return_reset()
    set(__function_call_args ${ARGN})

    list_pop_back(__function_call_args)
    ans(__function_call_paren_close)

    if (NOT "_${__function_call_paren_open}${__function_call_paren_close}" STREQUAL "_()")
        message("open ${__function_call_paren_open} close ${__function_call_paren_close}")
        message(WARNING "expected opening and closing parentheses for function '${__function_call_func}' '${ARGN}' '${__function_call_args}'")
    endif ()

    if (COMMAND "${__function_call_func}")
        set_ans("")
        eval("${__function_call_func}(\${__function_call_args})")
        return_ans()
    endif ()


    if (DEFINED "${__function_call_func}")
        call("${${__function_call_func}}" (${__function_call_args}))
        return_ans()
    endif ()

    is_address("${__function_call_func}")
    ans(isref)
    if (isref)
        obj_call("${__function_call_func}" ${__function_call_args})
        return_ans()
    endif ()

    propis_address("${__function_call_func}")
    ans(ispropref)
    if (ispropref)
        propref_get_key("${__function_call_func}")
        ans(key)
        propref_get_ref("${__function_call_func}")
        ans(ref)

        obj_member_call("${ref}" "${key}" ${__function_call_func})

    endif ()

    lambda2_tryimport("${__function_call_func}" __function_call_import)
    ans(success)
    if (success)
        __function_call_import(${__function_call_args})
        return_ans()
    endif ()


    if (DEFINED "${__function_call_func}")
        call("${__function_call_func}" (${__function_call_args}))
        return_ans()
    endif ()


    is_function(is_func "${__function_call_func}")
    if (is_func)
        function_import("${__function_call_func}" as __function_call_import REDEFINE)
        __function_call_import(${__function_call_args})
        return_ans()
    endif ()

    if ("${__function_call_func}" MATCHES "^[a-z0-9A-Z_-]+\\.[a-z0-9A-Z_-]+$")
        string_split_at_first(__left __right "${__function_call_func}" ".")
        is_address("${__left}")
        ans(__left_isref)
        if (__left_isref)
            obj_member_call("${__left}" "${__right}" ${__function_call_args})
            return_ans()
        endif ()
        is_address("${${__left}}")
        ans(__left_isrefref)
        if (__left_isrefref)
            obj_member_call("${${__left}}" "${__right}" ${__function_call_args})
            return_ans()
        endif ()
    endif ()

    nav(__function_call_import = "${__function_call_func}")
    if (__function_call_import)
        call("${__function_call_import}" (${__function_call_args}))
        return_ans()
    endif ()

    message(FATAL_ERROR "tried to call a non-function:'${__function_call_func}'")
endfunction()

# File: source/function/callable/call2.cmake

function(call2 callable)
  callable("${callable}")
  ans(callable)
  callable_call("${callable}")
  return_ans()
endfunction()

## faster version
function(call2 callable)
  callable_function("${callable}")
  eval("${__ans}(${ARGN})")
  set(__ans ${__ans} PARENT_SCOPE)
endfunction()

# File: source/function/callable/callable.cmake

function(callable input)
  string(MD5  input_key "${input}" )
  get_propertY(callable GLOBAL PROPERTY "__global_callables.${input_key}")

  if(NOT callable)
    callable_new("${input}")
    ans(callable)

    checksum_string("${callable}")
    ans(callable_key)

    map_set_hidden(__global_callables "${input_key}" ${callable})
    map_set_hidden(__global_callables "${callable_key}" ${callable})

    map_get_special(${callable} callable_function)
    ans(function)

    map_set_hidden(__global_callable_functions "${input_key}" ${function})
    map_set_hidden(__global_callable_functions "${callable_key}" ${function})

  endif()
  set(__ans ${callable} PARENT_SCOPE)
endfunction()


# File: source/function/callable/callable_call.cmake


function(callable_call callable)
  map_get_special("${callable}" callable_function)
  eval("${__ans}(${ARGN})")
  set(__ans "${__ans}" PARENT_SCOPE)
endfunction()


# File: source/function/callable/callable_function.cmake



## returns the cmake function for the specified callable
function(callable_function input)
  string(MD5  input_key "${input}" )
  get_propertY(callable_func GLOBAL PROPERTY "__global_callable_functions.${input_key}")
  if(NOT callable_func)
    callable("${input}")
    ans(callable)
    get_propertY(callable_func GLOBAL PROPERTY "__global_callable_functions.${input_key}")
  endif()
  set(__ans ${callable_func} PARENT_SCOPE)
endfunction()

# File: source/function/callable/callable_new.cmake

function(callable_new input)

  map_new()
  ans(callable)
  map_set_special("${callable}" "$type" "callable")
  function_import("${input}")
  ans(callable_func)
  map_set_special("${callable}" callable_function "${callable_func}")
  map_set_special("${callable}" callable_input "${input}" )
  return_ref(callable)
endfunction()

# File: source/function/callable/is_callable.cmake


  function(is_callable callable)
    map_get_special("${callable}" callable_function)
    ans(func)
    if(COMMAND "${func}")
      creturn(true)
    endif()
    creturn(false)
  endfunction()


# File: source/function/check_function.cmake

function(check_function func)
	is_function(res "${func}")
	if(NOT res)
		message(FATAL_ERROR "expected a function instead got: '${func}'")
	endif()
endfunction()

# File: source/function/curry3.cmake

## (["[" <capture vars> "]"] <callable> "(" (<argument>|<assignment>)* ")" ["=>" <?func_name>(<arg names>)  ])->
##
##

function(curry_compile_encoded_list out_func)
    set(arguments ${ARGN})
    string_codes()
    set(regex_evaluates_to "=>")
    if ("${arguments}" MATCHES "(.*);?${regex_evaluates_to};(.*)")
        set(definition "${CMAKE_MATCH_1}")
        set(invocation "${CMAKE_MATCH_2}")
    else ()
        set(invocation "${arguments}")
        set(definition)
    endif ()

    list_peek_front(invocation)
    ans(invocation_capture)

    if ("${invocation_capture}" MATCHES "^${bracket_open_code}(.*)${bracket_close_code}$")
        string_decode_list("${CMAKE_MATCH_1}")
        ans(invocation_capture)
        list_pop_front(invocation)
    else ()
        set(invocation_capture)
    endif ()

    set(capture_code)
    foreach (capture ${invocation_capture})
        # todo capture by value
        set(capture_code "${capture_code}\n  set(${capture} \"${${capture}}\")")
    endforeach ()

    regex_cmake()

    list_pop_front(invocation)
    ans(callable)

    string_decode_list("${callable}")
    ans(callable)

    function_import("${callable}")
    ans(invocation_name)

    set(invocation "${invocation_name};${invocation}")
    if ("${invocation}" MATCHES "^(${regex_cmake_identifier});\\(;(.*);\\)")
        set(invocation_name "${CMAKE_MATCH_1}")
        set(invocation_args "${CMAKE_MATCH_2}")
    elseif ("${invocation}" MATCHES "^(${regex_cmake_identifier})")
        set(invocation_name "${CMAKE_MATCH_1}")
        set(invocation_args "/*")
    endif ()

    if ("${definition}" MATCHES "^(${regex_cmake_identifier});\\(;?(.*);\\)")
        set(definition_name "${CMAKE_MATCH_1}")
        set(definition_args "${CMAKE_MATCH_2}")
    elseif ("${definition}" MATCHES "^(${regex_cmake_identifier});?$")
        set(definition_name "${CMAKE_MATCH_1}")
        set(definition_args)
    elseif ("${definition}" MATCHES "^\;?\\(;?(.*);\\)")
        set(definition_name)
        set(definition_args "${CMAKE_MATCH_1}")
    endif ()

    if (NOT definition_name)
        function_new()
        ans(definition_name)
    endif ()


    map_new()
    ans(assignments)


    set(arg_counter 0)
    set(arg_name_prefix __arg_)
    set(input_args)

    foreach (argument ${definition_args})
        string_decode_list("${argument}")
        ans(argument)
        set(argument_name "__${argument}")
        map_set(${assignments} ${argument} "${argument_name}")
        set(input_args "${input_args} ${argument_name}")
    endforeach ()

    set(regex_arg_replacement "\\/(${regex_cmake_identifier}|\\*)")
    set(regex_pos_replacement "\\/(0|([1-9][0-9]*))")
    set(output_args)
    foreach (argument ${invocation_args})
        string_decode_list("${argument}")
        ans(argument)
        if ("${argument}" MATCHES "^${regex_pos_replacement}$")
            set(argument_id "${CMAKE_MATCH_1}")
            set(argument_out "\${ARGV${argument_id}}")
        elseif ("${argument}" MATCHES "^${regex_arg_replacement}$")
            set(argument_id "${CMAKE_MATCH_1}")
            if ("${argument_id}" STREQUAL "*")
                set(argument_out "\${ARGN}")
            else ()
                map_tryget("${assignments}" "${argument_id}")
                ans(argument_out)
                set(argument_out "\${${argument_out}}")
            endif ()
        else ()
            argument_escape("${argument}")
            ans(argument_out)
        endif ()
        set(output_args "${output_args} ${argument_out}")
    endforeach ()
    if (NOT "${output_args}_" STREQUAL "_")
        string(SUBSTRING "${output_args}" 1 -1 output_args)
    endif ()
    if (NOT "${input_args}_" STREQUAL "_")
        string(SUBSTRING "${input_args}" 1 -1 input_args)
    endif ()

    set(code "function(${definition_name} ${input_args})${capture_code}\n  ${invocation_name}(${output_args})\n  return_ans()\nendfunction()")
    set(${out_func} "${definition_name}" PARENT_SCOPE)
    return_ref(code)

endfunction()

##
function(curry_compile)
    arguments_encoded_list(0 ${ARGC})
    ans(arguments)
    curry_compile_encoded_list(__outfunc "${arguments}")
    return_ans()
endfunction()

##
function(curry3)
    arguments_encoded_list(0 ${ARGC})
    ans(arguments)
    curry_compile_encoded_list(__outfunc "${arguments}")
    ans(code)
    eval("${code}")
    return_ref(__outfunc)
endfunction()

# File: source/function/define_function.cmake

## define an inline function
## e.g. `define_function(my_func() message(hello))`
function(define_function function_name)
  arguments_function("${function_name}" 1 ${ARGC})
  creturn()
endfunction()

# File: source/function/function_capture.cmake

## captures variables from the current scope in the function
function(function_capture callable)
  set(args ${ARGN})
  list_extract_labelled_value(args as)
  ans(func_name)
  if(func_name STREQUAL "")
    function_new()
    ans(func_name)
  endif()

  set(captured_var_string)
  foreach(arg ${args})
    set(captured_var_string "${captured_var_string}set(${arg} \"${${arg}}\")\n")
  endforeach()

  function_import("${callable}")
  ans(callable)

  eval("
    function(${func_name})
      ${captured_var_string}
      ${callable}(\${ARGN})
      return_ans()
    endfunction()
  ")
  return_ref(func_name)
endfunction()




# File: source/function/function_define_new.cmake

## `(<signarture> <cmake code>)-><function name>`
##
## defines an anonymous cmake function and returns its reference (name)
## the code needs to begin with the signature without the name e.g. `(arg1 arg2)` 
##  
function(function_define_new)
  arguments_cmake_code(0 ${ARGC})
  ans(code)
  anonymous_function_new("${code}")
  return_ans()
endfunction()




# File: source/function/function_help.cmake

function(function_help result func)
	function_lines_get( "${func}")
	ans(res)
	set(res)
	foreach(line ${res})
		string(STRIP "${line}" line)
		if(line)
			string(SUBSTRING "${line}" 0 1 first_char)
			if(NOT ${first_char} STREQUAL "#")
				if(res)
					set(res "${res}\n")
				endif()
				set(res "${res}${line}")
			else()
				break()
			endif()
		endif()
	endforeach()
	return_value("${res}")
endfunction()

# File: source/function/function_import.cmake

function(function_import callable)
    set(args ${ARGN})
    list_extract_flag(args REDEFINE)
    ans(redefine)
    list_extract_flag(args ONCE)
    ans(once)
    list_extract_labelled_value(args as)
    ans(function_name)

    if (callable STREQUAL "")
        message(FATAL_ERROR "no callable specified")
    endif ()

    if (COMMAND "${callable}")
        if ("${function_name}_" STREQUAL "_" OR "${callable}_" STREQUAL "${function_name}_")
            return_ref(callable)
        endif ()
    endif ()


    if (NOT function_name)
        if (COMMAND "${callable}")
            set(function_name "${callable}")
            return_ref(function_name)
        else ()
            function_new()
            ans(function_name)
            set(redefine true)
        endif ()
    endif ()


    if (COMMAND "${function_name}" AND NOT redefine)
        if (once)
            creturn()
        endif ()
        message(FATAL_ERROR "cannot import '${callable}' as '${function_name}' because it already exists")
    endif ()


    lambda2_tryimport("${callable}" "${function_name}")
    ans(res)
    if (res)
        return_ref(function_name)
    endif ()

    function_string_get("${callable}")
    ans(function_string)

    function_string_rename("${function_string}" "${function_name}")
    ans(function_string)

    function_string_import("${function_string}")

    return_ref(function_name)
endfunction()

# File: source/function/function_import_dispatcher.cmake


function(function_import_dispatcher function_name)
    string(REPLACE ";" "\n" content "${ARGN}")

    string(REGEX REPLACE "([^\n]+)" "elseif(command STREQUAL \"\\1\")\n \\1(\${ARGN})\nreturn_ans()\n" content "${content}")
    eval("
        function(${function_name} command)
          if(false)
          ${content}
            endif()
          creturn()
        endfunction()

      ")
      creturn()
endfunction()


function(function_import_global_dispatcher function_name)
    get_cmake_property(commands COMMANDS)       
    list(REMOVE_ITEM commands else if elseif endif while function endwhile endfunction macro endmacro foreach endforeach)
    function_import_dispatcher("${function_name}" ${commands})
    creturn()
endfunction()

# File: source/function/function_import_table.cmake

# imports the specified map as a function table which is callable via <function_name>
# whis is a performance enhancement 
function(function_import_table map function_name)
  map_keys(${map} )
  ans(keys)
  set("ifs" "if(false)\n")
  foreach(key ${keys})
    map_get(${map}  ${key})
    ans(command_name)
    set(ifs "${ifs}elseif(\"${key}\" STREQUAL \"\${switch}\" )\n${command_name}(\"\${ARGN}\")\nreturn_ans()\n")
  endforeach()
  set(ifs "${ifs}endif()\n")
set("evl" "function(${function_name} switch)\n${ifs}\ncreturn()\nendfunction()")
   # message(${evl})
  set_ans("")
   
    eval("${evl}")
endfunction()



# File: source/function/function_lines_get.cmake

# returns the function content in a list of lines.
# cmake does nto support a list containing a strings which in return contain semicolon
# the workaround is that all semicolons in the source are replaced by a separate line containsing the string ![[[SEMICOLON]]]
# so the number of lines a function has is the number of lines minus the number of lines containsing only ![[[SEMICOLON]]]
function(function_lines_get  func)
	function_string_get( "${func}")
	ans(function_string)
	
	string(REPLACE ";" "![[[SEMICOLON]]]"  function_string "${function_string}")
	string(REPLACE "\n" ";" lines "${function_string}")
	set(res)
	foreach(line ${lines})
		string(FIND "${line}" "![[[SEMICOLON]]]" hasSemicolon)
		if(${hasSemicolon} GREATER "-1")
			string(SUBSTRING "${line}" 0 ${hasSemicolon} part1)
			math(EXPR hasSemicolon "${hasSemicolon} + 16")
			string(SUBSTRING "${line}" ${hasSemicolon} "-1" part2)

			#string(REPLACE "" "${sc}" line "${line}")
			set(res ${res} "${part1}" "![[[SEMICOLON]]]" "${part2}")
		else()
			set(res ${res} ${line})
		endif()
	endforeach()

	return_ref(res)
endfunction()

# File: source/function/function_new.cmake

# creates a and defines a function (with random name)
function(function_new )
	#generate a unique function id

	set(name_base "${__current_constructor}_${__current_member}")
	string_normalize("${name_base}")
	ans(name_base)

	set(id "${name_base}")
	if("${name_base}" STREQUAL "_")
		set(name_base "__func")
		set(id "__func_1111111111")
	endif()

	while(TRUE)
		if(NOT COMMAND "${id}")
			#declare function
			function("${id}")
				message(FATAL_ERROR "function is declared, not defined")
			endfunction()
			return_ref(id)
		endif()
		#message("making_id because ${id} alreading existers")
		make_guid()
		ans(id)
		set(id "${name_base}_${id}")
	endwhile()


endfunction()

## faster, but less debug info 
macro(function_new )
	identifier(function)
endmacro()

# File: source/function/function_parse.cmake


function(function_parse function_ish)
  is_function(function_type "${function_ish}")
  if(NOT function_type)
    creturn()
  endif()
  function_string_get( "${function_ish}")
  ans(function_string)
  
  if(NOT function_string)
    creturn()
  endif()

  function_signature_regex(regex)
  function_signature_get( "${function_string}")
  ans(signature)

  string(REGEX REPLACE ${regex} "\\1" func_type "${signature}" )
  string(REGEX REPLACE ${regex} "\\2" func_name "${signature}" )
  string(REGEX REPLACE ${regex} "\\3" func_args "${signature}" )

  string(STRIP "${func_name}" func_name)

  # get args
  string(FIND "${func_args}" ")" endOfArgsIndex)
  string(SUBSTRING "${func_args}" "0" "${endOfArgsIndex}" func_args)

  if(func_args)
    string(REGEX MATCHALL "[A-Za-z0-9_\\\\-]+" all_args ${func_args})
  endif()

  string(SUBSTRING "${func_args}" 0 ${endOfArgsIndex} func_args)
  string(TOLOWER "${func_type}" func_type)


  map_new()
  ans(res)
  map_set(${res} type "${func_type}")
  map_set(${res} name "${func_name}")
  map_set(${res} args "${all_args}")
  map_set(${res} code "${function_string}")

  creturn(${res})
endfunction()



# File: source/function/function_signature_get.cmake

#
function(function_signature_get func)
	function_lines_get( "${func}")
  ans(lines)
	#function_signature_regex(regex)
	foreach(line ${lines})
		string(REGEX MATCH "^[ ]*([mM][aA][cC][rR][oO]|[fF][uU][nN][cC][tT][iI][oO][nN])[ ]*\\([ \n\r]*([A-Za-z0-9_\\\\-]*)(.+)\\)" found "${line}")
		if(found)
      return_ref(line)
		endif()
	endforeach()
  creturn()
endfunction()

# File: source/function/function_signature_regex.cmake

function(function_signature_regex result)
	set(${result} "^[ ]*([mM][aA][cC][rR][oO]|[fF][uU][nN][cC][tT][iI][oO][nN])[ ]*\\([ ]*([A-Za-z0-9_\\\\-]*)(.*)\\)" PARENT_SCOPE)
endfunction()

# File: source/function/function_string_get.cmake

## returns the implementation of the function (a string containing the source code)
## this only works for functions files and function strings. CMake does not offer
## a possibility to get the implementation of a defined function or macro.
function(function_string_get func)
    is_function_string(is_string "${func}")
    if (is_string)
        return_ref(func)
        creturn()
    endif ()

    is_function_ref(is_ref "${func}")
    if (is_ref)
        is_address(${func})
        ans(is_ref_ref)

        if (is_ref_ref)
            address_get(${func})
            ans(res)
            return_ref(res)
            creturn()
        else ()
            set(${func} ${${func}})
        endif ()
    endif ()


    path("${func}")
    ans(fpath)
    is_function_file(is_file "${fpath}")


    if (is_file)
        load_function(file_content "${fpath}")
        function_string_get("${file_content}")
        ans(file_content)
        return_ref(file_content)
        creturn()
    endif ()


    is_function_cmake(is_cmake_func "${func}")

    if (is_cmake_func)
        ## todo: just return nothing as func is already correctly defined...
        set(source "macro(${func})\n ${func}(\${ARGN})\nendmacro()")
        return_ref(source)
        creturn()
    endif ()

    if (NOT (is_string OR is_file OR is_cmake_func))
        message(FATAL_ERROR "the following is not a function: '${func}'")
    endif ()
    creturn()

    lambda_parse("${func}")
    ans(parsed_lambda)

    if (parsed_lambda)
        return_ref(parsed_lambda)
        creturn()
    endif ()
endfunction()

# File: source/function/function_string_import.cmake

function(function_string_import function_string)
  set_ans("")
  eval("${function_string}")
  creturn()
endfunction()

# File: source/function/function_string_rename.cmake


# injects code into  function (right after function is called) and returns result
function(function_string_rename input_function new_name) 
	function_string_get( "${input_function}")
	ans(function_string)
	function_signature_regex(regex)

	function_lines_get( "${input_function}")
	ans(lines)
	
	foreach(line ${lines})
		string(REGEX MATCH "${regex}" found "${line}")
		if(found)
			string(REGEX REPLACE "${regex}"  "\\1(${new_name} \\3)" new_line "${line}")
			string_replace_first("${input_function}" "${line}" "${new_line}")
			ans(input_function)
			break()
		endif()
	endforeach()
	return_ref(input_function)
endfunction()

# File: source/function/invocation_argument_encoded_list.cmake


  function(invocation_argument_encoded_list)
    arguments_encoded_list(0 ${ARGC})
    return_ans()
  endfunction()

# File: source/function/invocation_argument_string.cmake

function(invocation_argument_string)
  arguments_string(0 ${ARGC})
  return_ans()
endfunction()

# File: source/function/invocation_arguments_sequence.cmake

  function(invocation_arguments_sequence)
    arguments_sequence(0 ${ARGC})
    return_ans()
  endfunction()


# File: source/function/is_anonymous_function.cmake


function(is_anonymous_function)
  if(NOT ARGN)
    creturn(false)
  elseif("${ARGN}" MATCHES "^\\([^\\)]*\\)")
    creturn(code)
  elseif(COMMAND "${ARGN}" AND "${ARGN}" MATCHES "^anonymous_[a-zA-Z0-9_]+$")
    creturn(instance)
  endif()
  message("${ARGN}")
  creturn(false)
endfunction()


# File: source/function/is_function.cmake

#returns true if the the val is a function string or a function file
function(is_function result val)
	is_lambda("${val}")
	ans(is_lambda)
	if(is_lambda)
		creturn(lambda)
	endif()

	is_function_string(is_func "${val}")
	if(is_func)
		return_value(string)
	endif()
	is_function_cmake(is_func "${val}")
	if(is_func)
		return_value(cmake)
	endif()
	
	if(is_function_called)
		return_value(false)
	endif()
	is_function_file(is_func "${val}")
	if(is_func)		
		return_value(file)
	endif()
	set(is_function_called true)
	is_function_ref(is_func "${val}")
	if(is_func)
		return_value(${is_func})
	endif()


	return_value(false)
endfunction()

# File: source/function/is_function_cmake.cmake

function(is_function_cmake result name)
	if(COMMAND "${name}")
		return_value(true)
	else()
		return_value(false)
	endif()
endfunction()

# File: source/function/is_function_file.cmake

function(is_function_file result function_file)
	path("${function_file}")
	ans(function_file)
	
	if(NOT EXISTS "${function_file}")
		return_value(false)
	endif()

	if(IS_DIRECTORY "${function_file}")
		return_value(false)
	endif()

	file(READ "${function_file}" input)
	if(NOT input)
		return_value(false)
	endif()
	#is_function_string(res ${input})
	is_function(res "${input}")
	
	return_value(${res})
endfunction()

# File: source/function/is_function_ref.cmake

function(is_function_ref result func)
	is_address("${func}" )
  ans(is_ref)
	if(NOT is_ref)
		creturn(false)
	endif()
	address_get(${func} )
  ans(val)
	is_function(res "${val}")
	return_value(${res})
	
endfunction()

# File: source/function/is_function_string.cmake

#returns true if the the string val is a function
function(is_function_string result val)
	if(NOT val)
		return_value(false)
	endif()
	#string(MD5 hash "${val}")
	#set(hash "hash_${hash}")
	#get_property(was_checked GLOBAL PROPERTY "${hash}")
	#if(was_checked)
	#return_value(${was_checked})
	#endif()

	string(REGEX MATCH ".*([mM][aA][cC][rR][oO]|[fF][uU][nN][cC][tT][iI][oO][nN])[ ]*\\(" function_found "${val}")
	if(NOT function_found)
		return_value(false)
	endif()
	#set_property(GLOBAL PROPERTY "${hash}" true)
	return_value(true)

endfunction()

# File: source/function/lambda/is_lambda.cmake


function(is_lambda callable)
  if("${callable}" MATCHES "^\\[[a-zA-Z0-9_ ]*]*\\]\\([[a-zA-Z0-9_ ]*\\)")
    creturn(true)
  endif()
    creturn(false)
endfunction()

# File: source/function/lambda/lambda.cmake

##
## returns the cmake function that this lambda was compiled to
function(lambda2 source)
  lambda2_instanciate("${source}")
  ans(lambda)
  map_tryget(${lambda} function_name)
  return_ans()
endfunction()



# File: source/function/lambda/lambda_compile.cmake

##
## compiles a lambda expression to valid cmake source and returns it
## {{a}} -> ${a}
## ["["<capture>"]"]["("<arg defs>")"] [(<expression>";")*]
## 
## 
function(lambda2_compile source)
  string_encode_list("${source}")
  ans(source)
  string_codes()
  regex_cmake()

  string_take_whitespace(source)

  set(capture_group_regex "${bracket_open_code}([^${bracket_close_code}]*)${bracket_close_code}")
  if("${source}" MATCHES "^(${capture_group_regex})(.*)")
    set(capture "${CMAKE_MATCH_2}")
    set(source "${CMAKE_MATCH_3}")
    string(REPLACE " " ";" capture "${capture}")
  else() 
    set(capture)
  endif()

  string_take_whitespace(source)
  if("${source}" MATCHES "^\\(([^\\)]*)\\)(.*)")
    set(signature "${CMAKE_MATCH_1}")
    set(source "${CMAKE_MATCH_2}")
  else()

  endif()



  string_take_whitespace(source)

  lambda2_compile_source("${source}")
  ans(cmake_source)
    




  map_capture_new(signature capture source cmake_source)

  return_ans()

endfunction()


# File: source/function/lambda/lambda_compile_source.cmake


  function(lambda2_compile_source source)
    string(ASCII 5 string_token)
    
    ## remove semicolons and brackets
    string_encode_list("${source}")
    ans(source)

    #  extract all delimited strings
    regex_delimited_string(' ')
    ans(regex_delimited_string)
    string(REGEX MATCHALL "${regex_delimited_string}" strings "${source}")
    string(REGEX REPLACE "${regex_delimited_string}" "${string_token}" source "${source}")


    ## re add semicolons and brackets
    string_decode_list("${source}")
    ans(source)

    ## replace ; with \n and commas with ;
    set(code)
    foreach(line ${source})
      string(REPLACE "," ";" line "${line}")
      set(code "${code}${line}\n")
    endforeach()
    

    ## resubistitute all extracted strings
    while(true)
      list_pop_front(strings)
      ans(current_string)
      if(NOT current_string)
        break()
      endif()
      string_decode_delimited("${current_string}" ' ')
      ans(current_string)

      string_decode_list("${current_string}")
      ans(current_string)

      cmake_string_escape("${current_string}")
      ans(current_string)

      string_replace_first("${code}" "${string_token}" "\"${current_string}\"")
      ans(code)
    endwhile()

    regex_cmake()

    ## replace {{}} with ${__ans}
    string(REPLACE  "{{}}" "${string_token}" code "${code}" )
    string(REGEX REPLACE "${string_token}" "${string_token}{__ans}" code "${code}")

    ## replace {{<identifier>}} with ${<identifier>}
    string(REGEX REPLACE "{{(${regex_cmake_identifier})}}" "${string_token}{\\1}" code "${code}")
    string(REPLACE "${string_token}" "\$" code "${code}" )

    ## end with returns_ans which forwards last return value
    set(code "${code}return_ans()")
    return_ref(code)

  endfunction()

# File: source/function/lambda/lambda_import.cmake

function(lambda2_tryimport callable)
  if("${callable}" MATCHES "^\\[[a-zA-Z0-9_ ]*]*\\]\\([[a-zA-Z0-9_ ]*\\)")
    lambda2_instanciate("${callable}" ${ARGN})
    ans(res)
    return_ref(res)
  endif()
  creturn()
endfunction()


# File: source/function/lambda/lambda_instanciate.cmake



  function(lambda2_instanciate source)

    lambda2_compile("${source}")
    ans(lambda)

    map_tryget(${lambda} capture)
    ans(captures)
    set(capture_code)    
    foreach(capture ${captures})
      set(capture_code "${capture_code}\n  set(${capture} \"${${capture}}\")")
    endforeach()


    set(function_name ${ARGN})
    if(NOT function_name)
      function_new()
      ans(function_name)
    endif()
    map_set(${lambda} function_name ${function_name})

    map_tryget(${lambda} cmake_source)
    ans(cmake_source)
    map_tryget(${lambda} signature)
    ans(signature) 
    set(source "function(${function_name} ${signature})${capture_code}\n${cmake_source}\nendfunction()")
    eval("${source}")
    map_set(${lambda} cmake_function "${source}")
    return_ref(lambda)
  endfunction()


# File: source/function/load_function.cmake

# reads a functions and returns it
function(load_function result file_name)	
	file(READ ${file_name} func)	
	set(${result} ${func} PARENT_SCOPE)
endfunction()

# File: source/function/rcall.cmake

# allows a single line call with result 
# ie rcall(some_result = obj.getSomeInfo(arg1 arg2))
function(rcall __rcall_result_name equals __callable)
  set_ans("")
  call("${__callable}" ${ARGN})
  ans(res)
  set(${__rcall_result_name} ${res} PARENT_SCOPE)
  return_ref(res)
endfunction()

# File: source/function/save_function.cmake



function(save_function file_name function_string)
	
	file(WRITE "${file_name}" "${function_string}")
endfunction()

# File: source/function/try_call.cmake


function(try_call)
  set(args ${ARGN})
  list_pop_front(args)
  ans(func)
  is_function(is_func "${func}")
  if(is_func)
    creturn()
  endif()
  call(${ARGN})
  return_ans()
endfunction()

# File: source/function/wrap_platform_specific_function.cmake

## defines the function called ${function_name} to call an operating system specific function
## uses ${CMAKE_SYSTEM_NAME} to look for a function called ${function_name}${CMAKE_SYSTEM_NAME}
## if it exists it is wrapped itno ${function_name}
## else ${function_name} is defined to throw an error if it is called
function(wrap_platform_specific_function function_name)
  os()
  ans(os_name)
  set(specificname "${function_name}_${os_name}")
  if(NOT COMMAND "${specificname}")      
    eval("
    function(${function_name})
      message(FATAL_ERROR \"operation is not supported on ${os_name} - look at document of '${function_name}' and implement a function with a matching interface called '${specificname}' for you own system\")        
    endfunction()      
    ")
  else()
    eval("
      function(${function_name})
        ${function_name}_${os_name}(\${ARGN})
        return_ans()
      endfunction()
    ")
    
  endif()
  creturn()
endfunction()


# File: source/handlers/command_line_handler.cmake


  function(command_line_handler)
    this_set(name "${ARGN}")

    ## forwards the object call operation to the run method
    this_declare_call(call)
    function(${call})

      obj_member_call(${this} run ${ARGN})
      ans(res)
      return_ref(res)
    endfunction()

    method(run)
    function(${run})
      handler_request(${ARGN})
      ans(request)
      assign(handler = this.find_handler(${request}))
      list(LENGTH handler handler_count)  


      if(${handler_count} GREATER 1)
        return_data("{error:'ambiguous_handler',description:'multiple command handlers were found for the request',request:$request}" )
      endif()

      if(NOT handler)
        return_data("{error:'no_handler',description:'command runner could not find an appropriate handler for the specified arguments',request:$request}")
      endif() 
      ## remove first item
      assign(request.input[0] = '') 
      set(parent_handler ${this})
      assign(result = this.execute_handler(${handler} ${request}))
      return_ref(result)

    endfunction()


    method(run_interactive)
    function(${run_interactive})
      if(NOT ARGN)
        echo_append("please enter a command>")
        read_line()
        ans(command)
      else()
        echo("executing command '${ARGN}':")
        set(command "${ARGN}")
      endif()
      obj_member_call(${this} run ${command})
      ans(res)
      table_serialize(${res})
      ans(formatted)
      echo(${formatted})
      return_ref(res)
    endfunction()

    ## compares the request to the handlers
    ## returns the handlers which matches the request
    ## can return multiple handlers
    method(find_handler)
    function(${find_handler})
      handler_request("${ARGN}")
      ans(request)
      this_get(handlers)
      handler_find(handlers "${request}")
      ans(handler)
      return_ref(handler)
    endfunction()

    ## executes the specified handler 
    ## the handler must not be part of this command runner
    ## it takes a handler and a request and returns a response object
    method(execute_handler)
    function(${execute_handler} handler)
      handler_request(${ARGN})
      ans(request)
      map_set(${request} runner ${command_line_handler})
      map_new()
      ans(response)
      handler_execute("${handler}" ${request} ${response})
      return_ref(response)
    endfunction()

    ## adds a request handler to this command handler
    ## request handler can be any function/function definition 
    ## or handler object
    method(add_handler)
    function(${add_handler})
      request_handler(${ARGN})
      ans(handler)
      if(NOT handler)
        creturn()
      endif()
      map_append(${this} handlers ${handler})
      
      creturn(${handler})
    endfunction()

  ## property contains a managed list of handlers
  property(handlers)
  ## setter
  function(${set_handlers} obj key new_handlers)
    map_tryget(${this} handlers)
    ans(old_handlers)
    if(old_handlers)
      list(REMOVE_ITEM new_handlers ${old_handlers})
    endif()

    set(result)
    foreach(handler ${new_handlers})
      set_ans("")
      obj_member_call(${this} add_handler ${handler})
      ans(res)
      list(APPEND result ${res})
    endforeach()
    return_ref(result)
  endfunction()
  ## getter
  function(${get_handlers})
    map_tryget(${this} handlers)
    return_ans()
  endfunction()


endfunction()



# File: source/handlers/handler_default.cmake




  ## creates a default handler from the specified cmake function
  function(handler_default func)
    if(NOT COMMAND "${func}")
      creturn()
    endif()
      function_new()
      ans(call_function)
      function_import("
        function(funcname request response)
          map_tryget(\${request} input)
          ans(input)
          ${func}(\"\${input}\")
          ans(res)
          map_set(\${response} output \"\${res}\")
          creturn(true)
        endfunction()
        " as ${call_function} REDEFINE)

    data("{
      callable:$call_function,
      display_name:$func,
      labels:$func
      }")
    ans(handler)

    request_handler("${handler}")
    return_ans()

  endfunction()



# File: source/handlers/handler_execute.cmake


  ## executes a handler
  function(handler_execute handler request)
    request_handler(${handler})
    ans(handler)
    data(${request})
    ans(request)
    data(${ARGN})
    ans(response)
    if(NOT response)
      data("{output:''}")
      ans(reponse)
    endif()
    assign(!response.request = request)
    if(NOT handler)
      assign(!response.error = 'handler_invalid')
      assign(!response.message = "'handler was not valid'")
    else()
      assign(!response.handler = handler)
      map_tryget(${handler} callable)
      ans(callback)
      call("${callback}"("${request}" "${response}"))
      ans(result)
    endif()
    return_ref(response)
  endfunction()

# File: source/handlers/handler_find.cmake

# returns those handlers in handler_lst which match the specified request  
  function(handler_find handler_lst request)
    set(result)
    foreach(handler ${${handler_lst}})
      handler_match(${handler} ${request})
      ans(res)
      if(res)
        list(APPEND result ${handler})
      endif()
    endforeach()

    return_ref(result)
  endfunction() 


# File: source/handlers/handler_match.cmake

## checks of the handler can handle the specified request
## this is done by look at the first input argument and checking if
## it is contained in labels
function(handler_match handler request)
    map_tryget(${handler} labels)
    ans(labels)

    map_tryget(${request} input)
    ans(input)

    list_pop_front(input)
    ans(cmd)

    list_contains(labels "${cmd}")
    ans(is_match)

    return_ref(is_match)
endfunction()

# File: source/handlers/handler_request.cmake


  function(handler_request)
    set(request "${ARGN}")
    is_map("${request}")
    ans(is_map)

    if(NOT is_map)
      map_new()
      ans(request)
      map_set(${request} input ${ARGN})
    endif()
    return_ref(request)
  endfunction()

# File: source/handlers/request_handler.cmake

## creates a handler 
## 
function(request_handler handler)
  data("${handler}")
  ans(handler)
  is_map(${handler})
  ans(is_map)
  
  if(is_map)  
    map_tryget(${handler} callable)
    ans(callable)
    if(NOT COMMAND "${callable}")
      function_new()
      ans(new_callable)
      function_import("${callable}" as "${new_callable}" REDEFINE)
      map_set(${handler} callable "${new_callable}")
    endif()
    creturn(${handler})
  endif()

  if(COMMAND "${handler}")
    set(callable ${handler})
    if(NOT ARGN)
      handler_default("${callable}")
      return_ans()
    endif()
  else()
    function_new()
    ans(callable)
    function_import(${handler} as ${callable} REDEFINE)
    set(callable ${callable})
  endif()
  map_capture_new(
    callable
  )
  return_ans()
endfunction()

# File: source/indent_level/indent.cmake



  function(indent str)
    indent_get(${ARGN})
    ans(indent)
    set(str "${indent}${str}")
    return_ref(str)
  endfunction()


# File: source/indent_level/indent_get.cmake


  function(indent_get)
    list(LENGTH ARGN len)
    set(indent "  ")
    if(len)
      set(indent "${ARGN}")
    endif()
    indent_level()
    ans(lvl)
    string_repeat("${indent}" "${lvl}")
    return_ans()
  endfunction()

# File: source/indent_level/indent_level.cmake


  function(indent_level)
    map_peek_back(global __indentlevelstack)
    ans(lvl)
    if(NOT lvl)
      creturn(0)
    endif()
    return_ref(lvl)
  endfunction()

# File: source/indent_level/indent_level_current.cmake

## returns the current index level index which can be used to 
## restore the index level to a specific point
  function(indent_level_current)
    map_property_length(global __indentlevelstack)
    ans(idx)
    math(EXPR idx "${idx} -1")
    if("${idx}" LESS 0)
      set(idx 0)
    endif()
    return_ref(idx)
  endfunction()

# File: source/indent_level/indent_level_pop.cmake


  function(indent_level_pop)
    map_pop_back(global __indentlevelstack)
    indent_level_current()
    return_ans()
   endfunction()

# File: source/indent_level/indent_level_push.cmake


  function(indent_level_push)
    set(new_lvl ${ARGN})
    if("${new_lvl}_" STREQUAL "_")
      set(new_lvl +1)
    endif()
    if("${new_lvl}" MATCHES "^[+\\-]")
      indent_level()
      ans(current_level)
      math(EXPR new_lvl "${current_level} ${new_lvl}")
    endif()
    map_push_back(global __indentlevelstack "${new_lvl}")
    indent_level_current()
    return_ans()
  endfunction()

# File: source/indent_level/indent_level_restore.cmake


  function(indent_level_restore)
    set(target ${ARGN})
    while(true)
      indent_level_current()
      ans(current_level)
      if("${target}" LESS "${current_level}")
        map_pop_back(global __indentlevelstack)
      else()
        break()
      endif()
    endwhile()
    creturn()
  endfunction()

# File: source/indent_level/indent_level_test.cmake

function(test)



  indent_level_push(0)

  indent("asd" "...")
  ans(res)
  assert(${res} STREQUAL "asd")

  indent_level_push(+1)
  ans(storedlevel)
  indent("asd" "...")
  ans(res)
  assert(${res} STREQUAL "...asd")

  indent_level_push(+1)
  indent_level()
  ans(lvl)
  assert(${lvl} EQUAL 2)
  indent("asd" "...")
  ans(res)
  assert(${res} STREQUAL "......asd")


  indent_level_push()
  indent_level()
  ans(lvl)
  assert(${lvl} EQUAL 3)


  indent_level_restore(${storedlevel})
  indent_level()
  ans(lvl)
  assert(${lvl} EQUAL 1)

  
  

  indent_level_pop()


endfunction()

# File: source/interaction/query_select.cmake


  function(query_select __lst input_callback)
    set(args ${ARGN})
    list_extract_flag(args --index)
    ans(index)
    set(i 0)
    list(LENGTH ${__lst} len)

    message_indent_push(+2)
    foreach(item ${${__lst}})
      message("${i}: ${item}") 
      math(EXPR i "${i} + 1")
    endforeach()
    message_indent_pop()
    while(true)
      echo_append("> ")
      call("${input_callback}"())
      ans(selected_index)
    
      string_isnumeric("${selected_index}")
      ans(isnumeric)
      if(isnumeric)
        if("${selected_index}" GREATER 0 AND ${selected_index} LESS ${len})
          break()
        else()
          message_indent("please enter a positive number < ${len}")
        endif()
      else()
        list(FIND ${__lst} "${selected_index}" selected_index)
        if(NOT "${selected_index}_" STREQUAL "_")
          break()
        endif()
        message_indent("please enter a number")
      endif()
    endwhile()
    if(index)
      creturn(${selected_index})
    endif()
    list(GET ${__lst} ${selected_index} selected_value)
    return_ref(selected_value)
  endfunction()

# File: source/listings/listing.cmake


  function(listing)
    address_new()
    return_ans()    
  endfunction()




# File: source/listings/listing_append.cmake


  function(listing_append listing line)
    string_combine(" " ${ARGN})
    ans(rest)
    string_encode_semicolon("${line}${rest}")
    ans(line)
    address_append("${listing}" "${line}")
    creturn()
  endfunction()

# File: source/listings/listing_append_lines.cmake



  function(listing_append_lines listing)
   foreach(line ${ARGN})
    listing_append(${listing} "${line}")
   endforeach()
  endfunction()

# File: source/listings/listing_begin.cmake



  function(listing_begin)
    listing()
    ans(lst)
    set(__listing_current "${lst}" PARENT_SCOPE)
  endfunction()

# File: source/listings/listing_combine.cmake



  function(listing_combine)
    listing()
    ans(lst)
    foreach(listing ${ARGN})
      address_get(${listing})
      ans(current)
      address_append("${lst}" "${current}")
    endforeach()
    creturn(${lst})
  endfunction()

# File: source/listings/listing_compile.cmake



  function(listing_compile listing)
    address_get("${listing}")
    ans(code)
    set(indent_on while if function foreach macro else elseif)
    set(unindent_on endwhile endif endfunction endforeach endmacro else elseif)
    set(current_indentation "")
    set(indented)


    foreach(line ${code})
      string(STRIP "${line}" line)
      string_take_regex(line "[^\\(]+")
      ans(func_name)
      if(func_name)
        list_contains(unindent_on ${func_name})
        ans(unindent)
        if(unindent)
          string_take(current_indentation "  ")
        endif()
        set(line "${current_indentation}${func_name}${line}")
        list_contains(indent_on ${func_name})
        ans(indent)
        if(indent)
          set(current_indentation "${current_indentation}  ")
        
        endif()
      endif()
      list(APPEND indented "${line}")
    endforeach()
    string(REPLACE ";" "\n" code "${indented}")
    string_decode_semicolon("${code}")
    ans(code)
    string(REPLACE "'" "\"" code "${code}")
    string(REGEX REPLACE "([^$]){([a-zA-Z0-9\\-_\\.]+)}" "\\1\${\\2}" code "${code}")
    return_ref(code)
  endfunction()

# File: source/listings/listing_end.cmake


  function(listing_end)
    set(lst ${__listing_current})
    set(__listing_current PARENT_SCOPE)
    return_ref(lst)
  endfunction()

# File: source/listings/listing_end_compile.cmake



  macro(listing_end_compile)
    listing_end()
    listing_compile("${__ans}")
  endmacro()

# File: source/listings/listing_include.cmake


  function(listing_include listing)
    listing_compile("${listing}")
    eval("${__ans}")
    return_ans()
  endfunction()


# File: source/listings/listing_line.cmake



  function(line line)
    listing_append("${__listing_current}" "${line}")
  endfunction()


# File: source/listings/listing_make_compile.cmake





  function(listing_make_compile)
    listing()
    ans(uut)
    foreach(line ${ARGN})
      listing_append(${uut} "${line}")
    endforeach()
    listing_compile(${uut})
    return_ans()
  endfunction()


# File: source/log/error.cmake

## `error(...)-><log entry>`
##
## Shorthand function for `log(<message> <refs...> --error)
## 
## see [log](#log)
##
function(error)
  log(--error ${ARGN})  
  return_ans()
endfunction()




# File: source/log/fatal.cmake

## reports an error and stops program exection 
function(fatal)
  log(--error ${ARGN})
  ans(entry)

  map_tryget("${entry}" message)
  ans(message)

  _message(FATAL_ERROR "aborting exectution because of error '${message}'")
  creturn()
    
endfunction()


# File: source/log/log.cmake

## `log(<message:<string>> <refs...> [--error]|[--warning]|[--info]|[--debug]) -> <void>`
##
## This is the base function on which all of the logging depends. It transforms
## every log message into a object which can be consumed by listeners or filtered later
##
## *Note*: in its current state this function is not ready for use
##
## * returns
##   * the reference to the `<log entry>`
## * parameters
##   * `<message>` a `<string>` containing the message which is to be logged the data may be formatted (see `format()`)
##   * `<refs...>` you may pass variable references which will be captured so you can later check the state of the application when the message was logged
## * flags
##   * `--error`    flag indicates that errors occured
##   * `--warning`  flag indicates warnings
##   * `--info`     flag indicates a info output
##   * `--debug`    flag indicates a debug output
## * values
##   * `--error-code <code>` 
##   * `--level <n>` 
##   * `--push <section>` depth+1
##   * `--pop <section>`  depth-1
## * events
##   * `on_log_message`
##
## *Examples*
## ```
## log("this is a simple error" --error) => <% 
##   log("this is a simple error" --error) 
##   template_out_json("${__ans}")
## %>
## ```
function(log)

  map_tryget(global log)
  ans(log)
  if(NOT log)
    map_new()
    ans(log)
    map_set(global log "${log}")
  endif()

  event_handlers(on_log_message)
  ans(has_handlers)
  if(NOT has_handlers)
    creturn()
  endif()


  set(args ${ARGN})
  list_extract_flag(args --warning)
  list_extract_flag(args --info)
  list_extract_flag(args --debug)
  list_extract_flag(args --aftereffect)
  list_extract_flag(args --trace)
  ans(aftereffect)
  list_extract_flag(args --error)
  ans(is_error)
  list_extract_labelled_value(args --level)
  list_extract_labelled_value(args --push)
  list_extract_labelled_value(args --pop)
  list_extract_labelled_value(args --error-code)
  list_extract_labelled_value(args --function)
  ans(function)

  if(function)
    set(member_function ${function})
  endif()
  if(__current_function_name)
    set(member_function "${__current_function_name}")
  endif()


  ans(error_code)
  map_new()
  ans(entry)
  set(message "${args}")
  format("${message}")
  ans(message)
  if(aftereffect)
    log_last_error_entry()
    ans(last_error)
    map_set(${entry} preceeding_error ${last_error})
  endif()
  map_set(${entry} message ${message})
  ##map_set(${entry} args this ${args})
  map_set(${entry} function ${member_function})
  map_set(${entry} error_code ${error_code})
  set(type)
  if(is_error OR NOT error_code STREQUAL "")
    set(type error)
  endif()
  event_emit(on_log_message ${entry})
  map_set(${entry} type ${type})
  address_append(log_record ${entry})
  return_ref(entry)
endfunction()


# File: source/log/log_clear.cmake

## `log_record_clear()-><void>`
## 
## removes all messages from the log record
##
##
function(log_record_clear)
  address_set(log_record)
  creturn()
endfunction()




# File: source/log/log_default_handler.cmake

function(log_default_handler)
  event_addhandler(on_log_message "[](msg) message(FORMAT '{msg.function}> {msg.message}') ")
  ans(handler)
  creturn(${handler})
endfunction()

# File: source/log/log_last_error_entry.cmake

## `log_last_error_entry()-><log entry>`
##
## returns the last log entry which is an error
## 
function(log_last_error_entry)
  address_get(log_record)
  ans(log_record)
  set(entry)
  while(true)
    if(NOT log_record)
      break()
    endif()
    list_pop_back(log_record)
    ans(entry)

    map_tryget(${entry} type)
    ans(type)
    if(type STREQUAL "error")
      break()
    endif()
  endwhile()
  return_ref(entry)
endfunction()



# File: source/log/log_last_error_message.cmake

## `log_last_error_message()-><string>`
##
## returns the last logged error message
##
function(log_last_error_message)
  log_last_error_entry()
  ans(entry)
  if(NOT entry)
    creturn()
  endif()

  map_tryget(${entry} message)
  ans(message)


  return_ref(message)
endfunction()


# File: source/log/log_last_error_print.cmake

## `log_last_error_print()-><void>`
##
## prints the last error message to the console  
##
function(log_last_error_print)
  log_last_error_entry()
  ans(entry)
  if(NOT entry)
    creturn()
  endif()

  message(FORMAT "Error in {entry.function}: {entry.message}")
  while(true)
    map_tryget(${entry} preceeding_error)
    ans(entry)
    if(NOT entry)
      break()
    endif()
    message(FORMAT "  because of {entry.function}: {entry.message}")
  endwhile()
  creturn()
endfunction()


# File: source/log/log_print.cmake

## `log_print`
##
##
function(log_print)
  set(limit ${ARGN})

  address_get(log_record)
  ans(entries)

  list(LENGTH entries len)



  if("${limit}_" STREQUAL "_")
    math(EXPR limit "${len}")
  endif()

  if("${limit}" EQUAL 0)
    creturn()
  endif()

  foreach(i RANGE 1 ${limit})
    list_pop_back(entries)
    ans(entry)
    if(NOT entry)
      break()
    endif()
    message(FORMAT "{entry.type} @ {entry.function}: {entry.message}")
  endforeach()

endfunction()

# File: source/log/warning.cmake

function(warning ${ARGN})
  return_ans()
endfunction()

# File: source/map/core/is_map.cmake

## `(<any>...)-><bool>`
##
## returns true iff the specified value is a map
## note to self: cannot make this a macro because string will be evaluated
function(is_map)
	get_property(is_map GLOBAL PROPERTY "${ARGN}.__keys__" SET)
	set(__ans "${is_map}" PARENT_SCOPE)
endfunction()

# File: source/map/core/map_append.cmake

# appends a value to the end of a map entry
function(map_append map key)
  get_property(isset GLOBAL PROPERTY "${map}.${key}" SET)
	if(NOT isset)
		map_set(${map} ${key} ${ARGN})
		creturn()
	endif()
  set_property(GLOBAL APPEND PROPERTY "${map}.${key}" ${ARGN})
endfunction()


# File: source/map/core/map_append_string.cmake


function(map_append_string map key str)
  get_property(isset GLOBAL PROPERTY "${map}.${key}" SET)
  if(NOT isset)
    map_set(${map} ${key} "${str}")
    creturn()
  endif()
  get_property(property_val GLOBAL PROPERTY "${map}.${key}" )
  set_property(GLOBAL PROPERTY "${map}.${key}" "${property_val}${str}")
endfunction() 



function(map_append_string map key str)
  get_property(isset GLOBAL PROPERTY "${map}.${key}" SET)
  if(NOT isset)
    map_set(${map} ${key} "${str}")
  else()
    set_property(GLOBAL APPEND_STRING PROPERTY "${map}.${key}" "${str}")
  endif()
  set(__ans PARENT_SCOPE)
endfunction() 

# File: source/map/core/map_append_unique.cmake


## map_append_unique 
## 
## appends values to the <map>.<prop> and ensures 
## that <map>.<prop> stays unique 
function(map_append_unique map prop)
  map_tryget("${map}" "${prop}")
  ans(vals)
  list(APPEND vals ${ARGN})
  list_remove_duplicates(vals)
  map_set("${map}" "${prop}" ${vals})
endfunction()


# File: source/map/core/map_delete.cmake

function(map_delete this)
	map_keys("${this}")
	ans(keys)
	foreach(key ${keys})
		map_remove("${this}" ${key})
	endforeach()
endfunction()

# File: source/map/core/map_duplicate.cmake


  function(map_duplicate source)
    map_new()
    ans(duplicate)
    map_keys("${source}")
    ans(keys)
    foreach(key ${keys})
      map_tryget("${source}" "${key}")
      ans(val)
      map_set_hidden("${duplicate}" "${key}" ${val})
    endforeach()
    map_keys_set("${duplicate}" ${keys})
    return_ref(duplicate)
  endfunction()

# File: source/map/core/map_get.cmake


function(map_get this key)
  set(property_ref "${this}.${key}")
  get_property(property_exists GLOBAL PROPERTY "${property_ref}" SET)
  if(NOT property_exists)
    message(FATAL_ERROR "map '${this}' does not have key '${key}'")    
  endif()
  
  get_property(property_val GLOBAL PROPERTY "${property_ref}")
  return_ref(property_val)  
endfunction()
# faster way of accessing map.  however fails if key contains escape sequences, escaped vars or @..@ substitutions
# if thats the case comment out this macro
macro(map_get __map_get_map __map_get_key)
  set(__map_get_property_ref "${__map_get_map}.${__map_get_key}")
  get_property(__ans GLOBAL PROPERTY "${__map_get_property_ref}")
  if(NOT __ans)
    get_property(__map_get_property_exists GLOBAL PROPERTY "${__map_get_property_ref}" SET)
    if(NOT __map_get_property_exists)
      json_print("${__map_get_map}")
      message(FATAL_ERROR "map '${__map_get_map}' does not have key '${__map_get_key}'")    
    endif()
  endif()  
endmacro()



# File: source/map/core/map_get_special.cmake


function(map_get_special map key)
  map_tryget("${map}" "__${key}__")
  return_ans()
endfunction()

## faster
macro(map_get_special map key)
  get_property(__ans GLOBAL PROPERTY "${map}.__${key}__")
endmacro()

## correcter
function(map_get_special map key)
  get_property(__ans GLOBAL PROPERTY "${map}.__${key}__")
  set(__ans "${__ans}" PARENT_SCOPE)
endfunction()


# File: source/map/core/map_has.cmake




function(map_has this key )  
  get_property(res GLOBAL PROPERTY "${this}.${key}" SET)
  creturn(${res})
endfunction()

# faster way of accessing map.  however fails if key contains escape sequences, escaped vars or @..@ substitutions
# if thats the case comment out this macro
macro(map_has this key )  
  get_property(__ans GLOBAL PROPERTY "${this}.${key}" SET)
endmacro()





# File: source/map/core/map_keys.cmake

# returns all keys for the specified map
macro(map_keys this)
  get_property(__ans GLOBAL PROPERTY "${this}.__keys__")
  #return_ref(keys)
endmacro()
# returns all keys for the specified map
#function(map_keys this)
#  get_property(keys GLOBAL PROPERTY "${this}")
#  return_ref(keys)
#endfunction()


# File: source/map/core/map_new.cmake


## optimized version
macro(map_new)
  address_new()
  set_property(GLOBAL PROPERTY "${__ans}.__keys__" "") ## set keys (duck typing for map is that it has property keys)  
endmacro()

# File: source/map/core/map_remove.cmake


function(map_remove map key)
  map_has("${map}" "${key}")
  ans(has_key)
  ## set value to "" without updating key
  map_set_hidden("${map}" "${key}")
  if(NOT has_key)
    creturn(false)
  endif()
  get_property(keys GLOBAL PROPERTY "${map}.__keys__")
  list(LENGTH keys len)
  if(NOT len)
    creturn(false)
  endif()
  list(REMOVE_ITEM keys "${key}")
  set_property(GLOBAL PROPERTY "${map}.__keys__" "${keys}")
  creturn(true)
endfunction()

# File: source/map/core/map_remove_item.cmake


## map_remove_item
##
## removes the specified items from <map>.<prop>
## returns the number of items removed
function(map_remove_item map prop)
  map_tryget("${map}" "${prop}")
  ans(vals)
  list_remove(vals ${ARGN})
  ans(res)
  if(res)
    map_set_hidden("${map}" "${prop}" "${vals}")
  endif()
  return_ref(res)
endfunction()

# File: source/map/core/map_set.cmake

# set a value in the map
function(map_set this key )
  set(property_ref "${this}.${key}")
  get_property(has_key GLOBAL PROPERTY "${property_ref}" SET)
	if(NOT has_key)
		set_property(GLOBAL APPEND PROPERTY "${this}.__keys__" "${key}")
	endif()
	# set the properties value
	set_property(GLOBAL PROPERTY "${property_ref}" "${ARGN}")
endfunction()


# File: source/map/core/map_set_hidden.cmake

function(map_set_hidden map property)
  set_property(GLOBAL PROPERTY "${map}.${property}" ${ARGN})
endfunction()

# File: source/map/core/map_set_special.cmake


function(map_set_special map key)
  set_property(GLOBAL PROPERTY "${map}.__${key}__" "${ARGN}")
  #map_set_hidden("${map}" "__${key}__" "${ARGN}")
endfunction()

# File: source/map/core/map_tryget.cmake

# tries to get the value map[key] and returns NOTFOUND if
# it is not found

function(map_tryget map key)
  get_property(res GLOBAL PROPERTY "${map}.${key}")
  return_ref(res)
endfunction()

# faster way of accessing map.  however fails if key contains escape sequences, escaped vars or @..@ substitutions
# if thats the case comment out this macro
macro(map_tryget map key)
  get_property(__ans GLOBAL PROPERTY "${map}.${key}")
endmacro()

# File: source/map/dfs.cmake

# iterates a the graph with root nodes in ${ARGN}
# in depth first order
# expand must consider cycles
function(dfs expand)
  stack_new()
  ans(stack)
  curry3(() => stack_push("${stack}" /0))
  ans(push)
  curry3(() => stack_pop("${stack}" ))
  ans(pop)
  graphsearch(EXPAND "${expand}" PUSH "${push}" POP "${pop}" ${ARGN})
endfunction()


# File: source/map/dfs_callback.cmake


# emits events parsing a list of map type elements 
# expects a callback function that takes the event type string as a first argument
# follwowing events are called (available context variables are listed as subelements: 
# value
#   - list_length (may be 0 or 1 which is good for a null check)
#   - content_length (contains the length of the content)
#   - node (contains the value)
# list_begin
#   - list_length (number of elements the list contains)
#   - content_length (accumulated length of list elements + semicolon separators)
#   - node (contains all values of the lsit)
# list_end
#   - list_length(number of elements in list)
#   - node (whole list)
#   - list_char_length (length of list content)
#   - content_length (accumulated length of list elements + semicolon separators)
# list_element_begin
#   - list_length(number of elements in list)
#   - node (whole list)
#   - list_char_length (length of list content)
#   - content_length (accumulated length of list elements + semicolon separators)
#   - list_element (contains current list element)
#   - list_element_index (contains current index )   
# list_element_end
#   - list_length(number of elements in list)
#   - node (whole list)
#   - list_char_length (length of list content)
#   - content_length (accumulated length of list elements + semicolon separators)
#   - list_element (contains current list element)
#   - list_element_index (contains current index )
# visited_reference
#   - node (contains ref to revisited map)
# unvisited_reference
#   - node (contains ref to unvisited map)
# map_begin
#   - node( contains ref to map)
#   - map_keys (contains all keys of map)
#   - map_length (contains number of keys of map)
# map_end
#   - node( contains ref to map)
#   - map_keys (contains all keys of map)
#   - map_length (contains number of keys of map)
# map_element_begin
#   - node( contains ref to map)
#   - map_keys (contains all keys of map)
#   - map_length (contains number of keys of map)
#   - map_element_key (current key)
#   - map_element_value (current value)
#   - map_element_index (current index)
# map_element_end
#   - node( contains ref to map)
#   - map_keys (contains all keys of map)
#   - map_length (contains number of keys of map)
#   - map_element_key (current key)
#   - map_element_value (current value)
#   - map_element_index (current index)
function(dfs_callback callback)
  # inner function
  function(dfs_callback_inner node)
 

    is_map("${node}")
    ans(ismap)
    if(NOT ismap)
      list(LENGTH node list_length)
      string(LENGTH "${node}" content_length)
      if(${list_length} LESS 2)
        dfs_callback_emit(value)
      else()
        dfs_callback_emit(list_begin) 
        set(list_element_index 0)
        foreach(list_element ${node})
          list_push_back(path "${list_element_index}")
          dfs_callback_emit(list_element_begin)
          dfs_callback_inner("${list_element}")
          dfs_callback_emit(list_element_end)
          list_pop_back(path)
          math(EXPR list_element_index "${list_element_index} + 1")
        endforeach()
        dfs_callback_emit(list_end)
      endif()
      creturn()
    endif()

    map_tryget(${visited} "${node}")
    ans(was_visited)

    if(was_visited)
      dfs_callback_emit("visited_reference")
      creturn()
    else()
      dfs_callback_emit("unvisited_reference")
    endif()


    map_set(${visited} "${node}" true)

    map_keys("${node}")
    ans(map_keys)

    list(LENGTH map_keys map_length)

    dfs_callback_emit(map_begin)

    
    set(map_element_index 0)
    foreach(map_element_key ${map_keys})
      map_tryget("${node}" ${map_element_key})
      ans(map_element_value)
      list_push_back(path "${map_element_key}")
      dfs_callback_emit(map_element_begin)

      dfs_callback_inner("${map_element_value}")

      dfs_callback_emit(map_element_end)
      list_pop_back(path)

      math(EXPR map_element_index "${map_element_index} + 1")
    endforeach()


    dfs_callback_emit(map_end "${node}" )
  endfunction()

  function(dfs_callback callback)
#    curry3(dfs_callback_emit => "${callback}"(/0) as dfs_callback_emit)
    # faster
    eval("
function(dfs_callback_emit)
  ${callback}(\${ARGN})
endfunction()
")
    map_new()
    ans(visited)

   # foreach(arg ${ARGN})
   set(path)
    dfs_callback_inner("${ARGN}")
   # endforeach()
    creturn()
  endfunction()
  dfs_callback("${callback}" ${ARGN})
  return_ans()
endfunction()

# File: source/map/evaluate/map_conditional_default.cmake



  function(map_conditional_default parameters) 
    set(value ${ARGN})   
    map_clone_shallow("${value}")
    ans(value)
    
    is_map("${value}")
    ans(is_map)
    if(NOT is_map)
      return_ref(value)
    endif()


    foreach(key ${keys})
      map_tryget("${value}" "${key}")
      ans(val)
      map_conditional_evaluate("${parameters}" ${val})
      ans(val)
      map_set("${value}" "${key}" "${val}")
    endforeach()



    creturn(${value})

  endfunction()

# File: source/map/evaluate/map_conditional_evaluate.cmake



  function(map_conditional_evaluate parameters)
    set(result)
    foreach(map ${ARGN})
      map_conditional_single("${parameters}" "${map}")
      ans_append(result)
    endforeach()
    return_ref(result)
  endfunction()

# File: source/map/evaluate/map_conditional_if.cmake



  function(map_conditional_if parameters)
    
    set(map ${ARGN})

    map_tryget("${map}" $if)
    ans(condition)
  

        
    map_has("${map}" "$then")
    ans(has_then)

    map_has("${map}" "$else")
    ans(has_else)

    set(else)
    set(then)
    if(has_then OR has_else)
      map_tryget("${map}" $then)
      ans(then)
      map_tryget("${map}" $else)
      ans(else)
    else()
      set(then "${map}")
    endif()
    


    map_conditional_predicate_eval("${parameters}" "${condition}")    
    ans(evaluatedConditions)





    if(evaluatedConditions)
      set(result "${then}")
    else()
      set(result "${else}")
    endif()


    map_clone_shallow("${result}")
    ans(cloned)
    

    if("${result}_" STREQUAL "${map}_")
      map_keys_remove("${cloned}" $if $then $else)
    endif()
    


    map_conditional_evaluate("${parameters}" ${cloned})
    return_ans()
    
  endfunction()


# File: source/map/evaluate/map_conditional_predicate_eval.cmake


  function(map_conditional_predicate_eval parameters predicate)
    if("${predicate}_" STREQUAL "true_")
      creturn(true)
    elseif("${predicate}_" STREQUAL "false_")
      creturn(false)
    endif()
   # message(" map_conditional_predicate_eval>>>>   ${predicate}")
    eval_predicate_template_cmake("${parameters}" "${predicate}")
    return_ans()
  endfunction()


# File: source/map/evaluate/map_conditional_single.cmake


  function(map_conditional_single parameters)
      set(value ${ARGN})

      
      is_map(${value})
      ans(is_map)

      if(NOT is_map)
      
        return_ref(value)
      endif()
     
      
      map_keys(${value})
      ans(keys)


      list_peek_front(keys)
      ans(firstKey)


      if(firstKey MATCHES "^\\$(.*)$")
        set(type "${CMAKE_MATCH_1}")
        if(COMMAND "map_conditional_${type}")
          #message("map_conditional_${type}(\"\${parameters}\" \"\${value}\")")
          eval("map_conditional_${type}(\"\${parameters}\" \"\${value}\")")
          ans(value)
        else()
          map_conditional_default("${parameters}" "${value}")
          ans(value)
        endif()        
      else()
          map_conditional_default("${parameters}" "${value}")
          ans(value)      
      endif()
      

      return_ref(value)
  endfunction()


# File: source/map/evaluate/map_conditional_switch.cmake



  function(map_conditional_switch parameters)
    message("switch")
    creturn()
  endfunction()

# File: source/map/helpers/list_match.cmake



# matches the object list 
function(list_match __list_match_lst )
  map_matches("${ARGN}")
  ans(predicate)
  list_where("${__list_match_lst}" "${predicate}")
  return_ans()
endfunction()

# File: source/map/helpers/map_all_paths.cmake




# returns all possible paths for the map
# (currently crashing on cycles cycles)
# todo: implement
function(map_all_paths)
  message(FATAL_ERROR "map_all_paths is not implemented yet")

  function(_map_all_paths event)
    if("${event}" STREQUAL "map_element_begin")
      address_get(${current_path})
      ans(current_path)
      set(cu)
    endif()
    if("${event}" STREQUAL "value")
      address_new(${})
    endif()
  endfunction()

  address_new()
  ans(current_path)
  address_new()
  ans(path_list)

  dfs_callback(_map_all_paths ${ARGN})
endfunction()

# File: source/map/helpers/map_at.cmake


  ## returns the value at idx
  function(map_at map idx)
    map_key_at(${map} "${idx}")
    ans(key)
    map_tryget(${map} "${key}")
    return_ans()
  endfunction()

# File: source/map/helpers/map_capture.cmake

## captures the listed variables in the map
function(map_capture map)
    set(__map_capture_args ${ARGN})
    list_extract_flag(__map_capture_args --reassign)
    ans(__reassign)
    list_extract_flag(__map_capture_args --notnull)
    ans(__not_null)
    foreach (__map_capture_arg ${__map_capture_args})
        if (__reassign AND ${__map_capture_arg} MATCHES "(.+)[:=](.+)")
            set(__map_capture_arg_key ${CMAKE_MATCH_1})
            set(__map_capture_arg ${CMAKE_MATCH_2})
        else ()
            set(__map_capture_arg_key "${__map_capture_arg}")
        endif ()
#        print_vars(__map_capture_arg __map_capture_arg_key)
#        print_vars(__not_null)
        if (NOT __not_null OR NOT "${${__map_capture_arg}}_" STREQUAL "_")
            map_set(${map} "${__map_capture_arg_key}" "${${__map_capture_arg}}")
        endif ()
    endforeach ()
endfunction()



# File: source/map/helpers/map_capture_new.cmake

## captures a new map from the given variables
## example
## set(a 1)
## set(b 2)
## set(c 3)
## map_capture_new(a b c)
## ans(res)
## json_print(${res})
## --> 
## {
##   "a":1,
##   "b":2,
##   "c":3 
## }
function(map_capture_new)
  map_new()
  ans(__map_capture_new_map)
  map_capture(${__map_capture_new_map} ${ARGN})
  creturn(${__map_capture_new_map})
endfunction()

# File: source/map/helpers/map_clear.cmake



# removes all properties from map
function(map_clear map)
  map_keys("${map}")
  ans(keys)
  foreach(key ${keys})
    map_remove("${map}" "${key}")
  endforeach()
  creturn()
endfunction()

# File: source/map/helpers/map_coerce.cmake





   
    ## if `mapOrDefaultValue` is a map then just returns the map
    ## if not `mapOrDefaultValue` is assigned to a new map under the specified defaultKey
    function(map_coerce mapOrDefaultValue defaultKey) 
      is_map("${mapOrDefaultValue}")
      ans(isMap)
      if(NOT isMap)
        map_new()
        ans(map)
        map_set(${map} ${defaultKey} ${mapOrDefaultValue})
      else()
        set(map "${mapOrDefaultValue}")
      endif()
      creturn(${map})
    endfunction()

# File: source/map/helpers/map_copy_shallow.cmake

# copies the values of the source map into the target map by assignment
# (shallow copy)
function(map_copy_shallow target source)
  map_keys("${source}")
  ans(keys)

  foreach(key ${keys})
    map_tryget("${source}" "${key}")
    ans(val)
    map_set("${target}" "${key}" "${val}")
  endforeach()
  creturn()
endfunction()



# File: source/map/helpers/map_count.cmake

## `(<map>)-><uint>`
##
## returns the number of elements for the specified map
macro(map_count map)
  map_keys("${map}")
  list(LENGTH __ans __ans)
endmacro()

# File: source/map/helpers/map_defaults.cmake


# sets all undefined properties of map to the default value
function(map_defaults map defaults)
  obj("${defaults}")
  ans(defaults)
  if(NOT defaults)
    message(FATAL_ERROR "No defaults specified")
  endif()

  if(NOT map)
    map_new()
    ans(map)
  endif()

  map_keys("${map}")
  ans(keys)

  map_keys("${defaults}")
  ans(default_keys)


  if(default_keys AND keys)
    list(REMOVE_ITEM default_keys ${keys})
  endif()
  foreach(key ${default_keys})
    map_tryget("${defaults}" "${key}")
    ans(val)
    map_set("${map}" "${key}" "${val}")
  endforeach()
  return_ref(map)
endfunction()

# File: source/map/helpers/map_ensure.cmake

# ensures that the specified vars are a map
# parsing structured data if necessary
  macro(map_ensure)
    foreach(__map_ensure_arg ${ARGN})
      obj("${${__map_ensure_arg}}")
      ans("${__map_ensure_arg}")
    endforeach()
  endmacro()

# File: source/map/helpers/map_extract.cmake

function(map_extract navigation_expressions)
  cmake_parse_arguments("" "REQUIRE" "" "" ${ARGN})
  set(args ${_UNPARSED_ARGUMENTS})
  foreach(navigation_expression ${navigation_expressions})
    map_navigate(res "${navigation_expression}")
    list_pop_front( args)
    ans(current)
    if(_REQUIRE AND NOT res)
      message(FATAL_ERROR "map_extract failed: requires ${navigation_expression}")
    endif()

    if(current)
      set(${current} ${res} PARENT_SCOPE)
    else()
      if(NOT _REQUIRE)
       break()
      endif()
    endif()
  endforeach()
  foreach(arg ${args})
    set(${arg} PARENT_SCOPE)  
  endforeach()
  
endfunction()

# File: source/map/helpers/map_fill.cmake



  ## files non existing or null values of lhs with values of rhs
  function(map_fill lhs rhs)
    map_ensure(lhs rhs)
    map_iterator(${rhs})
    ans(it)
    while(true)
      map_iterator_break(it)
    
      map_tryget(${lhs} "${it.key}")
      ans(lvalue)

      if("${lvalue}_" STREQUAL "_")
        map_set(${lhs} "${it.key}" "${it.value}")
      endif()
    endwhile()
    return_ref(lhs)
  endfunction()

# File: source/map/helpers/map_flatten.cmake


  function(map_flatten)
    set(result)
    foreach(map ${ARGN})
      map_values(${map})
      ans_append(result)
    endforeach()
    return_ref(result)
  endfunction()

# File: source/map/helpers/map_from_keyvaluelist.cmake

# adds the keyvalues list to the map (if not map specified created one)
function(map_from_keyvaluelist map)
  if(NOT map)
    map_new()
    ans(map)
  endif()
  set(args ${ARGN})
  while(true)
    list_pop_front(args)
    ans(key)
    list_pop_front(args)
    ans(val)
    if(NOT key)
      break()
    endif()
    map_set("${map}" "${key}" "${val}")
  endwhile()
  return_ref(map)
endfunction()

# File: source/map/helpers/map_get_default.cmake

## `(<map> <key> <any...>)-><any...>`
##
## returns the value stored in map.key or 
## sets the value at map.key to ARGN and returns 
## the value
function(map_get_default map key)
  map_has("${map}" "${key}")
  ans(has_key)
  if(NOT has_key)
    map_set("${map}" "${key}" "${ARGN}")
  endif()
  map_tryget("${map}" "${key}")
  return_ans()
endfunction()

# File: source/map/helpers/map_get_map.cmake

## `(<map> <key>)-><map>`
##
## returns a map for the specified key
## creating it if it does not exist
##
function(map_get_map map key)
  map_tryget(${map} ${key})
  ans(res)
  is_address("${res}")
  ans(ismap)
  if(NOT ismap)
    map_new()
    ans(res)
    map_set(${map} ${key} ${res})
  endif()
  return_ref(res)
endfunction()



# File: source/map/helpers/map_has_all.cmake


# returns true if map has all keys specified
#as varargs
function(map_has_all map)

  foreach(key ${ARGN})
    map_has("${map}" "${key}")
    ans(has_key)
    if(NOT has_key)
      creturn(false)
    endif()
  endforeach()
  creturn(true)

endfunction()


# File: source/map/helpers/map_has_any.cmake


# returns true if map has any of the keys
# specified as varargs
function(map_has_any map)
  foreach(key ${ARGN})
    map_has("${map}" "${key}")
    ans(has_key)
    if(has_key)
      creturn(true)
    endif()
  endforeach()
  creturn(false)

endfunction()

# File: source/map/helpers/map_invert.cmake



# returns a copy of map with key values inverted
# only works correctly for bijective maps
function(map_invert map)
  map_keys("${map}")
  ans(keys)
  map_new()
  ans(inverted_map)
  foreach(key ${keys})
    map_tryget("${map}" "${key}")
    ans(val)
    map_set("${inverted_map}" "${val}" "${key}")
  endforeach()
  return_ref(inverted_map)
endfunction()

# File: source/map/helpers/map_isempty.cmake


  function(map_isempty map)
    map_keys(${map})
    ans(keys)
    list(LENGTH keys len)
    if(len)
      creturn(false)
    else()
      creturn(true)
    endif()
  endfunction()


# File: source/map/helpers/map_key_at.cmake

  ## returns the key at the specified position
  function(map_key_at map idx)
    map_keys(${map})
    ans(keys)
    list_normalize_index(keys ${idx})
    ans(idx)
    list_get(keys ${idx})
    ans(key)
    return_ref(key)
  endfunction()



# File: source/map/helpers/map_keys_append.cmake


function(map_keys_append map)
  set_property(GLOBAL APPEND PROPERTY "${map}" ${ARGN})
endfunction()

# File: source/map/helpers/map_keys_clear.cmake


function(map_keys_clear map)
  set_property(GLOBAL PROPERTY "${map}.__keys__")
endfunction()

# File: source/map/helpers/map_keys_remove.cmake


function(map_keys_remove map)
  get_property(keys GLOBAL PROPERTY "${map}.__keys__" )
  if(keys AND ARGN)
    list(REMOVE_ITEM keys ${ARGN})
    set_property(GLOBAL PROPERTY "${map}.__keys__" ${keys})
  endif()
endfunction()

# File: source/map/helpers/map_keys_set.cmake


function(map_keys_set map)
  set_property(GLOBAL PROPERTY "${map}.__keys__" ${ARGN})
endfunction()

# File: source/map/helpers/map_keys_sort.cmake


function(map_keys_sort map)
  get_property(keys GLOBAL PROPERTY "${map}.__keys__")
  if(keys)
    list(SORT keys)
    set_property(GLOBAL PROPERTY "${map}.__keys__" ${keys})
  endif()
endfunction()


# File: source/map/helpers/map_match.cmake


  ## checks if all fields specified in actual rhs are equal to the values in expected lhs
  ## recursively checks submaps
  function(map_match lhs rhs)
    if("${lhs}_" STREQUAL "${rhs}_")
      creturn(true)
    endif()


    list(LENGTH lhs lhs_length)
    list(LENGTH rhs rhs_length)

    if(NOT "${lhs_length}" EQUAL "${rhs_length}")
      creturn(false)
    endif()
  
    if(${lhs_length} GREATER 1)
      while(true)
        list(LENGTH lhs len)
        if(NOT len)
          break()
        endif()

        list_pop_back(lhs)
        ans(lhs_value)
        list_pop_back(rhs)
        ans(rhs_value)
        map_match("${lhs_value}" "${rhs_value}")
        ans(is_match)
        if(NOT is_match)
          creturn(false)
        endif()
      endwhile()
      creturn(true)
    endif() 

    is_map("${rhs}")
    ans(rhs_ismap)

    is_map("${lhs}")
    ans(lhs_ismap)

  
    if(NOT lhs_ismap OR NOT rhs_ismap)
      creturn(false)
    endif()


    map_iterator(${rhs})
    ans(it)

    while(true)
      map_iterator_break(it)

      map_tryget("${lhs}" "${it.key}")
      ans(lhs_value)

      map_match("${lhs_value}" "${it.value}")
      ans(values_match)

      if(NOT values_match)
        creturn(false)
      endif()

    endwhile()

    creturn(true)

  endfunction()

# File: source/map/helpers/map_match_properties.cmake

# returns true if map's properties match all properties of attrs
function(map_match_properties map attrs)
  map_keys("${attrs}")
  ans(attr_keys)
  foreach(key ${attr_keys})

    map_tryget("${map}" "${key}")
    ans(val)
    map_tryget("${attrs}" "${key}")
    ans(pred)
   # message("matching ${map}'s ${key} '${val}' with ${pred}")
    if(NOT "${val}" MATCHES "${pred}")
      creturn(false)
    endif()
  endforeach()
  creturn(true)
endfunction()



# File: source/map/helpers/map_matches.cmake


# returns a function which returns true of all 
function(map_matches attrs)
  obj("${attrs}")
  ans(attrs)
#  curry(map_match_properties(/1 ${attrs}))
  curry3(map_match_properties(/0 ${attrs}))
  return_ans()
endfunction()




# File: source/map/helpers/map_omit.cmake

# returns a copy of map without the specified keys (argn)
function(map_omit map)
  map_keys("${map}")
  ans(keys)
  if(ARGN)
    list(REMOVE_ITEM keys ${ARGN})
  endif()
  map_pick("${map}" ${keys})
  return_ans()
endfunction()

# File: source/map/helpers/map_omit_regex.cmake

# returns a map with all properties except those matched by any of the specified regexes
function(map_omit_regex map)
  set(regexes ${ARGN})
  map_keys("${map}")
  ans(keys)

  foreach(regex ${regexes})
    foreach(key ${keys})
        if("${key}" MATCHES "${regex}")
          list_remove(keys "${key}")
        endif()
    endforeach()
  endforeach()


  map_pick("${map}" ${keys})

  return_ans()


endfunction()

# File: source/map/helpers/map_overwrite.cmake


  ## overwrites all values of lhs with rhs
  function(map_overwrite lhs rhs)
    obj("${lhs}")
    ans(lhs)
    obj("${rhs}")
    ans(rhs)

    map_iterator("${rhs}")
    ans(it)
    while(true)
      map_iterator_break(it)
      map_set("${lhs}" "${it.key}" "${it.value}")
    endwhile()
    creturn(${lhs})
  endfunction()


# File: source/map/helpers/map_pairs.cmake



# returns a list key;value;key;value;...
# only works if key and value are not lists (ie do not contain ;)
function(map_pairs map)
  map_keys("${map}")
  ans(keys)
  set(pairs)
  foreach(key ${keys})
    map_tryget("${map}" "${key}")
    ans(val)
    list(APPEND pairs "${key}")
    list(APPEND pairs "${val}")
  endforeach()
  return_ref(pairs)
endfunction()


# File: source/map/helpers/map_partial.cmake

function(test)
  new()
  ans(obj)
  obj_set(${obj} "test1" "val1")
  obj_set(${obj} "test2" "val2")
  obj_set(${obj} "test3" "val3")


  obj_pick("${obj}" test1 test3)
  ans(res)
  assert(DEREF {res.test1} STREQUAL "val1")
  assert(DEREF {res.test3} STREQUAL "val3")

  obj_pick("${obj}" test4)
  ans(res)
  assert(res)
  assert(DEREF "_{res.test4}" STREQUAL "_")


endfunction()

# File: source/map/helpers/map_path_get.cmake

# returns the value at the specified path (path is specified as path fragment list)
# e.g. map = {a:{b:{c:{d:{e:3}}}}}
# map_path_get(${map} a b c d e)
# returns 3
# this function is somewhat faster than map_navigate()
function(map_path_get map)
  set(args ${ARGN})
  set(current "${map}")
  foreach(arg ${args}) 
    if(NOT current)
      creturn()
   endif()
   map_tryget("${current}" "${arg}")
   ans(current)
  endforeach()
  return_ref(current)
endfunction()


# File: source/map/helpers/map_path_set.cmake

# todo implement

function(map_path_set map path value)
  message(FATAL_ERROR "not implemented")
  if(NOT map)
    map_new()
    ans(map)
  endif()

  set(current "${map}")

  foreach(arg ${path})
    map_tryget("${current}" "${arg}")
    ans(current) 

  endforeach()

endfunction()


# File: source/map/helpers/map_peek_back.cmake


function(map_peek_back map prop)
  map_tryget("${map}" "${prop}")
  ans(lst)
  list_peek_back(lst)
  return_ans()
endfunction()

# File: source/map/helpers/map_peek_front.cmake


function(map_peek_front map prop)
  map_tryget("${map}" "${prop}")
  ans(lst)
  list_peek_front(lst)
  return_ans()
endfunction()

# File: source/map/helpers/map_pick.cmake


# returns a copy of map returning only the whitelisted keys
function(map_pick map)
    map_new()
    ans(res)
    foreach(key ${ARGN})
      obj_get(${map} "${key}")
      ans(val)

      map_set("${res}" "${key}" "${val}")
    endforeach()
    creturn("${res}")
endfunction()


# File: source/map/helpers/map_pick_regex.cmake

## returns a map containing all properties whose keys were matched by any of the specified regexes
function(map_pick_regex map)
    set(regexes ${ARGN})
    map_keys("${map}")
    ans(keys)
    set(pick_keys)
    foreach (regex ${regexex})
        foreach (key ${keys})
            if ("${key}" MATCHES "${regex}")
                list(APPEND pick_keys "${key}")
            endif ()
        endforeach ()
    endforeach ()
    list(REMOVE_DUPLICATES pick_keys)
    map_pick("${map}" ${pick_keys})
    return_ans()
endfunction()

# File: source/map/helpers/map_pop_back.cmake



function(map_pop_back map prop)
  map_tryget("${map}" "${prop}")
  ans(lst)
  list_pop_back(lst)
  ans(res)
  map_set("${map}" "${prop}" ${lst})
  return_ref(res) 
endfunction()

# File: source/map/helpers/map_pop_front.cmake



function(map_pop_front map prop)
  map_tryget("${map}" "${prop}")
  ans(lst)
  list_pop_front(lst)
  ans(res)
  map_set("${map}" "${prop}" ${lst})
  return_ref(res)
endfunction()

# File: source/map/helpers/map_promote.cmake


macro(map_promote __map_promote_map)
  # garbled names help free from variable collisions
  map_keys(${__map_promote_map} )
  ans(__map_promote_keys)
  foreach(__map_promote_key ${__map_promote_keys})
    map_get(${__map_promote_map}  ${__map_promote_key})
    ans(__map_promote_value)
    set("${__map_promote_key}" "${__map_promote_value}" PARENT_SCOPE)
  endforeach()
endmacro()

# File: source/map/helpers/map_property_length.cmake




  ## returns the length of the specified property
  function(map_property_length map prop)
    map_tryget("${map}" "${prop}")
    ans(val)
    list(LENGTH val len)
    return_ref(len)
  endfunction()


  macro(map_property_length map prop)
    get_property(__map_property_length_value GLOBAL PROPERTY "${map}.${prop}")
    list(LENGTH __map_property_length_value __ans)
  endmacro()


  macro(map_property_string_length map prop)
    get_property(__map_property_length_value GLOBAL PROPERTY "${map}.${prop}")
    string(LENGTH "${__map_property_length_value}" __ans)
  endmacro()

# File: source/map/helpers/map_push_back.cmake



function(map_push_back map prop)
  map_tryget("${map}" "${prop}")
  ans(lst)
  list_push_back(lst ${ARGN})
  map_set("${map}" "${prop}" ${lst})
  return_ref(lst)
endfunction()

# File: source/map/helpers/map_push_front.cmake


function(map_push_front map prop)
  map_tryget("${map}" "${prop}")
  ans(lst)
  list_push_front(lst ${ARGN})
  ans(res)
  map_set("${map}" "${prop}" ${lst})
  return_ref(res)
endfunction()


# File: source/map/helpers/map_rename.cmake

## renames a key in the specified map
function(map_rename map key_old key_new)
  map_get("${map}" "${key_old}")
  ans(value)
  map_remove("${map}" "${key_old}")
  map_set("${map}" "${key_new}" "${value}")
endfunction()


# File: source/map/helpers/map_set_default.cmake

 ## `()-><bool>`
##
## sets the value of the specified prop if it does not exist
## ie if map_has returns false for the specified property
## returns true iff value was set
function(map_set_default map prop)
  map_has("${map}" "${prop}")
  if(__ans)
    creturn(false)
  endif()
  map_set("${map}" "${prop}" ${ARGN})
  creturn(true)
endfunction()


# File: source/map/helpers/map_to_keyvaluelist.cmake

# converts a map to a key value list 
function(map_to_keyvaluelist map)
  map_keys(${map})
  ans(keys)
  set(kvl)
  foreach(key ${keys})
    map_get("${map}" "${key}")
    ans(val)
    list(APPEND kvl "${key}" "${val}")
  endforeach()
  return_ref(kvl)
endfunction()

# File: source/map/helpers/map_to_valuelist.cmake



  function(map_to_valuelist map)
    set(keys ${ARGN})
    list_extract_flag(keys --all)
    ans(all)
    if(all)
      map_keys(${map})
      ans(keys)
    endif()
    set(result)

    foreach(key ${keys})
      map_tryget(${map} "${key}")
      ans(value)
      list(APPEND result "${value}")
    endforeach()
    return_ref(result)
  endfunction()

# File: source/map/helpers/map_unpack.cmake


  ## unpacks the specified reference to a map
  ## let a map be stored in the var 'themap'
  ## let it have the key/values a/1 b/2 c/3
  ## map_unpack(themap) will create the variables
  ## ${themap.a} contains 1
  ## ${themap.b} contains 2
  ## ${themap.c} contains 3
  function(map_unpack __ref)
    map_iterator(${${__ref}})
    ans(it)
    while(true)
      map_iterator_break(it)
      set("${__ref}.${it.key}" ${it.value} PARENT_SCOPE)
    endwhile()
  endfunction()

# File: source/map/helpers/map_values.cmake

# returns all values of the map which are passed as ARNG
function(map_values this)
  set(args ${ARGN})
  if(NOT args)
    map_keys(${this})
    ans(args)
  endif()
  set(res)
	foreach(arg ${args})
		map_get(${this}  ${arg})
    ans(val)
		list(APPEND res ${val})	
	endforeach()
  return_ref(res)
endfunction()


# ## faster
# macro(map_values map)
#   set(__ans ${ARGN})
#   if(NOT __ans)
#     map_keys(${map})
#   endif()
#   ## ____map_values_key does not conflict as it is the loop variable
#   foreach(____map_values_key ${__ans})
#     map_tryget(${map} ${____map_values_key})
#     list(APPEND __map_values_result ${__ans})
#   endforeach()
#   set(__ans ${__map_values_result})
# endmacro()

# File: source/map/helpers/mm.cmake

## function which generates a map 
## out of the passed args 
## or just returns the arg if it is already valid
function(mm)
  
  set(args ${ARGN})
  # assignment
  list(LENGTH args len)
  if("${len}" GREATER 2)
    list(GET args 1 equal)
    list(GET args 0 target)
    if("${equal}" STREQUAL = AND "${target}" MATCHES "[a-zA-Z0-9_\\-]")
      list(REMOVE_AT args 0 )
      list(REMOVE_AT args 0 )
      mm(${args})
      ans(res)
      set("${target}" "${res}" PARENT_SCOPE)
      return_ref(res)
    endif()
  endif()



  data(${ARGN})
  return_ans()
endfunction()



# File: source/map/iterator/map_iterator.cmake

## initializes a new mapiterator
  function(map_iterator map)
    map_keys("${map}")
    ans(keys)
    set(iterator "${map}" before_start ${keys})
    return_ref(iterator)    
  endfunction()



# File: source/map/iterator/map_iterator_break.cmake

# use this macro inside of a while(true) loop it breaks when the iterator is over
# e.g. this prints all key values in the map
# while(true) 
#   map_iterator_break(myiterator)
#   message("${myiterator.key} = ${myiterator.value}")
# endwhile()
macro(map_iterator_break it_ref)
    map_iterator_next(${it_ref})
    if (${it_ref}.end)
        break()
    endif ()
endmacro()

# File: source/map/iterator/map_iterator_next.cmake

## this function moves the map iterator to the next position
## and returns true if it was possible
## e.g.
## map_iterator_next(myiterator) 
## ans(ok) ## is true if iterator had a next element
## variables ${myiterator.key} and ${myiterator.value} are available
macro(map_iterator_next it_ref)
  list(LENGTH "${it_ref}" __map_iterator_next_length)
  if("${__map_iterator_next_length}" GREATER 1)
    list(REMOVE_AT "${it_ref}" 1)
    if(NOT "${__map_iterator_next_length}" EQUAL 2)
      list(GET "${it_ref}" 1 "${it_ref}.key")
      list(GET "${it_ref}" 0 "__map_iterator_map")
      get_property("${it_ref}.value" GLOBAL PROPERTY "${__map_iterator_map}.${${it_ref}.key}")
      set(__ans true)
    else()
      set(__ans false)
      set("${it_ref}.end" true)
    endif() 
  else()
    set("${it_ref}.end" true)
    set(__ans false)
  endif()
endmacro()


# File: source/map/map_dfs_references_once.cmake

function(map_dfs_references_once)
    if(NOT __recurse)
        set(__recurse true)
        map_new()
        ans(visited)
    endif()


    list(LENGTH ARGN count)
    if("${count}" EQUAL 0)
        creturn(${visited})
    endif()


    if("${count}" GREATER "1")
        foreach(arg ${ARGN})
            map_dfs_references_once(${arg})
        endforeach()
        creturn(${visited})
    endif()

    is_map("${ARGN}")
    ans(is_map)

    if(NOT is_map)
        creturn(${visited})
    endif()
    map_tryget(${visited} "${ARGN}")
    ans(result)

    if(result)
        creturn(${visited})
    endif()


    map_set(${visited} "${ARGN}" "true")


    map_keys("${ARGN}")
    ans(keys)

    foreach(key ${keys})
        map_tryget("${ARGN}" "${key}")
        ans(keyVal)
        map_dfs_references_once("${keyVal}")
    endforeach()

    creturn(${visited})

endfunction()

# File: source/map/map_import_properties.cmake

## imports the specified properties into the current scope
## e.g map = {a:1,b:2,c:3}
## map_import_properties(${map} a c)
## -> ${a} == 1 ${b} == 2
macro(map_import_properties __map)
  foreach(key ${ARGN})
    map_tryget("${__map}" "${key}")
    ans("${key}")
  endforeach()
endmacro()


# File: source/map/map_import_properties_all.cmake

## 
## imports all properties of map into local scope
function(map_import_properties_all __map)
  if(NOT __map)
    creturn()
  endif()
  map_keys("${__map}")
  ans(__mipa_keys)
  foreach(key ${__mipa_keys})
    map_tryget("${__map}" "${key}")
    set("${key}" "${__ans}" PARENT_SCOPE)
  endforeach()
  creturn()
endfunction()

# File: source/map/map_matches_obj.cmake

## returns true if actual has all properties (and recursive properties)
## that expected has
  function(map_match_obj actual expected)
    obj("${actual}")
    ans(actual)
    obj("${expected}")
    ans(expected)
    map_match("${actual}" "${expected}")
    return_ans()
  endfunction()

# File: source/map/operations/map_clone.cmake


function(map_clone original type) 
  if("${type}" STREQUAL "DEEP")
    map_clone_deep("${original}")
    return_ans()
  elseif("${type}" STREQUAL "SHALLOW") 
    map_clone_shallow("${original}")
    return_ans()
  else()
    message(FATAL_ERROR "unknown clone type: ${type}")
  endif()
endfunction()

# File: source/map/operations/map_clone_deep.cmake


function(map_clone_deep original)
  map_clone_shallow("${original}")
  ans(result)
    
  is_map("${result}" )
  ans(ismap)
  if(ismap) 
    map_keys("${result}" )
    ans(keys)
    foreach(key ${keys})
      map_get(${result}  ${key})
      ans(value)
      map_clone_deep("${value}")
      ans(cloned_value)
      map_set(${result} ${key} ${cloned_value})
    endforeach()
  endif()
  return_ref(result)
endfunction()

# File: source/map/operations/map_clone_shallow.cmake


function(map_clone_shallow original)
  is_map("${original}" )
  ans(ismap)
  if(ismap)
    map_new()
    ans(result)
    map_keys("${original}" )
    ans(keys)
    foreach(key ${keys})
      map_get("${original}"  "${key}")
      ans(value)
      map_set("${result}" "${key}" "${value}")
    endforeach()
    creturn(${result})
  endif()

  is_address("${original}")
  ans(isref)
  if(isref)
    address_get(${original})
    ans(res)
    address_type_get(${original})
    ans(type)
    address_new(${type})
    ans(result)
    address_set(${result} ${res})
    creturn(${result})
  endif()

  # everythign else is a value type and can be returned
  return_ref(original)

endfunction()



# File: source/map/operations/map_equal.cmake

# compares two maps and returns true if they are equal
# order of list values is important
# order of map keys is not important
# cycles are respected.
function(map_equal lhs rhs)
	# create visited map on first call
	set(visited ${ARGN})
	if(NOT visited)
		map_new()
		ans(visited)
	endif()

	# compare lengths of lhs and rhs return false if they are not equal
	list(LENGTH lhs lhs_length)
	list(LENGTH rhs rhs_length)

	if(NOT "${lhs_length}" EQUAL "${rhs_length}")
		creturn(false)
	endif()


	# compare each element of list recursively and return result
	if("${lhs_length}" GREATER 1)
		math(EXPR len "${lhs_length} - 1")
		foreach(i RANGE 0 ${len})
			list(GET lhs "${i}" lhs_item)
			list(GET rhs "${i}" rhs_item)
			map_equal("${lhs_item}" "${rhs_item}" ${visited})
			ans(res)
			if(NOT res)
				creturn(false)
			endif()
		endforeach()
		creturn(true)
	endif()

	# compare strings values of lhs and rhs and return if they are equal
	if("${lhs}" STREQUAL "${rhs}")
		creturn(true)
	endif()

	# else lhs and rhs might be maps
	# if they are not return false
	is_map(${lhs})
	ans(lhs_ismap)

	if(NOT lhs_ismap)
		creturn(false)
	endif()

	is_map(${rhs})	
	ans(rhs_ismap)

	if(NOT rhs_ismap)
		creturn(false)
	endif()

	# if already visited return true as a parent call will correctly 
	# determine equality
	map_tryget(${visited} ${lhs})
	ans(lhs_isvisited)
	if(lhs_isvisited)
		creturn(true)
	endif()

	map_tryget(${visited} ${rhs})
	ans(rhs_isvisited)
	if(rhs_isvisited)
		creturn(true)
	endif()

	# set visited to true
	map_set(${visited} ${lhs} true)
	map_set(${visited} ${rhs} true)

	# compare keys of lhs and rhs	
	map_keys(${lhs} )
	ans(lhs_keys)
	map_keys(${rhs} )
	ans(rhs_keys)

	# order not important
	set_isequal(lhs_keys rhs_keys)
	ans(keys_equal)

	if(NOT keys_equal)		
		creturn(false)
	endif()

	# compare each property of lhs and rhs recursively
	foreach(key ${lhs_keys})

		map_get(${lhs}  ${key})
		ans(lhs_property_value)
		map_get(${rhs}  ${key})
		ans(rhs_property_value)
		
		map_equal("${lhs_property_value}" "${rhs_property_value}" ${visited})		
		ans(val_equal)
		if(NOT val_equal)
			creturn(false)
		endif()
	endforeach()

	## everything is equal -> return true
	creturn(true)
endfunction()



# File: source/map/operations/map_equal_obj.cmake

## compares two maps for value equality
## lhs and rhs may be objectish 
function(map_equal_obj lhs rhs)
  obj("${lhs}")
  ans(lhs)
  obj("${rhs}")
  ans(rhs)
  map_equal("${lhs}" "${rhs}")
  return_ans()
endfunction()

# File: source/map/operations/map_foreach.cmake

# executes action (key, value)->void
# on every key value pair in map
# exmpl: map = {id:'1',val:'3'}
# map_foreach("${map}" "(k,v)-> message($k $v)")
# prints 
#  id;1
#  val;3
function(map_foreach map action)
	map_keys("${map}")
	ans(keys)
	foreach(key ${keys})
		map_tryget("${map}" "${key}")
		ans(val)
		call("${action}"("${key}" "${val}"))
	endforeach()
endfunction()

# File: source/map/operations/map_issubsetof.cmake

function(map_issubsetof result superset subset)
	map_keys(${subset} )
	ans(keys)
	foreach(key ${keys})
		map_tryget(${superset}  ${key})
		ans(superValue)
		map_tryget(${subset}  ${key})
		ans(subValue)

		is_map(${superValue} )
		ans(issupermap)
		is_map(${subValue} )
		ans(issubmap)
		if(issubmap AND issubmap)
			map_issubsetof(res ${superValue} ${subValue})
			if(NOT res)
				return_value(false)
			endif()
		else()
			list_isvalid(${superValue} )
			ans(islistsuper)
			list_isvalid(${subValue} )
			ans(islistsub)
			if(islistsub AND islistsuper)
				address_get(${superValue})
				ans(superValue)
				address_get(${subValue})
				ans(subValue)
			endif()
			list_equal( "${superValue}" "${subValue}")
			ans(res)
			if(NOT res)
				return_value(false)
			endif()
		endif()
	endforeach()
	return_value(true)
endfunction()

# File: source/map/operations/map_merge.cmake

# creates a union from all all maps passed as ARGN and combines them in result
# you can merge two maps by typing map_union(${map1} ${map1} ${map2})
# maps are merged in order ( the last one takes precedence)
function(map_merge )
	set(lst ${ARGN})

	map_new()
  ans(res)
  
	foreach(map ${lst})
		map_keys(${map} )
		ans(keys)
		foreach(key ${keys})
			map_tryget(${res}  ${key})
			ans(existing_val)
			map_tryget(${map}  ${key})
			ans(val)

			is_map("${existing_val}" )
			ans(existing_ismap)
			is_map("${val}" )
			ans(new_ismap)

			if(new_ismap AND existing_ismap)
				map_union(${existing_val}  ${val})
				ans(existing_val)
			else()
				
				map_set(${res} ${key} ${val})
			endif()
		endforeach()
	endforeach()
	creturn(${res})
endfunction()



# File: source/map/operations/map_permutate.cmake

## 
## permutates the specified input map 
## takes every key of the input map and treats the value as a list
## the result is n maps which contain one value per key

function(map_permutate input)
  
  map_keys("${input}")
  ans(keys)

  map_new()
  ans(result)
  foreach(key ${keys})
    map_get("${input}" "${key}")
    ans(values)

    set(currentList ${result})
    set(result)
    foreach(current ${currentList})
      foreach(value IN LISTS values)
        map_clone_shallow("${current}")
        ans(current)
        map_set(${current} ${key} ${value})
        list(APPEND result ${current})
      endforeach()      
    endforeach()
  endforeach()
  return_ref(result)
endfunction()

# File: source/map/operations/map_union.cmake

# creates a union from all all maps passed as ARGN and combines them in the first
# you can merge two maps by typing map_union(${map1} ${map1} ${map2})
# maps are merged in order ( the last one takes precedence)
function(map_union)
	set(lst ${ARGN})
	list_pop_front(lst)
	ans(res)
	if(NOT res)
		message(FATAL_ERROR "map_union: no maps passed")
	endif()
	# loop through the keys of every map	
	foreach(map ${lst})
		map_keys(${map} )
		ans(keys)
		foreach(key ${keys})
			map_tryget(${map}  ${key})
			ans(val)
			map_set(${res} ${key} ${val})
		endforeach()
	endforeach()
	creturn(${res})
endfunction()



# File: source/navigation/assign.cmake

## `([!]<expr> <value>|("="|"+=" <expr><call>)) -> <any>`
##
## the assign function allows the user to perform some nonetrivial 
## operations that other programming languages allow 
##
## Examples
## 
function(assign __lvalue __operation __rvalue)
    ## is a __value

    if (NOT "${__operation}" MATCHES "^(=|\\+=)$")
        ## if no equals sign is present then interpret all
        ## args as a simple literal cmake value
        ## this allows the user to set an expression to
        ## a complicated string with spaces without needing
        ## to single quote it
        set(__value ${__operation} ${__rvalue} ${ARGN})
    elseif (${__rvalue} MATCHES "^'.*'$")
        string_decode_delimited("${__rvalue}" ')
        ans(__value)
    elseif (${__rvalue} MATCHES "(^{.*}$)|(^\\[.*\\]$)")
        script("${__rvalue}")
        ans(__value)
    else ()
        navigation_expression_parse("${__rvalue}")
        ans(__rvalue)
        list_pop_front(__rvalue)
        ans(__ref)

        if ("${ARGN}" MATCHES "^\\(.*\\)$")
            ref_nav_get("${${__ref}}" "%${__rvalue}")
            ans(__value)

            map_tryget(${__value} ref)
            ans(__value_ref)

            data("${ARGN}")
            ans(__args)
            if (NOT __value_ref)
                call("${__ref}" ${__args})
                ans(__value)

            else ()
                map_tryget(${__value} property)
                ans(__prop)
                map_tryget(${__value} range)
                ans(ranges)

                if (NOT ranges)
                    list_pop_front(__args)
                    list_pop_back(__args)
                    obj_member_call("${__value_ref}" "${__prop}" ${__args})
                    ans(__value)

                else ()
                    map_tryget(${__value} __value)
                    ans(__callables)
                    set(__value)
                    set(this "${__value_ref}")
                    foreach (__callable ${__callables})
                        call("${__callable}" ${__args})
                        ans(__res)
                        list(APPEND __value ${__res})
                    endforeach ()
                endif ()
            endif ()
        else ()
            ref_nav_get("${${__ref}}" ${__rvalue})
            ans(__value)
        endif ()
    endif ()
    string_take(__lvalue !)
    ans(__exc)
    navigation_expression_parse("${__lvalue}")
    ans(__lvalue)
    list_pop_front(__lvalue)
    ans(__lvalue_ref)

    if ("${__operation}" STREQUAL "+=")
        ref_nav_get("${${__lvalue_ref}}" "${__lvalue}")
        ans(prev_value)
        set(__value "${prev_value}${__value}")
    endif ()
    # message("ref_nav_set ${${__lvalue_ref}} ${__exc}${__lvalue} ${__value}" )
    ref_nav_set("${${__lvalue_ref}}" "${__exc}${__lvalue}" "${__value}")
    ans(__value)
    set(${__lvalue_ref} ${__value} PARENT_SCOPE)
    return_ref(__value)
endfunction()

# File: source/navigation/get.cmake


  ## universal get function which allows you to get
  ## from an object or map. only allows property names
  ## returns nothing if navigting the object tree fails
  function(get ref_name _equals nav)
    string(REPLACE "." "\;" nav "${nav}")
    set(nav ${nav})
    list_pop_front(nav)
    ans(part)


    set(current "${${part}}")
    map_get_special("${current}" object)
    ans(isobject)

    if(isobject)
      foreach(part ${nav})
        obj_get("${current}" "${part}")
        ans(current)
        if("${current}_" STREQUAL "_")
          break()
        endif()
      endforeach()
    else()
      foreach(part ${nav})
        map_tryget("${current}" "${part}")
        ans(current)
        if("${current}_" STREQUAL "_")
          break()
        endif()
      endforeach()
    endif()
    
    set("${ref_name}" "${current}" PARENT_SCOPE)
  endfunction()

# File: source/navigation/map_navigate.cmake

#navigates a map structure
# use '.' and '[]' operators to select next element in map
# e.g.  map_navigate(<map_ref> res "propa.propb[3].probc[3][4].propd")
function(map_navigate result navigation_expression)
    # path is empty => ""
    if (navigation_expression STREQUAL "")
        return_value("")
    endif ()

    # if navigation expression is a simple var just return it
    if (${navigation_expression})
        return_value(${${navigation_expression}})
    endif ()

    # check for dereference operator
    set(deref false)
    if ("${navigation_expression}" MATCHES "^\\*")
        set(deref true)
        string(SUBSTRING "${navigation_expression}" 1 -1 navigation_expression)
    endif ()

    # split off reference from navigation expression
    unset(ref)
    #_message("${navigation_expression}")
    string(REGEX MATCH "^[^\\[|\\.]*" ref "${navigation_expression}")
    string(LENGTH "${ref}" len)
    string(SUBSTRING "${navigation_expression}" ${len} -1 navigation_expression)


    # if ref is a ref to a ref dereference it :D
    set(not_defined true)
    if (DEFINED ${ref})
        set(ref ${${ref}})
        set(not_defined false)
    endif ()

    # check if ref is valid
    is_address("${ref}")
    ans(is_ref)
    if (NOT is_ref)
        if (not_defined)
            return_value()
        endif ()
        set(${result} "${ref}" PARENT_SCOPE)

        creturn()
        message(FATAL_ERROR "map_navigate: expected a reference but got '${ref}'")
    endif ()

    # match all navigation expression parts
    string(REGEX MATCHALL "(\\[([0-9][0-9]*)\\])|(\\.[a-zA-Z0-9_\\-][a-zA-Z0-9_\\-]*)" parts "${navigation_expression}")

    # loop through parts and try to navigate
    # if any part of the path is invalid return ""
    set(current "${ref}")
    foreach (part ${parts})
        string(REGEX MATCH "[a-zA-Z0-9_\\-][a-zA-Z0-9_\\-]*" index "${part}")
        string(SUBSTRING "${part}" 0 1 index_type)
        if (index_type STREQUAL ".")
            # get by key
            map_tryget(${current} "${index}")
            ans(current)
        elseif (index_type STREQUAL "[")
            message(FATAL_ERROR "map_navigate: indexation '[<index>]' is not supported")
            # get by index
            address_get(${current})
            ans(lst)
            list(GET lst ${index} keyOrValue)
            map_tryget(${current} ${keyOrValue})
            ans(current)
            if (NOT current)
                set(current "${keyOrValue}")
            endif ()
        endif ()
        if (NOT current)
            return_value("${current}")
        endif ()
    endforeach ()
    if (deref)
        is_address("${current}")
        ans(is_ref)
        if (is_ref)
            address_get("${current}")
            ans(current)
        endif ()
    endif ()
    # current  contains the navigated value
    set(${result} "${current}" PARENT_SCOPE)
endfunction()
	


# File: source/navigation/map_navigate_set.cmake

function(map_navigate_set navigation_expression)
	cmake_parse_arguments("" "FORMAT" "" "" ${ARGN})
	set(args)
	if(_FORMAT)
		foreach(arg ${_UNPARSED_ARGUMENTS})
			format( "${arg}")
			ans(formatted_arg)
			list(APPEND args "${formatted_arg}")
		endforeach()
	else()
		set(args ${_UNPARSED_ARGUMENTS})
	endif()
	# path is empty => ""
	if(navigation_expression STREQUAL "")
		return_value("")
	endif()

	# split off reference from navigation expression
	unset(ref)
	string(REGEX MATCH "^[^\\[|\\.]*" ref "${navigation_expression}")
	string(LENGTH "${ref}" len )
	string(SUBSTRING "${navigation_expression}" ${len} -1 navigation_expression)

	# rest of navigation expression is empty, first is a var
	if(NOT navigation_expression)

		set(${ref} "${args}" PARENT_SCOPE)
		creturn()
	endif()
	



	# match all navigation expression parts
	string(REGEX MATCHALL  "(\\[([0-9][0-9]*)\\])|(\\.[a-zA-Z0-9_\\-][a-zA-Z0-9_\\-]*)" parts "${navigation_expression}")
	
	# loop through parts and try to navigate 
	# if any part of the path is invalid return ""

	set(current "${${ref}}")
	
	
	while(parts)
		list(GET parts 0 part)
		list(REMOVE_AT parts 0)
		
		string(REGEX MATCH "[a-zA-Z0-9_\\-][a-zA-Z0-9_\\-]*" index "${part}")
		string(SUBSTRING "${part}" 0 1 index_type)	



		#message("current ${current}, parts: ${parts}, current_part: ${part}, current_index ${index} current_type : ${index_type}")
		# first one could not be ref so create ref and set output
		is_address("${current}")
		ans(isref)
		
		if(NOT isref)
			map_new()
    	ans(current)
			set(${ref} ${current} PARENT_SCOPE)
		endif()		
		
		# end of navigation string reached, set value
		if(NOT parts)
			map_set(${current} ${index} "${args}")
			creturn()
		endif()

		
		map_tryget(${current}  "${index}")
		ans(next)
		# create next element in change
		if(NOT next)
			map_new()
    	ans(next)
			map_set(${current} ${index} ${next})
		endif()

		# if no next element exists its an error
		if(NOT next)
			message(FATAL_ERROR "map_navigate_set: path is invalid")
		endif()

		set(current ${next})

		
	endwhile()
endfunction()

# File: source/navigation/map_navigate_set_if_missing.cmake



function(map_navigate_set_if_missing navigation_expr)
  map_navigate(result ${navigation_expr})
  if(NOT result OR "${result}" STREQUAL "${navigation_expr}")
    map_navigate_set("${navigation_expr}" ${ARGN})
  endif() 
endfunction()

# File: source/navigation/nav.cmake

# a convenience function for navigating maps
# nav(a.b.c) -> returns memver c of member b of map a
# nav(a.b.c 3) ->sets member c of member b of map a to 3 (creating any missing maps along the way)
# nav(a.b.c = d.e.f) -> assignes the value of d.e.f to a.b.c
# nav(a.b.c += d.e) adds the value of d.e to the value of a.b.c
# nav(a.b.c -= d.e) removes the value of d.e from a.b.c
# nav(a.b.c FORMAT "{d.e}@@{d.f}") formats the string and assigns a.b.c to it
# nav(a.b.c CLONE_DEEP d.e.f) clones the value of d.e.f depely and assigns it to a.b.c
function(nav navigation_expression)
  set(args ${ARGN})
  if("${args}_" STREQUAL "_")
    map_navigate(res "${navigation_expression}")
    creturn(${res})
  endif()

  if("${ARGN}" STREQUAL "UNSET")
    map_navigate_set("${navigation_expression}")
    creturn()
  endif()


  set(args ${ARGN})
  list_peek_front(args)
  ans(first)

  if("_${first}" STREQUAL _CALL)
    call(${args})
    ans(args)
  elseif("_${first}" STREQUAL _FORMAT)
    list_pop_front( args)
    format("${args}")  
    ans(args)
  elseif("_${first}" STREQUAL _APPEND OR "_${first}" STREQUAL "_+=")
    list_pop_front(args)
    map_navigate(cur "${navigation_expression}")
    map_navigate(args "${args}")
    set(args ${cur} ${args})
  elseif("_${first}" STREQUAL _REMOVE OR "_${first}" STREQUAL "_-=")
    list_pop_front(args)
    map_navigate(cur "${navigation_expression}")
    map_navigate(args "${args}")
    if(cur)
      list(REMOVE_ITEM cur "${args}")
    endif()
    set(args ${cur})
 elseif("_${first}" STREQUAL _ASSIGN OR "_${first}" STREQUAL _= OR "_${first}" STREQUAL _*)
    list_pop_front( args)
    map_navigate(args "${args}")
    
 elseif("_${first}" STREQUAL _CLONE_DEEP)
    list_pop_front( args)
    map_navigate(args "${args}")
    map_clone_deep("${args}")
    ans(args)
 elseif("_${first}" STREQUAL _CLONE_SHALLOW)
    list_pop_front( args)
    map_navigate(args "${args}")
    map_clone_shallow("${args}")
    ans(args)
  endif()

  # this is a bit hacky . if a new var is created by map_navigate_set
  # it is propagated to the PARENT_SCOPE
  string(REGEX REPLACE "^([^.]*)\\..*" "\\1" res "${navigation_expression}")
  map_navigate_set("${navigation_expression}" ${args})
  set(${res} ${${res}} PARENT_SCOPE)

  return_ref(args)
endfunction()

# File: source/navigation/navigation_expression_parse.cmake

function(navigation_expression_parse)
    string(REPLACE "." ";" expression "${ARGN}")
    string(REPLACE "[" "<" expression "${expression}")
    string(REPLACE "]" ">" expression "${expression}")
    string(REGEX REPLACE "([<>][0-9:-]*[<>])" ";\\1" expression "${expression}")
    string(REGEX REPLACE "^;" "" expression "${expression}")
    return_ref(expression)
endfunction()

# File: source/navigation/query/query_disjunction.cmake


  ## `(<clause:{<selector>:<literal...>}> <any..> )-><bool>`
  ##
  ## queries the specified args for the specified clause
  function(query_disjunction clause)
    map_keys("${clause}")
    ans(selectors)

    foreach(selector ${selectors})
      map_tryget(${clause} "${selector}")
      ans(predicates)

      foreach(predicate ${predicates})

        if("${selector}" STREQUAL " ")
          set(selector)
          set(foreach_item false)
        elseif("${selector}" MATCHES "(.*)\\[.*\\]$")
          set(foreach_item true)
          set(target_property ${CMAKE_MATCH_1})
        else()
          set(foreach_item false)
        endif()


        ref_nav_get("${ARGN}" ${selector})
        ans(value)

        query_literal("${predicate}" __query_predicate)
        ans(success)

        if(success)
          if(foreach_item)
            foreach(item ${value})
              __query_predicate(${item})
              if(__ans)
                creturn(true)
              endif()
            endforeach()
          else()
            __query_predicate(${value})
            if(__ans)
              creturn(true)
            endif()
          endif()
        endif()
      endforeach()
    endforeach()

    creturn(false)
  endfunction()

# File: source/navigation/query/query_literal.cmake



function(query_literal)


  query_literal_definition_add(bool query_literal_bool "^((true)|(false))$")
  query_literal_definition_add(regex query_literal_regex "^/(.+)/$")
  query_literal_definition_add(gt query_literal_gt "^>([^=].*)")
  query_literal_definition_add(lt query_literal_lt "^<([^=].*)")
  query_literal_definition_add(eq query_literal_eq "^=([^=].*)")
  query_literal_definition_add(match query_literal_match "^\\?/(.+)/$" )
  query_literal_definition_add(strequal  query_literal_strequal "(.+)")  
  query_literal_definition_add(where query_literal_where "" )

    
  function(query_literal query_literal_instance )
    if("${query_literal_instance}_" STREQUAL "_")
      creturn()
    endif()

    is_address("${query_literal_instance}")
    ans(is_ref)

    if(is_ref)
      map_keys(${query_literal_instance})
      ans(type)
      query_literal_definition("${type}")
      ans(query_literal_definition)
      map_tryget(${query_literal_instance} "${type}")
      ans(query_literal_input)
    else()
      # is predicate?
      if(false)
        
      else()
        query_literal_definitions_with_regex()
        ans(definitions)
        foreach(def ${definitions})
          map_tryget(${def} regex)
          ans(regex)
          set(query_literal_input)
          if("${query_literal_instance}" MATCHES "${regex}")
            set(query_literal_input ${CMAKE_MATCH_1})
          endif()
        #   print_vars(query_literal_input query_literal_instance regex replace)
          if(NOT "${query_literal_input}_" STREQUAL "_")
            set(query_literal_definition ${def})
            break()
          endif()
        endforeach()

        # if("${query_literal_instance}" MATCHES "^(true)|(false)$")
        #   ## boolish
        #   map_new()
        #   ans(query_literal_definition)
        #   map_set(${query_literal_definition} bool ${query_literal_instance})
        # else()
        #   ## just a value -> strequal
        #   map_new()
        #   ans(query_literal_definition)
        #   map_set(${query_literal_definition} strequal ${query_literal_instance})
        # endif()
      endif()
    endif()
    if(NOT query_literal_definition)
      message(FATAL_ERROR "invalid query literal")
    endif()

    map_tryget(${query_literal_definition} function)
    ans(query_literal_function)

    if("${ARGN}_" STREQUAL "_")
      function_new()
      ans(alias)
    else()
      set(alias ${ARGN})
    endif()

    ## create a curried function
    eval( "
    function(${alias})
      ${query_literal_function}(\"${query_literal_input}\" \${ARGN})
      set(__ans \${__ans} PARENT_SCOPE)
    endfunction()
    ")
    return_ref(alias)
  endfunction()

  query_literal(${ARGN})
  return_ans()
endfunction()

# File: source/navigation/query/query_literal_add.cmake


  function(query_literal_definition_add type function regex)
    map_new()
    ans(query_literal_def)
    callable_function("${function}")
    ans(function)
    map_set(${query_literal_def} type "${type}")
    map_set(${query_literal_def} function "${function}")
    if(regex)
      map_set(${query_literal_def} regex "${regex}")
      address_append(__query_literal_handlers_with_regex ${query_literal_def})
    endif()
    map_set(__query_literal_handlers "${type}" "${query_literal_def}")
    return_ref(query_literal_def)
  endfunction()

macro(query_literal_definitions_with_regex)
  address_get(__query_literal_handlers_with_regex)
endmacro()
macro(query_literal_definitions)
  map_value(__query_literal_handlers)
endmacro() 

function(query_literal_definition_function type)
  map_tryget(__query_literal_handlers "${type}")
  ans(handler)
  map_tryget("${handler}" function )
  return_ans()

endfunction()

macro(query_literal_definition type)
  map_tryget(__query_literal_handlers "${type}")
endmacro()

# File: source/navigation/query/query_literals/query_literal_bool.cmake


  function(query_literal_bool expected)
    #message("bool ${expected} - ${ARGN}")
    if(ARGN AND expected)
      creturn(true)
    elseif(NOT ARGN AND NOT expected)
      creturn(true)
    endif()
    creturn(false)
  endfunction()


# File: source/navigation/query/query_literals/query_literal_eq.cmake


  function(query_literal_eq input)
    if("${ARGN}" EQUAL "${input}")
      creturn(true)
    endif()
    creturn(false)
  endfunction()


# File: source/navigation/query/query_literals/query_literal_gt.cmake



  function(query_literal_gt input)
    if("${ARGN}" GREATER "${input}")
      creturn(true)
    endif()
    creturn(false)
  endfunction()


# File: source/navigation/query/query_literals/query_literal_lt.cmake


  function(query_literal_lt input)
    if("${ARGN}" LESS "${input}")
      creturn(true)
    endif()
    creturn(false)
  endfunction()

# File: source/navigation/query/query_literals/query_literal_match.cmake



  function(query_literal_match expected)
    #message("match ${expected} - ${ARGN}")
    if("${ARGN}" MATCHES "${expected}")
      creturn(true)
    endif()
    creturn(false)
  endfunction()


# File: source/navigation/query/query_literals/query_literal_regex.cmake


  function(query_literal_regex input)
    is_address("${input}")
    ans(is_ref)
    if(is_ref)
      map_import_properties(${input} 
        match
        matchall
        replace
      )
    else()  
      set(match "${input}")
      set(matchall)
    endif()
    if(NOT replace )
      set(replace "$0")
    endif()

    if(NOT "${match}_" STREQUAL "_")
      regex_match_replace("${match}" "${replace}" "${ARGN}")
      ans(result)
      return_ref(result)
    elseif(NOT "${matchall}_" STREQUAL "_")
      string(REGEX MATCHALL "${matchall}" matches "${ARGN}")
      set(result)
      foreach(match ${matches})
        regex_match_replace("${matchall}" "${replace}" "${match}")
        ans_append(result)
      endforeach()
      return_ref(result)
    else()
      message(FATAL_ERROR "no regex speciefied (either match or matchall property needs to be set)")
    endif()
    creturn()
  endfunction()


# File: source/navigation/query/query_literals/query_literal_strequal.cmake


  function(query_literal_strequal expected)
    #message("strequal ${expected} - ${ARGN}")
    if("${expected}_" STREQUAL "${ARGN}_")
      creturn(true)
    endif()
    creturn(false)
  endfunction()

# File: source/navigation/query/query_literals/query_literal_where.cmake


  function(query_literal_where input)
    query_literal("${input}" __query_literal_select_predicate)
    ans(success)

    if(NOT success)
      creturn()
    endif()

    __query_literal_select_predicate(${ARGN})
    ans(match)
    if(match)
      set(result ${ARGN})
      return_ref(result)
    endif()
    creturn()
  endfunction()

# File: source/navigation/query/query_match_cnf.cmake

##  `(<clauses: <clause: { <selector>:<literal...> }>...> <any...>)-><bool>`
## 
##  queries the specified args for the specified clauses in conjunctive normal form
function(query_match_cnf clauses)
  data("${clauses}")
  ans(clauses)

  foreach(clause ${clauses})
    query_disjunction(${clause} ${ARGN})
    ans(clause_result)
    if(NOT clause_result)
      creturn(false)
    endif()
  endforeach()
  creturn(true)
endfunction()


# File: source/navigation/query/query_selection.cmake

## `(<query: { <<selector:<navigation expression>> : <query literal>>...  } > <any>)-><any>`
##
## selects values depending on the specified query
## example 
## ```
## assign(input_data = "{
##   a: 'hello world',
##   b: 'goodbye world',
##   c: {
##    d: [1,2,3,4,5]
##   } 
## }")
## assign(result = query_selection("{a:{regex:{matchall:'[^ ]+'}}" ${input_data}))
## assertf("{result.a}" EQUALS  "hello" "world")
##
## ```
function(query_selection query)
  obj("${query}")


  map_keys("${query}")
  ans(selectors)



  set(result)


  ## loop through all selectors
  foreach(selector ${selectors})
    map_tryget(${query} "${selector}")
    ans(literal)

    ## check to see if selector ends with [...] 
    ## which indicates that action should be performed
    ## foreach item 
    ## 
    set(target_property)

    if("${selector}" MATCHES "(.+)=>(.+)")
      set(selector "${CMAKE_MATCH_1}")
      set(target_property "${CMAKE_MATCH_2}")
    endif()

    if("${selector}" STREQUAL "$")
      set(selector)
      set(foreach_item false)
    elseif("${selector}" MATCHES "(.*)\\[.*\\]$")
      if(NOT "${selector}" MATCHES "\\[-?([0]|[1-9][0-9]*)\\]$")
        if(NOT target_property)
          set(target_property "${CMAKE_MATCH_1}")
        endif()
        set(foreach_item true)
      endif()
    else()
      set(foreach_item false)
    endif()

    if("${target_property}_" STREQUAL "_")
      set(target_property "${selector}")
    endif()
    if("${target_property}" STREQUAL "$")
      set(target_property)
    endif()


    ref_nav_get("${ARGN}" ${selector})
    ans(value)

    query_literal("${literal}" __query_literal)
    ans(success)

    if(success)
      set(selection)
      if(foreach_item)
        foreach(item ${value})
          __query_literal(${item})
          if(NOT "${__ans}_" STREQUAL "_" )
            list(APPEND selection ${__ans})
          endif()
        endforeach()
      else()
        __query_literal(${value})
        if(NOT "${__ans}_" STREQUAL "_" )
          list(APPEND selection ${__ans})
        endif()
      endif()
      ref_nav_set("${result}" "!${target_property}" ${selection})
      ans(result)
    endif()

  endforeach()
  return_ref(result)

endfunction()

# File: source/navigation/query/query_where.cmake

##
##
##
function(query_where query)
  data("${query}")
  ans(query)

  map_keys("${query}")
  ans(selectors)

  set(result)

  foreach(selector ${selectors})
    map_tryget(${query} "${selector}")
    ans(predicate)
    if("${selector}" STREQUAL " ")
      set(selector)
      set(foreach_item false)
    elseif("${selector}" MATCHES "(.*)\\[.*\\]")
      set(foreach_item true)
      set(target_property ${CMAKE_MATCH_1})
    else()
      set(foreach_item false)
    endif()

    ref_nav_get("${ARGN}" ${selector})
    ans(value)

    query_literal("${predicate}" __query_predicate)
    ans(success)



    if(success)
      set(matched_values)
      set(found_match false)
      if(foreach_item)
        foreach(item ${value})
          __query_predicate(${item})
          if(__ans)
            list(APPEND matched_values ${item})
            set(found_match true)
          endif()
        endforeach()
      else()
        __query_predicate(${value})
        if(__ans)
          list(APPEND matched_values ${value})
          set(found_match true)
        endif()
      endif()

      if(found_match)
        ref_nav_set("${result}" "!${target_property}" ${matched_values})
        ans(result)
      endif()
    endif()

  endforeach()

  return_ref(result)

endfunction()

# File: source/navigation/ref_keys.cmake




  function(ref_keys ref)
    map_get_special("${ref}" object)
    ans(isobject)
    if(isobject)
      obj_keys("${ref}")
    else()
      map_keys("${ref}")
    endif()
    return_ans()
  endfunction()


# File: source/navigation/ref_nav_create_path.cmake


  function(ref_nav_create_path expression)
    navigation_expression_parse("${expression}")
    ans(expression)
    set(current_value ${ARGN})
    while(true)
      list(LENGTH expression continue)
      if(NOT continue)
        break()
      endif()

      list_pop_back(expression)
      ans(current_expression)
      if(NOT "${current_expression}" STREQUAL "[]")
        if("${current_expression}" MATCHES "^[<>].*[<>]$")
          message(FATAL_ERROR "invalid range: ${current_expression}")
        endif()
        map_new()
        ans(next_value)
        map_set("${next_value}" "${current_expression}" "${current_value}")
        set(current_value "${next_value}")
      endif()
    endwhile()
    return_ref(current_value)
  endfunction()




# File: source/navigation/ref_nav_get.cmake

## `(<current value:<any>> ["&"]<navigation expression>)-><any>`
## navigates the specified value and returns the value the navigation expression 
## points to.  If the value does not exist nothing is returned
## 
## if the expression is prepended by an ampersand `&` the current lvalue is returned.
## 
## **Examples**<%
##  set(data_input "{a:{b:{c:3},d:[{e:4},{e:5}]}}")
##  script("${data_input}")
##  ans(data)
##  function(ref_nav_get_example )
##    set(expr ${ARGN})
##    ref_nav_get("${data}" ${expr})
##    ans(res)
##    json("${res}")
##    ans(res)
##    creturn("`ref_nav_get(\\\${data} ${expr}) => ${res}`")
##  endfunction()
##  set(asdas 123)
## %>
## let `${data}` be `@json(${data_input})`
## then 
## * @ref_nav_get_example(a)
## * @ref_nav_get_example(a.b.c)
## * @ref_nav_get_example(a.b.c.d)
## * @ref_nav_get_example(a.d[1].e) 
## * @ref_nav_get_example(a.d[0].e)
## * @ref_nav_get_example(a.d)
## * @ref_nav_get_example()
## * @ref_nav_get_example(&a.b.c)
#cmake_policy(SET CMP0054 NEW)

function(ref_nav_get current_value)
    set(expression ${ARGN})
    if (${expression} MATCHES "^&(.*)")
        set(return_lvalue true)
        set(expression "${CMAKE_MATCH_1}")
    else ()
        set(return_lvalue false)
    endif ()

    navigation_expression_parse("${expression}")
    ans(expression)

    set(current_ref)
    set(current_property)
    set(current_ranges)
    foreach (current_expression ${expression})
        if ("${current_expression}" MATCHES "^[<>].*[<>]$")
            list_range_try_get(current_value "${current_expression}")
            ans(current_value)
            list(APPEND current_ranges ${current_expression})
        else ()
            is_address("${current_value}")
            #map_isvalid("${current_value}")
            ans(is_ref)
            if (NOT is_ref)
                set(current_value)
                break()
            endif ()
            set(current_ref "${current_value}")
            set(current_property "${current_expression}")
            set(current_ranges)

            ref_prop_get("${current_value}" "${current_expression}")
            ans(current_value)
        endif ()
    endforeach ()
    if (return_lvalue)
        map_capture_new(ref:current_ref property:current_property range:current_ranges value:current_value --reassign)
        return_ans()
    endif ()
    return_ref(current_value)

endfunction()

## nev version supports property of range expressions
function(ref_nav_get current_value)
    set(expression ${ARGN})
    #    print_var(expression)
    if ("${ARGN}" MATCHES "^&(.*)")
        message(FATAL_ERROR "address '${expression}' operation is unsupported")
    elseif ("${ARGN}" MATCHES "^%(.*)")
        set(return_lvalue true)
        set(expression "${CMAKE_MATCH_1}")
    else ()
        set(return_lvalue false)
    endif ()

    navigation_expression_parse(${expression})
    ans(expression)

    set(current_ref)
    set(current_property)
    set(current_ranges)
    set(evaluated_expression)
    foreach (current_expression ${expression})
        if (${current_expression} MATCHES "^[<>].*[<>]$")
            list_range_try_get(current_value "${current_expression}")
            ans(current_value)
            list(APPEND current_ranges ${current_expression})
        else ()
            set(current_ref)
            set(current_result_value)
            foreach (current_value_i ${current_value})
                is_address("${current_value_i}")
                ans(is_ref)
                if (is_ref)
                    list(APPEND current_ref "${current_value_i}")
                    #set(current_ref "${current_value}")
                    set(current_property "${current_expression}")
                    set(current_ranges)
                    ref_prop_get("${current_value_i}" "${current_expression}")
                    list(APPEND current_result_value ${__ans})
                endif ()
            endforeach ()
            set(current_value "${current_result_value}")

            if ("${current_value}_" STREQUAL "_")
                break()
            endif ()
        endif ()
    endforeach ()
    if (return_lvalue)
        map_capture_new(ref:current_ref property:current_property range:current_ranges value:current_value --reassign)
        return_ans()
    endif ()

    return_ref(current_value)

endfunction()


# File: source/navigation/ref_nav_set.cmake

## `(<base_value:<any>> ["!"]<navigation expresion> <value...>)-><any>`
##
## sets the specified navigation expression to the the value
## taking into consideration the base_value.
##
##
##
function(ref_nav_set base_value expression)
  string_take(expression "!")
  ans(create_path)

  navigation_expression_parse("${expression}")
  ans(expression)
  set(expression ${expression})

  set(current_value "${base_value}")
  set(current_ranges)
  set(current_property)
  set(current_ref)
  # this loop  navigates through existing values using ranges and properties as navigation expressions
  # the 4 vars declared before this comment will be defined
  while(true)
    list(LENGTH expression continue)
    if(NOT continue)
      break()
    endif()

    list_pop_front(expression)
    ans(current_expression)

    set(is_property true)
    if("${current_expression}" MATCHES "^[<>].*[<>]$")
      set(is_property false)
    endif()
 #   print_vars(current_expression is_property)
    if(is_property)

      #is_map("${current_value}")
      is_address("${current_value}")
      ans(is_ref)
      if(is_ref)
          set(current_ref "${current_value}")
          set(current_property "${current_expression}")
          set(current_ranges) 
      else()
        list_push_front(expression "${current_expression}")
        break()
      endif()

      ref_prop_get("${current_value}" "${current_expression}")
      ans(current_value)
    else()
      list_range_try_get(current_value "${current_expression}")
      ans(current_value)
      list(APPEND current_ranges "${current_expression}")
    endif()
  endwhile()



  set(value ${ARGN})
  
  # if the expressions are left and create_path is not specified
  # this will cause an error else the rest of the path is created
  list(LENGTH expression expression_count)
  if(expression_count GREATER 0)
    if(NOT create_path)
      message(FATAL_ERROR "could not find path ${expression}")
    endif()
    ref_nav_create_path("${expression}" ${value})
    ans(value)
  endif()

  ## get the last existing value
  if(current_ref)
    ref_prop_get("${current_ref}" "${current_property}")
    ans(current_value)
  else()
    set(current_value ${base_value})
  endif()

  ## if there are ranges set the interpret the value as a lsit and set the correct element
  list(LENGTH current_ranges range_count)
  if(range_count GREATER 0)
    list_range_partial_write(current_value "${current_ranges}" "${value}")
  else()
    set(current_value "${value}")
  endif()

  ## either return a new base balue or set the property of the last existing ref
  if(NOT current_ref)    
    set(base_value "${current_value}")
  else()
    ref_prop_set("${current_ref}" "${current_property}" "${current_value}")
  endif()

  return_ref(base_value)
endfunction()




# File: source/navigation/ref_prop_get.cmake


  function(ref_prop_get ref prop)
    map_get_special("${ref}" object)
    ans(isobject)
    if(isobject)
      obj_get("${ref}" "${prop}")
    else()
      map_tryget("${ref}" "${prop}")
    endif()
    return_ans()
  endfunction()

  ## faster
  macro(ref_prop_get ref prop)
    map_get_special("${ref}" object)
    ans(isobject)
    if(isobject)
      obj_get("${ref}" "${prop}")
    else()
      map_tryget("${ref}" "${prop}")
    endif()
  endmacro()

# File: source/navigation/ref_prop_set.cmake


  function(ref_prop_set ref prop)
    map_get_special("${ref}" object)
    ans(isobject)
    if(isobject)
      obj_set("${ref}" "${prop}" ${ARGN})
    else()
      map_set("${ref}" "${prop}" ${ARGN})
    endif()
  endfunction()



# File: source/object/core/obj_call.cmake

  # calls the object itself
  function(obj_call obj)
    map_get_special("${obj}" "call")
    ans(call)

    if(NOT call)
      message(FATAL_ERROR "cannot call '${obj}' - it has no call function defined")
    endif()
    set(this "${obj}")
    call("${call}" (${ARGN}))
    ans(res)
    return_ref(res )
  endfunction()

# File: source/object/core/obj_delete.cmake

function(obj_delete this)
 	map_delete(${this})
endfunction()



# File: source/object/core/obj_get.cmake


# returns the objects value at ${key}
function(obj_get this key)
  map_get_special("${this}" "get_${key}")
  ans(getter)
  if(NOT getter)
    map_get_special("${this}" "getter")
    ans(getter)    
    if(NOT getter)
      obj_default_getter("${this}" "${key}")
      return_ans()
    endif()

  endif()
  set_ans("")
  eval("${getter}(\"\${this}\" \"\${key}\")")
  return_ans()
endfunction()




# File: source/object/core/obj_has.cmake


  function(obj_has obj key)
    map_get_special("${obj}" has)
    ans(has)
    if(NOT has)
      obj_default_has_member("${obj}" "${key}")
      return_ans()
    endif()
    set_ans("")
    eval("${has}(\"\${obj}\" \"\${key}\")")
    return_ans()
  endfunction()


# File: source/object/core/obj_keys.cmake


  # returns all keys for the specified object
  function(obj_keys obj)
    map_get_special("${obj}" get_keys)
    ans(get_keys)
    if(NOT get_keys)
      obj_default_get_keys("${obj}")
      return_ans()
    endif()
    set_ans("")
    eval("${get_keys}(\"\${obj}\")")
    return_ans()
  endfunction()

# File: source/object/core/obj_member_call.cmake

# 
function(obj_member_call this key)
  #message("obj_member_call ${this}.${key}(${ARGN})")
  map_get_special("${this}" "member_call")
  ans(member_call)
  if(NOT member_call)
    obj_default_member_call("${this}" "${key}" ${ARGN})
    return_ans()
    #set(member_call obj_default_callmember)
  endif()
  call("${member_call}" ("${this}" "${key}" ${ARGN}))
  return_ans()
endfunction()



# File: source/object/core/obj_new.cmake

function(obj_new)
	set(args ${ARGN})
	list_pop_front( args)
	ans(constructor)
	list(LENGTH constructor has_constructor)
	if(NOT has_constructor)
		set(constructor Object)
	endif()
	

	if(NOT COMMAND "${constructor}")	
		message(FATAL_ERROR "obj_new: invalid type defined: ${constructor}, expected a cmake function")
	endif()

	obj_type_get(${constructor})
	ans(base)

	map_new()
	ans(instance)

	obj_setprototype(${instance} ${base})


	set(__current_constructor ${constructor})
	obj_member_call(${instance} __constructor__ ${args})
	ans(res)


	if(res)
		set(instance "${res}")
	endif()

	map_set_special(${instance} "object" true)

	return_ref(instance)
endfunction()

# File: source/object/core/obj_set.cmake


  # sets the objects value at ${key}
  function(obj_set this key)

    map_get_special("${this}" "set_${key}")
    ans(setter)
    if(NOT setter)
      map_get_special("${this}" "setter")
      ans(setter)
      if(NOT setter)
        obj_default_setter("${this}" "${key}" "${ARGN}")
        return_ans()
      endif()
    endif()
    set_ans("")
    eval("${setter}(\"\${this}\" \"\${key}\" \"${ARGN}\")")
    return_ans()
  endfunction()

# File: source/object/default/obj_default_get_keys.cmake

# default implementation for returning all avaialbe keys
function(obj_default_get_keys obj)
  map_keys("${obj}")
  ans(ownkeys)
  map_get_special("${obj}" "prototype")
  ans(prototype)
  if(NOT prototype)
    return_ref(ownkeys)
  endif()
  obj_keys("${prototype}")
  ans(parent_keys)
  set(keys ${ownkeys} ${parent_keys})
  list(LENGTH keys len)
  if(${len} GREATER 1)
    list(REMOVE_DUPLICATES keys)
  endif()
  return_ref(keys)
endfunction()

# File: source/object/default/obj_default_getter.cmake

  # default getter for object properties tries to get
  # the maps own value and if not looks for the prototype
  # special field and calls obj_get on it
  function(obj_default_getter obj key)
    map_has("${obj}" "${key}")
    ans(has_own_property)
    if(has_own_property)
      map_tryget("${obj}" "${key}")
      return_ans()  
    endif()

    map_get_special("${obj}" "prototype")
    ans(prototype)
    #message("proto is ${prototype}")
    if(NOT prototype)
      creturn()
    endif()

    obj_get("${prototype}" "${key}")
    return_ans()
  endfunction()

# File: source/object/default/obj_default_has_member.cmake

function(obj_default_has_member obj key)
  map_has("${obj}" "${key}")
  ans(has_member)
  if(has_member)
    creturn(true)
  endif()
  obj_getprototype("${obj}")
  ans(proto)
  if(NOT proto)
    creturn(false)
  endif()
  obj_has("${proto}" "${key}")
  return_ans()
endfunction()

# File: source/object/default/obj_default_member_call.cmake


# default implementation for calling a member
# imports all vars int context scope
# and binds this to the calling object
function(obj_default_member_call this key)
  #message("obj_default_callmember ${this}.${key}(${ARGN})")
  obj_get("${this}" "${key}")
  ans(member_function)
  if(NOT member_function)
    message(FATAL_ERROR "member does not exists '${this}.${key}'")
  endif()
  # this elevates all values of obj into the execution scope
  #obj_import("${this}")  
  call("${member_function}"(${ARGN}))
  return_ans()
endfunction()



# File: source/object/default/obj_default_setter.cmake




  # default setter for object properties sets the
  # owned value @ key
  function(obj_default_setter obj key value)
    map_set("${obj}" "${key}" "${value}")
    creturn()
  endfunction()

# File: source/object/default/obj_injectable_member_call.cmake


function(obj_injectable_callmember this key)
  map_get_special("${this}" before_call)
  ans(before_call)
  map_get_special("${this}" after_call)
  ans(after_call)

  set(call_this ${this})
  set(call_args ${ARGN})
  set(call_key ${key})
  set(call_result)
  
  if(before_call)
    call("${before_call}"())
  endif()
  obj_default_member_call("${this}" "${key}" "${ARGN}")
  ans(call_result)
  if(after_call)
    call("${after_call}"())
  endif()
  return_ref(call_result)
endfunction()


function(obj_before_callmember obj func)
  map_set_special("${obj}" call_member obj_injectable_callmember)
  map_set_special("${obj}" before_call "${func}")
endfunction()

function(obj_after_callmember obj func)
  map_set_special("${obj}" call_member obj_injectable_callmember)
  map_set_special("${obj}" after_call "${func}")
endfunction()

# File: source/object/helpers/data.cmake

## tries to parse structured data
## if structured data is not parsable returns the value passed
function(data)
    set(result)
    set(args ${ARGN})
    foreach (arg ${args})
        if ("_${arg}" MATCHES "^_(\\[|{).*(\\]|})$")
            script("${arg}")
            ans(val)
        else ()
            set(val "${arg}")
        endif ()
        list(APPEND result "${val}")
    endforeach ()
    return_ref(result)
endfunction()

# File: source/object/helpers/new.cmake

# shorthand for map_new and obj_new
# accepts a Type (which has to be a cmake function)
function(new)
  obj_new(${ARGN})
  return_ans()
endfunction()


  

# File: source/object/helpers/obj.cmake

# returns an object from string, or reference
# ie obj("{id:1, test:'asd'}") will return an object
  function(obj object_ish)
    is_map("${object_ish}")
    ans(isobj)
    if(isobj)
      creturn("${object_ish}")
    endif()
    if("${object_ish}" MATCHES "^{.*}$")
     script("${object_ish}")
     return_ans()
    endif()
    creturn()
  endfunction()

# File: source/object/helpers/obj_capture.cmake

## capture the specified variables in the specified obj
function(obj_capture map)
   set(__obj_capture_args ${ARGN})
    list_extract_flag(__obj_capture_args --notnull)
    ans(__not_null)
    foreach(__obj_capture_arg ${ARGN})
      if("${__obj_capture_arg}" MATCHES "(.+)[:=](.+)")
        set(__obj_capture_arg_key ${CMAKE_MATCH_1})
        set(__obj_capture_arg ${CMAKE_MATCH_2})
      else()
        set(__obj_capture_arg_key "${__obj_capture_arg}")
      endif()
     # print_vars(__obj_capture_arg __obj_capture_arg_key)
      if(NOT __not_null OR NOT "${${__obj_capture_arg}}_" STREQUAL "_")
        obj_set(${map} "${__obj_capture_arg_key}" "${${__obj_capture_arg}}")
      endif()
    endforeach()

endfunction()


# File: source/object/helpers/obj_declare_call.cmake


function(obj_declare_call obj out_function_name)
  function_new()
  ans(callfunc)
  map_set_special("${obj}" call "${callfunc}")
  set("${out_function_name}" "${callfunc}" PARENT_SCOPE)  
endfunction()  

# File: source/object/helpers/obj_declare_get_keys.cmake

function(obj_declare_get_keys obj function_ref)
    function_new()
    ans(func)
    map_set_special(${obj} get_keys ${func})
    set(${function_ref} ${func} PARENT_SCOPE)
  endfunction()


# File: source/object/helpers/obj_declare_getter.cmake


  function(obj_declare_getter obj function_name_ref)
      function_new()
      ans(func)
      map_set_special(${obj} getter "${func}")
      set(${function_name_ref} ${func} PARENT_SCOPE)
      creturn()
  endfunction()


# File: source/object/helpers/obj_declare_member_call.cmake


  function(obj_declare_member_call obj function_ref) 
    function_new()
    ans(func)
    map_set_special(${obj} member_call ${func})
    set(${function_ref} ${func} PARENT_SCOPE)
  endfunction()

# File: source/object/helpers/obj_declare_property.cmake

## declares a programmou able property 
## if one var arg is specified the function is ussed as a getter
## if there are more the one args you need to label the getter with --getter and setter with --setter
## if no var arg is specified the two functions will be created call
## get_${property_name} and set_${property_name}

  function(obj_declare_property obj property_name)
    set(args ${ARGN})
    list_extract_flag(args --hidden)
    ans(hidden)
    if(hidden)
      set(hidden --hidden)
    else()
      set(hidden)
    endif()

    list(LENGTH args len)
    if(${len} EQUAL 0)
      set(getter "get_${property_name}")
      set(setter "set_${property_name}")
    elseif(${len} GREATER 1)
      list_extract_labelled_value(args --getter)
      ans(getter)
      list_extract_labelled_value(args --setter)
      ans(setter)
    else()
      set(getter ${args})
    endif()

    if(getter)
      obj_declare_property_getter("${obj}" "${property_name}" "${getter}" ${hidden})
      set(${getter} ${${getter}} PARENT_SCOPE)
    endif()
    if(setter)
      obj_declare_property_setter("${obj}" "${property_name}" "${setter}" ${hidden})
      set(${setter} ${${setter}} PARENT_SCOPE)
    endif()
  endfunction()


# File: source/object/helpers/obj_declare_property_getter.cmake


  ## obj_declare_property_getter(<objref> <propname:string> <getter:cmake function ref>)
  ## declares a property getter for a specific property
  ## after the call getter will contain a function name which needs to be implemented
  ## the getter function signature is (current_object key values...)
  ## the getter function also has access to `this` variable
  function(obj_declare_property_getter obj property_name getter)
    set(args ${ARGN})
    list_extract_flag(args --hidden)
    ans(hidden)
    function_new()
    ans("${getter}")
    if(NOT hidden)
      map_set("${obj}" "${property_name}" "")
    endif()
    map_set_special("${obj}" "get_${property_name}" "${${getter}}")
    set("${getter}" "${${getter}}" PARENT_SCOPE)
  endfunction()

# File: source/object/helpers/obj_declare_property_setter.cmake

## sets the a setter functions for a specific property
  function(obj_declare_property_setter obj property_name setter)
    set(args ${ARGN})
    list_extract_flag(args --hidden)
    ans(hidden)
    function_new()
    ans("${setter}")
    if(NOT hidden)
      map_set("${obj}" "${property_name}" "")
    endif()
    map_set_special("${obj}" "set_${property_name}" "${${setter}}")
    set("${setter}" "${${setter}}" PARENT_SCOPE)

  endfunction()


# File: source/object/helpers/obj_declare_setter.cmake


  function(obj_declare_setter obj function_ref)
    function_new()
    ans(res)
    map_set_special(${obj} setter ${res})
    set(${function_ref} ${res} PARENT_SCOPE)
  endfunction()


# File: source/object/helpers/obj_gethierarchy.cmake

# returns a list of prototypes for ${this}
function(obj_gethierarchy this )
	set(current ${this})
	set(types)
	while(current)
		obj_gettype(${current} )
		ans(type)
		if(type)
			list(APPEND types ${type})
		endif()
		obj_getprototype(${current} )
		ans(proto)
		set(current ${proto})
	endwhile()

	return_ref(types)
endfunction()

# File: source/object/helpers/obj_getprototype.cmake


  function(obj_getprototype obj)
    map_get_special("${obj}" prototype)
    ans(res)
    return_ref(res)
  endfunction()

# File: source/object/helpers/obj_import.cmake


  function(obj_import obj)
    if(ARGN)
      foreach(arg ${ARGN})
        obj_get("${obj}" "${arg}")
        ans(val)
        set("${arg}" "${val}" PARENT_SCOPE)
      endforeach()
    endif()
    obj_keys("${obj}")
    ans(keys)
    foreach(key ${keys})
      obj_get("${obj}" "${key}")
      ans(val)
      set("${key}" "${val}" PARENT_SCOPE)
    endforeach()

  endfunction()

# File: source/object/helpers/obj_pick.cmake



  # creates a new map only getting the specified keys
  function(obj_pick map)
    map_new()
    ans(res)
    foreach(key ${ARGN})
      obj_get(${map} "${key}")
      ans(val)

      map_set("${res}" "${key}" "${val}")
    endforeach()
    creturn("${res}")
  endfunction()

# File: source/object/helpers/obj_setprototype.cmake


  function(obj_setprototype obj prototype)
    map_set_special("${obj}" prototype "${prototype}")
    creturn()
  endfunction()

# File: source/object/helpers/objs.cmake



# converts the <structured data?!...> into  <structured data...>
function(objs)
  set(res)
  foreach(arg ${ARGN})
    obj(${arg})
    ans(arg)
    list(APPEND res "${arg}")
  endforeach()
  return_ref(res)
endfunction()

# File: source/object/helpers/structured_data.cmake


## returns structured data - either from a runtime object or a file
function(structured_data)
  is_map("${ARGN}")
  ans(isMap)
  if(isMap)
    creturn(${ARGN})
  endif()

  fopen_data("${ARGN}")
  ans(data)

  return_ref(data)
endfunction()

# File: source/object/helpers/type_get.cmake

function(obj_type_get type)
	if(NOT COMMAND ${type})
		message(FATAL_ERROR "obj_new: only cmake functions are allowed as types, '${type}' is not function")
	endif()	
	set(base)
	#get_property(base GLOBAL PROPERTY "type_${type}")
	if(NOT base)
		map_new()
		ans(base)		
		set_property(GLOBAL PROPERTY "type_${type}" "${base}")
		map_set_special("${base}" constructor "${type}")
	endif()
	return_ref(base)
endfunction()

# File: source/object/this/property.cmake

## shorthand for obj_declare_property 
##
macro(property)
  obj_declare_property(${this} ${ARGN})
endmacro()


# File: source/object/this/proto_declarefunction.cmake

function(proto_declarefunction result)
  string(REGEX MATCH "[a-zA-Z0-9_]+" match "${result}")
  set(function_name "${match}")
  obj_getprototype(${this})
  ans(proto)
	if(NOT proto)
		message(FATAL_ERROR "proto_declarefunction: expected prototype to be present")
	endif()
	set(res ${result})
  set(__current_member ${function_name})
  function_new(${function_name} ${ARGN})
  ans(func)
  obj_set("${proto}" "${function_name}" "${func}")
	#obj_declarefunction(${proto} ${res})
	set(${function_name} "${func}" PARENT_SCOPE)
endfunction()


## shorthand for proto_declarefunction
macro(method result)
  proto_declarefunction("${result}")
endmacro()


# causes the following code inside a constructor to only run once
macro(begin_methods)

endmacro()

# File: source/object/this/this_append.cmake

# appends the value(s) to the specified member variable
function(this_append member_name)
  obj_get("${this}" "${member_name}")
  ans(value)
  obj_set("${this}" "${member_name}" ${value} "${ARGN}")
endfunction()

# File: source/object/this/this_callmember.cmake


function(this_callmember function)
	obj_member_call("${this}" "${function}" ${ARGN})
  return_ans()
endfunction()

# File: source/object/this/this_capture.cmake


  macro(this_capture)
    obj_capture(${this} ${ARGN})
  endmacro()



# File: source/object/this/this_declare_call.cmake

function(this_declare_call out_function_name)
  function_new()
  ans(callfunc)
  map_set_special("${this}" call "${callfunc}")
  set(${out_function_name} ${callfunc} PARENT_SCOPE)
endfunction()


# File: source/object/this/this_declare_get_keys.cmake


  function(this_declare_get_keys function_ref)
    obj_declare_get_keys(${this} _ref)
    set(${function_ref} ${_ref} PARENT_SCOPE)
  endfunction()

# File: source/object/this/this_declare_getter.cmake


  function(this_declare_getter function_name_ref)
    obj_declare_getter(${this} _res)
    set(${function_name_ref} ${_res} PARENT_SCOPE)
    creturn()
  endfunction()

# File: source/object/this/this_declare_member_call.cmake


  function(this_declare_member_call function_ref)
    obj_declare_member_call(${this} _res)
    set(${function_ref} ${_res} PARENT_SCOPE)
  endfunction()


# File: source/object/this/this_declare_setter.cmake



  function(this_declare_setter function_ref)
    obj_declare_setter(${this} _ref)
    set(${function_ref} ${_ref} PARENT_SCOPE)
  endfunction()



# File: source/object/this/this_declarefunction.cmake


function(this_declarefunction result)
	this_check()
	obj_declarefunction(${this} ${result})
	return_value(${${result}})
endfunction()

# File: source/object/this/this_get.cmake

macro(this_get member_name)
	obj_get("${this}" "${member_name}")
  ans("${member_name}")
endmacro()

# File: source/object/this/this_import.cmake

# imports all variables specified as varargs
macro(this_import)
  obj_import("${this}" ${ARGN})
endmacro()

# File: source/object/this/this_inherit.cmake

#inherits from base (if base is an objct it will be set as the prototype of this)
# if base is a function / constructor then a base object will be constructed and set
# as the prototy of this
function(this_inherit baseType)
	obj_type_get( ${baseType})
	ans(base)
	obj_getprototype(${this})
	ans(prototype)
	obj_setprototype(${prototype} ${base})
	map_get_special(${base} constructor)
	ans(super)
	function_import("${super}" as base_constructor REDEFINE)
	clr()	
  set(__current_constructor "${super}")
  obj_setprototype(${this} ${base})
	base_constructor(${ARGN})
	obj_setprototype(${this} ${prototype})
	ans(instance)
	if(instance)
		set(this "${instance}" PARENT_SCOPE)
	endif()
endfunction()


# File: source/object/this/this_set.cmake

# sets both the objects proerpty and the local cmake variable called ${member_name}
function(this_set member_name)
	obj_set("${this}" "${member_name}" "${ARGN}")
	set(${member_name} "${ARGN}" PARENT_SCOPE)
endfunction()



# File: source/object/this/this_setprototype.cmake

function(this_setprototype proto_ref)
	obj_setprototype(${this} ${proto_ref})
endfunction()

# File: source/package/package_content/package_content_check.cmake


## `(<package handle> <content_dir: <path>>)-><bool>`
## checks to see if the package content is valid at the specified locatin
## returns true if so else returns false
function(package_content_check package_handle content_dir)
  path_qualify(content_dir)
  if(NOT EXISTS "${content_dir}")
    creturn(false)
  endif()
  creturn(true)
endfunction()

# File: source/package/package_dependency/package_dependency_change_parse.cmake

## `(<change action>)->[ <admissable uri>, <action>]`
##
## parses a change action `<change action> ::= <admissable uri> [" " <action>]`
## `<action> ::= "add"|"remove"|"optional"|<dependency constraint>`
## the default action is `add`
function(package_dependency_change_parse)
  set(action ${ARGN})
  string_take_regex(action "[^ ]+")
  ans(admissable_uri)
  if("${admissable_uri}_" STREQUAL "_")
    creturn()
  endif()
  string_take_whitespace(action)
  data("${action}")
  ans(action)

  if("${action}_" STREQUAL "_")
    set(action add)
  endif()

  is_address(${action})
  ans(isref)  
  if(isref)
    set(action add ${action})
  elseif("${action}" MATCHES "^((add)|(remove)|(optional)|(conflict))$")
    set(action ${CMAKE_MATCH_1})
  else()
    message(FATAL_ERROR "invalid change: ${action}")
  endif()

  set(result ${admissable_uri} ${action})
  return_ref(result)
endfunction()

# File: source/package/package_dependency/package_dependency_changeset.cmake

## `(<dependency changeset>|<change ...>)-><dependency changeset>`
##
## returns a `<dependency changeset>`
## ```
## <dependency changeset>::={
##  <<admissable uri>:<dependency constraint>>... 
## }
## <change> ::= <admissable uri> [" " <dependency constraint> | "remove"  ] 
## ``` 
##
function(package_dependency_changeset)
  is_address("${ARGN}")
  ans(isref)
  if(isref)
    creturn(${ARGN})
  endif()
  package_dependency_changeset_parse(${ARGN})
  return_ans()
endfunction()


# File: source/package/package_dependency/package_dependency_changeset_parse.cmake

## `(<change action>...)-> <packag dependency changeset>`
##
## ```
## <package dependency changeset> ::= {
##   <admissable_uri> : <change action>
## }
## ```
## parses a changeset from the specified console friendly input arguments
## 
function(package_dependency_changeset_parse)
  map_new()
  ans(changeset)
  foreach(action ${ARGN})
    package_dependency_change_parse("${action}")
    ans_extract(admissable_uri)
    ans(action)
    if(NOT "${admissable_uri}_" STREQUAL "_")
      map_set("${changeset}" "${admissable_uri}" "${action}")
    endif()
  endforeach()
  return_ref(changeset)
endfunction()

# File: source/package/package_dependency/package_dependency_configuration.cmake

## `(<package source> <package handle>  [--cache <map>] )-> <dependency configuration>`
##  
## the `<dependency configuration> ::= { <<dependable uri>:<bool>>... }`
## is a map which indicates which dependencies MUST BE present and which MAY NOT
##
##  returns a map of `package uri`s which consist of a valid dependency configuration
##  { <package uri>:{ state: required|incompatible|optional}, package_handle{ dependencies: {packageuri: package handle} } }
##  or a reason why the configuration is impossible
##
##  **sideffects**
## *sets the `dependencies` property of all `package handle`s to the configured dependency using `package_dependency_configuration_set`.
##  
function(package_dependency_configuration package_source root_handle)  
  package_dependency_resolve_and_satisfy("${package_source}" "${root_handle}" ${ARGN})
  ans(dependency_problem)

  ## get the assignments
  map_tryget(${dependency_problem} dp_result)
  ans(dp_result)
  map_tryget(${dp_result} atom_assignments)
  ans(assignments)

  map_tryget(${dependency_problem} package_graph)
  ans(package_graph)
  map_values("${package_graph}")
  ans(package_handles)

  if(assignments)
    ## update the package handles
    package_dependency_configuration_set("${assignments}" ${package_handles})
  endif()
  return_ref(assignments)
endfunction()





# File: source/package/package_dependency/package_dependency_configuration_changeset.cmake

## `(<lhs: <dependency configuration>> <rhs:<dependency configuration>>-><changeset>`
## 
## compares two dependency configurations and returns a resulting changeset
## the `<changeset> ::= { <dependable uri>:"install"|"uninstall"}` 
function(package_dependency_configuration_changeset lhs rhs)
    set(package_uris)
    map_keys(${lhs})
    ans_append(package_uris)
    map_keys(${rhs})
    ans_append(package_uris)
    list_remove_duplicates(package_uris)

    map_new()
    ans(changeset)


    foreach(package_uri ${package_uris})
      map_tryget(${lhs} ${package_uri})
      ans(before)
      map_tryget(${rhs} ${package_uri})
      ans(after)

      set(action)

      if(NOT after)
        if(NOT "${before}_" STREQUAL "false_")
          set(action uninstall)
        endif()
      elseif(after AND NOT before)
        set(action install)

      endif()

      if(action)
        map_set(${changeset} ${package_uri} ${action})
      endif()
    endforeach()

    return_ref(changeset)
endfunction()  

# File: source/package/package_dependency/package_dependency_configuration_set.cmake

##
##
## takes a specific dependency configuration and a set of package descriptors from
## a package graph obtained by package_dependency_graph_resolve and updates 
## the package_handle's dependencies property to contain a single unique package handle 
## for every admissable_uri. before the dependencies property maps admissable_uri x {package uri x package handle}
##
function(package_dependency_configuration_set configuration)
  if(NOT configuration)
    message(FATAL_ERROR "package_dependency_configuration_set: expected a valid configuration map")
  endif()
  set(package_handles ${ARGN})

  foreach(package_handle ${package_handles})
    map_tryget(${package_handle} dependencies)
    ans(dependencies)
    if(dependencies)
      map_keys(${dependencies})
      ans(admissable_uris)

      foreach(admissable_uri ${admissable_uris})
        map_tryget(${dependencies} ${admissable_uri})
        ans(possible_dependencies)
        map_values(${possible_dependencies})
        ans(possible_dependencies)
        map_set(${dependencies} ${admissable_uri})

        foreach(possible_dependency ${possible_dependencies})
          map_tryget(${possible_dependency} uri)
          ans(possible_dependency_uri)
          map_has(${configuration} ${possible_dependency_uri})
          ans(has_uri)
          if(has_uri)
            map_set(${dependencies} ${admissable_uri} ${possible_dependency})
            break()
          endif()
        endforeach()
      endforeach()

    endif()
  endforeach()
endfunction()

# File: source/package/package_dependency/package_dependency_configuration_update.cmake

## `()-><dependency configuration>`
##
## 
function(package_dependency_configuration_update package_source project_handle)
  set(args ${ARGN})
  ## get cache if available - else create a new one
  list_extract_labelled_value(args --cache)
  ans(cache)
  if(NOT cache)
    map_new()
    ans(cache)
  endif()

  package_handle_update_dependencies(${project_handle} ${args})
  ans(changes)

  package_dependency_configuration("${package_source}" "${project_handle}" --cache ${cache})
  ans(configuration)

  return_ref(configuration)
endfunction()





# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_clause_new.cmake

## `(<dependency constraint> <reason:<string>> <<literal>|<negated literal>>...)-><dependency constraint clause>`
##
## ```
## <package dependency constraint clause> ::= {
##   reason: <string>
##   literals: <["!"] <package uri>>...
## } 
## ```
##
## creates the specified clause and returns it. expects literals to be package handles
## adds the clause to the constraints clauses property. A good reason helps the user
## debug the dependency problem should an error occur. The reason is formatted ie strings may contain `{<navigation expressions>}`
function(package_dependency_constraint_clause_new constraint reason)
  ## format reason
  format("${reason}")
  ans(reason)


  map_new()
  ans(clause)
  map_set(${clause} reason "${reason}")
  ## loop through all literals and add them to the clause object
  set(literals ${ARGN})
  foreach(literal ${literals})
    if("${literal}" MATCHES "^!(.+)")
      map_tryget(${CMAKE_MATCH_1} uri)
      ans(uri)
      map_append(${clause} literals "!${uri}")
    else()
      map_tryget(${literal} uri)
      ans(uri)
      map_append(${clause} literals "${uri}")
    endif()
  endforeach()

  ## add clause to constraint's claues property and set 
  ## the clause's constraint property
  map_set(${clause} constraint ${constraint})
  map_append(${constraint} clauses ${clause})

  creturn(${clause})
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_derive_all.cmake

## `(<dependency problem>) -> <package dependency constraint clause>...`
## 
## **note** this function will be refactored along with `package_dependency_constraint_derive_single_package` and `package_dependency_constraint_derive`
## creates cnf clauses for all dependencies in the dependency graph
## this is done by walking all package handles of the `dependency_problem.package_graph`
## and calling all `package_dependency_constraint_derive_single_package` on each of the
function(package_dependency_constraint_derive_all dependency_problem) 
  map_tryget(${dependency_problem} package_graph)
  ans(package_graph)


  map_values("${package_graph}")
  ans(package_handles)

set(derived_constraints)
  ## loop through all package handles in dependency graph 
  ## and add their dependency clauses to clauses sequence
  foreach(package_handle ${package_handles})      
    package_dependency_constraint_derive_single_package("${dependency_problem}" "${package_handle}")
    ans_append(derived_constraints)
  endforeach()

  ## loop through all constraints and collect the clauses
  set(clauses)
  foreach(constraint ${derived_constraints})
    map_tryget(${constraint} clauses)
    ans_append(clauses)
  endforeach()


  return_ref(clauses)
endfunction()


# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_derive_single_dependency.cmake

## `(<dependency problem>)-><package dependency constraint>...`
##
## this function tries to derive constraints for the specified package handle
## uses the constraint handlers specified in `dependency_problem.constraint_handlers`
function(package_dependency_constraint_derive_single_dependency
  dependency_problem
  dependee_handle 
  admissable_uri
  dependency_constraint
  possible_dependencies
  )

  ## if dependency_constraint is a map it is a valid depndency constraint
  is_address("${dependency_constraint}")
  ans(is_address)
  if(is_address)

    map_tryget(${dependency_constraint} constraint_type)
    ans(constraint_type)

    if("${constraint_type}_" STREQUAL "_")
        map_set(${dependency_constraint} constraint_type "required")
        set(constraint_type "required")
    endif()

    if("${constraint_type}_" STREQUAL "_")
        error("invalid constraint type for {dependee_handle.uri} => {admissable_uri} (got '{constraint_type}')")
      creturn()
    endif()

    set(derived_constraints)
    map_tryget(${dependency_problem} constraint_handlers)
    ans(constraint_handlers)
    foreach(handler ${constraint_handlers})
      call2(
        "${handler}" 
        "${dependency_problem}" 
        "${dependee_handle}" 
        "${admissable_uri}" 
        "${dependency_constraint}"
        "${possible_dependencies}"
        )
      ans_append(derived_constraints)
    endforeach()

    return_ref(derived_constraints)
  endif()

  ## if the dependency_constraint is not a map it may either by empty, optional , true or false
  ## the correct object will be created and recursively handled
  if("${dependency_constraint}_" STREQUAL "_" OR "${dependency_constraint}_" STREQUAL "optional_")
    map_new()
    ans(dependency_constraint)
    map_set(${dependency_constraint} constraint_type optional)
  elseif("${dependency_constraint}" MATCHES "^((true)|(false))$")
    map_new()
    ans(dependency_constraint)

    if(CMAKE_MATCH_1)
      map_set(${dependency_constraint} constraint_type required)
    else()
      map_set(${dependency_constraint} constraint_type incompatible)
    endif()
  else()
    error("invalid dependency constraint: '${dependency_constraint}'")
    creturn()
  endif()

  package_dependency_constraint_derive_single_dependency(
    "${dependency_problem}"
    "${dependee_handle}"
    "${admissable_uri}"
    "${dependency_constraint}"
    "${possible_dependencies}"
    )
  return_ans()
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_derive_single_package.cmake

## `(<clauses:<sequence>> <dependee_handle:<package handle>>)-><void>`
##
##
## adds depdency clauses resulting from dependee handle to the 
## clauses sequence.  Currently only supports  
##
## **currently only supports true, false and "" constraints**
function(package_dependency_constraint_derive_single_package dependency_problem dependee_handle)

  map_tryget(${dependee_handle} dependencies)
  ans(dependencies)

  map_tryget(${dependee_handle} package_descriptor)
  ans(package_descriptor)

  map_tryget("${package_descriptor}" dependencies)
  ans(constraints)

  map_keys(${dependencies})
  ans(admissable_uris)

  ## todo:  this has to become nicer.....
  ## actually the whole following section is pretty stupid.
  ## it should just call package_dependency_constraint_derive_single_dependency on 
  ## every package handle / dependecy problem
  ## and every constraint handler should then be able to 
  ## get its own dependencies, possibley with a helper function
  ## ala get_constraint_and_dependencies()....
  map_new()
  ans(empty)
  map_new()
  ans(package_constraint)
  map_set(${package_constraint} constraint_type "package_constraint")
  ## derive package constraints
  package_dependency_constraint_derive_single_dependency(
    "${dependency_problem}"
    "${dependee_handle}"
    "self"
    "${package_constraint}" 
    "${empty}")
  ans(derived_constraints)

  

  foreach(admissable_uri ${admissable_uris})
    map_tryget("${constraints}" "${admissable_uri}")
    ans(dependency_constraint)

    ## gets all dependency handles for admissable_uri
    map_tryget("${dependencies}" "${admissable_uri}")
    ans(dependency_handle_map)
    
    package_dependency_constraint_derive_single_dependency(
      "${dependency_problem}"
      "${dependee_handle}" 
      "${admissable_uri}"
      "${dependency_constraint}" 
      "${dependency_handle_map}"
    )
    ans_append(derived_constraints)

  endforeach()

  return_ref(derived_constraints)
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_incompatible.cmake


function(package_dependency_constraint_incompatible
  dependency_problem 
  dependee
  admissable_uri 
  dependency_constraint
  possible_dependencies
  )
  
  ## ignore constraints which are not "incompatible" type
  map_tryget(${dependency_constraint} constraint_type)
  ans(constraint_type)

  if(NOT "${constraint_type}" STREQUAL "incompatible")
    creturn()
  endif()


  package_dependency_constraint_new("incompatible" "${dependee}")
  ans(constraint)

  map_values(${possible_dependencies})
  ans(dependencies)
  foreach(dependency ${dependencies})
    package_dependency_constraint_clause_new(
      ${constraint}
      "'{dependee.uri}' is incompatible with '{dependency.uri}'" 
      "!${dependee}" "!${dependency}")
  endforeach()

  creturn(${constraint})
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_mutually_exclusive.cmake


function(package_dependency_constraint_mutually_exclusive
   dependency_problem 
  dependee_handle
  admissable_uri 
  dependency_constraint
  possible_dependencies
  )
  ## if dependency is not mutually_exclusive ignore
  map_tryget(${dependency_constraint} mutually_exclusive)
  ans(is_mutually_exclusive)
  if(NOT is_mutually_exclusive)
    creturn()
  endif()


  package_dependency_constraint_new("mutually_exclusive" "${dependee_handle}")
  ans(constraint)
  
  ## loop through all dependencies and add the mutual exclusitivity as a clause to the the cosntraint
  map_values(${possible_dependencies})
  ans(dependencies)
  set(current_dependencies ${dependencies})
  foreach(lhs ${dependencies})
    list(REMOVE_ITEM current_dependencies ${lhs})
    foreach(rhs ${current_dependencies})
      package_dependency_constraint_clause_new(
        ${constraint}
        "mutually exclusivivity" 
        "!${lhs}" "!${rhs}")
    endforeach()
  endforeach()

  creturn(${constraint})
endfunction()


# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_new.cmake

## `(<type:<string>> <package handle>)-> <package dependency constraint>` 
##
## creates a new dependecy constraint.  The type must be unqiue.
function(package_dependency_constraint_new type package_handle)
  map_new()
  ans(constraint)
  map_set(${constraint} type "${type}")
  map_set(${constraint} package_handle "${package_handle}")
  creturn(${constraint})
endfunction()


# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_optional.cmake


function(package_dependency_constraint_optional
   dependency_problem 
  dependee_handle
  admissable_uri 
  dependency_constraint
  possible_dependencies)

  ## if constraint type is not optional ignore
  map_tryget(${dependency_constraint} constraint_type)
  ans(constraint_type)
  if(NOT "${constraint_type}_" STREQUAL "optional_")
    creturn()
  endif()


  package_dependency_constraint_new("optional" "${dependee_handle}")
  ans(constraint)

  creturn(${constraint})
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_required.cmake

## creates the dependency required cosntraint for the specified dependee
function(package_dependency_constraint_required
  dependency_problem 
  dependee
  admissable_uri 
  dependency_constraint
  possible_dependencies
  )
  
  ## if constraint_type is not required ignore
  map_tryget(${dependency_constraint} constraint_type)
  ans(type)
  if(NOT "${type}" STREQUAL "required")
    creturn()
  endif()

  map_values(${possible_dependencies})
  ans(dependencies)

  package_dependency_constraint_new("required" "${dependee}")
  ans(constraint)

  ## either depndee is not installed 
  set(clause "!${dependee}")
  foreach(dependency ${dependencies})
    ## or one of the dependencies is installed
    list(APPEND clause "${dependency}")
  endforeach()


  package_dependency_constraint_clause_new(
    ${constraint}
    "{dependee.uri} => {admissable_uri} requires one of {possible_dependencies.__keys__}" 
    ${clause})


  creturn(${constraint})
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_root_package.cmake


function(package_dependency_constraint_root_package
  dependency_problem 
  dependee_handle
  admissable_uri 
  dependency_constraint
  possible_dependencies)

  map_tryget(${dependency_constraint} constraint_type)
  ans(constraint_type)
  if(NOT "${constraint_type}" STREQUAL "package_constraint")
    creturn()
  endif()
  ## if root was not yet added and depndee is root package return a required constraint
  map_tryget(${dependency_problem} __root_handle_added)
  ans(__root_handle_added)

  if(__root_handle_added)
    creturn()
  endif() 



  map_tryget(${dependency_problem} root_handle)
  ans(root_handle)


  if(NOT "${dependee_handle}" STREQUAL "${root_handle}")
    creturn()
  endif()



  package_dependency_constraint_new("root_package" "${dependee_handle}")
  ans(constraint)

  package_dependency_constraint_clause_new(
    ${constraint}
    "root package is always required" 
    "${dependee_handle}")

  creturn(${constraint})
endfunction()

# File: source/package/package_dependency/package_dependency_constraint/package_dependency_constraint_semantic_version.cmake

## `()->`
## 
## constrains the semantic version of a dependency
function(package_dependency_constraint_semantic_version
  dependency_problem 
  dependee
  admissable_uri 
  dependency_constraint
  possible_dependencies)

  ## if dependency constraint does not have a version property then ignore
  map_has(${dependency_constraint} version)
  ans(has_version_constraint)
  if(NOT has_version_constraint)
    creturn()
  endif()

  ## get version constraint and compile it
  map_tryget(${dependency_constraint} version)
  ans(version_constraint)

  semver_constraint_compile("${version_constraint}")
  ans(compiled_version_constraint)


  ## create the package constraint to return 
  package_dependency_constraint_new("semantic_version" "${dependee}")
  ans(constraint)


  ## loop through all possible dependencies and if the version constraint does not hold 
  ## add a incompatibility clause to the cosntraint
  map_values(${possible_dependencies})  
  ans(dependencies)
  foreach(dependency ${dependencies})

    ## check version agains the version constraint
    map_tryget(${dependency} package_descriptor)
    ans(package_descriptor)
    map_tryget(${package_descriptor} version)
    ans(version)
    semver_constraint_compiled_evaluate("${compiled_version_constraint}" "${version}")
    ans(holds)

    ## if incompatible add incompatibility
    if(NOT holds)
      package_dependency_constraint_clause_new(
        ${constraint}
        "{dependee.uri} => {admissable_uri}: is incompatible with {dependency.uri} because version constraint '${version_constraint}' does not hold for '${version}'"
        "!${dependee}"
        "!${dependency}"
        )
    endif()

  endforeach()

  ## success returns a valid package_dependency_constraint
  creturn(${constraint})

endfunction()

# File: source/package/package_dependency/package_dependency_graph_resolve.cmake

## `(<package source> <package_handles:<package handle>...>  [--cache:<map>])->{ <<package uri>:<package handle>>...}`
##
## resolves the dependecy graphs given by `package_handles`
## returns a map of `<package uri> => <package handle>`
## uses the cache for to lookup `package uri`s
## the `package handle`s all habe a `dependees` and `dependencies` property
## see also `dependencies_resolve`
function(package_dependency_graph_resolve package_source)

  function(expand_dependencies package_source cache context package_handle)
    if(NOT package_handle)
      creturn()
    endif()
    map_tryget("${package_handle}" uri)
    ans(package_uri)

    #message(FORMAT "package_dependency_graph_resolve: expanding dependencies for ${package_uri}")
    map_has("${context}" "${package_uri}")
    ans(visited)
    if(visited)
      creturn()
    endif()

    map_set("${context}" "${package_uri}" ${package_handle})
    
    package_dependency_resolve("${package_source}"  "${package_handle}" --cache "${cache}")
    ## flatten the map twice -> results in package handles
    map_flatten(${__ans})
    map_flatten(${__ans})


    return_ans()
  endfunction()

  set(package_handles ${ARGN})
  list_extract_labelled_value(package_handles --cache)
  ans(cache)
  if(NOT cache)
    map_new()
    ans(cache)
  endif()

  ## add the root nodes of the graph into the cache
  foreach(package_handle ${package_handles})
    map_tryget(${package_handle} uri)
    ans(package_uri)
    map_set("${cache}" "${package_uri}" "${package_handle}")
  endforeach()


  ## create context
  map_new()
  ans(context)


  ## get a map of all dependencies mentioned in dependency graph
  curry3(() => expand_dependencies("${package_source}" "${cache}" "${context}" "/*"))
  ans(expand)
  dfs(${expand} ${package_handles})
  return_ref(context)
endfunction()



# File: source/package/package_dependency/package_dependency_manage.cmake


  function(pkg_inst)
    pkg_load()
    ans(project_handle)
    
    default_package_source()
    ans(package_source)
    
    map_tryget(${project_handle} dependency_configuration)
    ans(configuration)

    if(NOT configuration)
      creturn()
    endif()

    map_keys(${configuration})
    ans(package_uris)

    map_tryget(${project_handle} uri)
    ans(uri)
    list_remove(package_uris ${uri})
    foreach(package_uri ${package_uris})
      string_normalize("${package_uri}")
      ans(target)
      path_qualify(target)
      map_tryget(${configuration} ${package_uri})
      ans(pull)
      if(pull)
        if(NOT EXISTS "${target}")
          message("installing ${package_uri} to ${target}")
          #mkdir("${target}")
          call(package_source.pull(${package_uri} ${target}))
        endif()
      else()
        if(EXISTS "${target}")
          message("deleting ${package_uri} from ${target}")
          
          rm(-r "${target}")
        endif()
      endif()
    endforeach()  

    creturn(${configuration})

  endfunction()

function(pkg_load)
  path("project.cmake")
  ans(config)
  if(NOT EXISTS "${config}")
    map_new()
    ans(project_handle)
  else()
    cmake_read("${config}")
    ans(project_handle)
  endif()
  map_tryget(${project_handle} uri)
  ans(uri)
  if(NOT uri)
    map_set(${project_handle} uri project:root)

  endif()

  return_ref(project_handle)

endfunction()
function(pkg_save)
  cmake_write("project.cmake" ${project_handle})

endfunction()

function(pkg_dep)
  set(args ${ARGN})
  default_package_source()
  ans(package_source)
  pkg_load()
  ans(project_handle)
 
  project_update_dependencies(${package_source} ${project_handle} ${args})
  ans(res)
 
  pkg_save(${project_handle})
  return_ref(res)
endfunction()


  function(project_update_dependencies package_source project_handle)

    map_tryget(${project_handle} cache)
    ans(cache)
    if(NOT cache)
      map_new()
      ans(cache)
      map_set(${project_handle} cache ${cache})
    endif()


    map_tryget(${project_handle} dependency_configuration)
    ans(previous_configuration)
    if(NOT previous_configuration)
      map_new()
      ans(previous_configuration)
    endif()

    package_dependency_configuration_update(
      ${package_source} 
      ${project_handle} 
      ${ARGN} 
      --cache ${cache}
    )
    ans(configuration)
    map_set(${project_handle} dependency_configuration ${configuration})

    package_dependency_configuration_changeset(${previous_configuration} ${configuration})
    ans(res)


    return_ref(res)
  endfunction()


# File: source/package/package_dependency/package_dependency_problem/package_dependency_problem_complete.cmake



## takes the resolve
function(package_dependency_problem_complete dependency_problem)

  map_tryget(${dependency_problem} dp_result)
  ans(result)


  map_tryget(${result} success)
  ans(success)
  

  if(success)
    map_tryget(${result} assignments)
    ans(assignments)  
    map_tryget(${dependency_problem} cnf)
    ans(cnf)
    literal_to_atom_assignments("${cnf}" "${assignments}")
    ans(atom_assignments)
    map_set(${result} atom_assignments ${atom_assignments})
  endif()

  creturn(${result})
endfunction()


# File: source/package/package_dependency/package_dependency_problem/package_dependency_problem_init.cmake

## `(<package dependency problem>)-><bool>`
##
## initializes the dependency problem after it was configured
## derives the constraints and clauses and adds them to the dependency problem
## returns true on success
function(package_dependency_problem_init dependency_problem)
  is_address("${dependency_problem}")
  ans(is_ok)
  if(NOT is_ok)
    message(FATAL_ERROR "expected a dependency problem object")
  endif()

  ## create boolean satisfiablitiy problem 
  ## by getting all clauses
  package_dependency_constraint_derive_all(${dependency_problem})
  ans(clauses)
  map_set(${dependency_problem} clauses "${clauses}")  

  ## reformulate clause objects to cnf clauses
  sequence_new()
  ans(cnf_clauses)
  foreach(clause ${clauses})
    map_tryget(${clause} literals)
    ans(literals)
    sequence_add(${cnf_clauses} ${literals})
    ## debug output
    string(REPLACE ";" "|" literals "${literals}")
    log("{clause.reason}.  derived clause: ({literals})" --trace --function package_dependency_problem_init)
  endforeach()

  ## create cnf
  cnf("${cnf_clauses}")
  ans(cnf)

  map_set(${dependency_problem} cnf "${cnf}")

  creturn(true)

endfunction()

# File: source/package/package_dependency/package_dependency_problem/package_dependency_problem_new.cmake

## `(<package graph> <root_handle:<package handle>>)-><package dependency problem>`
##
## ```
## <package dependency problem> ::= {
##  package_graph: {<<package uri>:<package handle>>...}
##  constraint_handlers: <callable:<(...)-><package dependency constraint>>>...
##  root_handle: <package handle>   
##  cnf :  <cnf>          # the conjuntive normal form SAT problem formulation
##  dp_result: {...}      # result of the SAT solver
##  clauses: <package dependency constraint clause 
## }
## ```
## creates a package dependency problem context
function(package_dependency_problem_new package_graph root_handle)
  set(args ${ARGN})

  set(constraint_handlers 
    package_dependency_constraint_required
    package_dependency_constraint_optional
    package_dependency_constraint_mutually_exclusive
    package_dependency_constraint_semantic_version
    package_dependency_constraint_incompatible
    package_dependency_constraint_root_package
    )
  map_capture_new(
    package_graph
    root_handle 
    constraint_handlers
    )
  return_ans()

endfunction()

# File: source/package/package_dependency/package_dependency_problem/package_dependency_problem_run.cmake

## `(<package graph> <root_handle:<package handle>>)-><package dependency problem>`
##
## runs the the package dependency problem just using the package graph and the root handle as input
## returns the completed package dependency problem
function(package_dependency_problem_run package_graph root_handle)

  package_dependency_problem_new("${package_graph}" "${root_handle}")
  ans(dependency_problem)


  package_dependency_problem_init("${dependency_problem}")  
  ans(success)
  if(NOT success)
    message(FATAL_ERROR "failed to initialize dependency_problem")
  endif()

  package_dependency_problem_solve("${dependency_problem}")
  ans(success)
  if(NOT success)
    message(FATAL_ERROR "failed to solve dependency_problem")
  endif()

  package_dependency_problem_complete("${dependency_problem}")
  ans(success)
  if(NOT success)
    message(FATAL_ERROR "failed to complete dependency_problem")
  endif()

  return_ref(dependency_problem)

endfunction()

# File: source/package/package_dependency/package_dependency_problem/package_dependency_problem_solve.cmake

## `(<package dependency problem>)-><bool>` 
##
## solves the dependency problem by running the sat solver
## returns true on success
function(package_dependency_problem_solve dependency_problem)
  map_tryget(${dependency_problem} cnf)
  ans(cnf)

  ## solve boolean satisfiablitiy problem
  dp_naive("${cnf}")
  ans(result)

  map_set(${dependency_problem} dp_result "${result}")

  creturn(true)
endfunction()

# File: source/package/package_dependency/package_dependency_problem/package_dependency_problem_test.cmake

##
##
## helper function to test the package dependency problem. users should not use this
function(package_dependency_problem_test project_dependencies constraint_handlers)
  mock_package_source("mock" ${ARGN})
  ans(package_source)

  map_new()
  ans(cache)

  project_open(".")
  ans(project)

  assign(project.project_descriptor.package_source = package_source)


  assign("!project.package_descriptor.dependencies" = "${project_dependencies}")

  package_dependency_graph_resolve("${package_source}" "${project}" --cache ${cache})
  ans(package_graph)

  package_dependency_problem_new("${package_graph}" "${project}")
  ans(problem)


  assign(problem.constraint_handlers = constraint_handlers)
  
  timer_start(package_dependency_problem_init)
  package_dependency_problem_init("${problem}")
  ans(success)
  timer_print_elapsed(package_dependency_problem_init)

  timer_start(package_dependency_problem_solve)
  package_dependency_problem_solve("${problem}")
  ans(success)
  timer_print_elapsed(package_dependency_problem_solve)

  assign(res = problem.dp_result.initial_context.f.clause_map)

  sequence_to_list("${res}" "|" ")&(")
  ans(res)
  
  set(res "(${res})")
  message("cnf: ${res}")
  return_ref(res)


endfunction()



# File: source/package/package_dependency/package_dependency_resolve.cmake

## `(<package handle> [--cache <map>])->`
##
##
## resolves all dependencies for the specified package_handle
## keys of `package_handle.package_descriptor.dependencies` are `admissable uri`s 
## `admissable uri`s are resolved to `dependency handle`s 
## returns a map of `<admissable_uri>: <dependency handle>` if no dependencies are present 
## an empty map is returned
## sideffects 
## sets `<package handle>.dependencies.<admissable uri> = { <<dependable uri>:<dependency handle>>... }` 
## adds  to `<dependency handle>.dependees.<package uri> = { <admissable_uri>:<package handle> }` 
function(package_dependency_resolve package_source  package_handle )
  set(args ${ARGN})
  list_extract_labelled_value(args --cache)
  ans(cache)
  if(NOT cache)
    map_new()
    ans(cache)
  endif()

  if(NOT package_handle)
    message(FATAL_ERROR "no package handle specified")
  endif()

  map_get_map(${package_handle} dependency_descriptor)
  ans(dependency_descriptor)


  ## get the dependencies specified in package_handle's package_descriptor
  ## it does not matter if the package_descriptor does not exist
  set(admissable_uris)
  map_tryget("${package_handle}" package_descriptor)
  ans(package_descriptor)
  if(package_descriptor)
    map_tryget("${package_descriptor}" dependencies)
    ans(dependencies)
    if(dependencies)
      map_keys("${dependencies}")
      ans(admissable_uris)
    endif()
  endif()

  ## get package uri
  map_tryget(${package_handle} uri)
  ans(package_uri)

  #message(FORMAT "package_dependency_resolve: trying to resolve ${admissable_uris}")

  ## resolve all package dependencies
  ## and assign package handles dependencies property
  package_source_query_resolve_all("${package_source}" ${admissable_uris} --cache ${cache})
  ans(dependencies)

  ## todo replace first with latter
  map_set(${package_handle} dependencies ${dependencies})

  ## loop through all admissable uris 
  ## and assign dependees property 
  
  foreach(admissable_uri ${admissable_uris})
    ## get map for admissable_uri
    map_tryget(${dependencies} "${admissable_uri}")
    ans(dependency)

    map_keys(${dependency})
    ans(dependable_uris)
    foreach(dependency_uri ${dependable_uris})      
      map_tryget(${dependency} ${dependency_uri})
      ans(dependency_handle)
      
      map_tryget(${dependency_handle} dependees)
      ans(dependees)
      if(NOT dependees)
        map_new()
        ans(dependees)
        map_set(${dependency_handle} dependees ${dependees}) 
      endif()
      map_tryget(${dependees} ${package_uri})
      ans(dependee)
      if(NOT dependee)
        map_new()
        ans(dependee)
        map_set(${dependees} ${package_uri} ${dependee})
      endif()
      map_append_unique("${dependee}" "${admissable_uri}" "${package_handle}")
    endforeach()
  endforeach()

  return_ref(dependencies)
endfunction()


# File: source/package/package_dependency/package_dependency_resolve_and_satisfy.cmake


function(package_dependency_resolve_and_satisfy package_source root_handle)
  set(args ${ARGN})
  list_extract_labelled_value(args --cache)
  ans(cache)
  ## get cache if available - else create a new one
  if(NOT cache)
    ## cache map 
    map_new()
    ans(cache)
  endif()

  ## resolve graph
  package_dependency_graph_resolve("${package_source}" "${root_handle}" --cache ${cache} )
  ans(package_graph)

  ## run dependency problem
  package_dependency_problem_run("${package_graph}" "${root_handle}")
  ans(dependency_problem)
  
  return_ref(dependency_problem)
endfunction()

# File: source/package/package_dependency/package_handle_update_dependencies.cmake

## `(<package handle> <~package changeset>)-> <old changes>`
## 
## modified the dependencies of a package handle
## ```
##  package_handle_update_dependencies(${package_handle} "A" "B conflict") 
##  package handle: <%
##    map_new()
##   ans(package_handle)
##   package_handle_update_dependencies(${package_handle} "A" "B conflict")
##   template_out_json(${package_handle})
##  %>
## ```
function(package_handle_update_dependencies package_handle)
  if(NOT package_handle)
    message(FATAL_ERROR "package_handle_update_dependencies: no package handle specified")
    creturn()
  endif()
  package_dependency_changeset(${ARGN})
  ans(changeset)


  package_handle_dependencies("${package_handle}")
  ans(dependencies)
  
  map_new()
  ans(diff)

  map_keys(${changeset})
  ans(admissable_uris)
  
  foreach(admissable_uri ${admissable_uris})
    ## get previous value
    map_has(${dependencies} "${admissable_uri}")
    ans(has_constraint)

    if(has_constraint)
      map_tryget(${dependencies} "${admissable_uri}")
      ans(constraint)
      map_set(${diff} "${admissable_uri}" ${constraint})
    endif()

    ## set new value
    map_tryget(${changeset} ${admissable_uri})
    ans_extract(action)
    ans(constraint)



    if("${action}" STREQUAL "add")
      if(constraint)
        map_set(${dependencies} "${admissable_uri}" ${constraint})
      else()
        map_set(${dependencies} "${admissable_uri}" true)
      endif()
    elseif("${action}" STREQUAL "remove")
      map_remove(${dependencies} "${admissable_uri}")
    elseif("${action}" STREQUAL "conflict")
      map_set(${dependencies} ${admissable_uri} false)
    elseif("${action}" STREQUAL "optional")
      map_set(${dependencies} "${admissable_uri}")
    endif()    


  endforeach()
  return_ref(diff)
endfunction()




# File: source/package/package_descriptor/package_descriptor_parse_filename.cmake


  ## parses the package descriptor from the filename
  ## a filename's version is separated by a hyphen
  function(package_descriptor_parse_filename file_name)
    string_take_regex(file_name "([^-]|(-[^0-9]))+")
    ans(default_id)
    set(rest "${file_name}")
    string_take_regex(file_name "\\-")
    string_take_regex(file_name "v")

    semver_format("${file_name}")
    ans(default_version)
    if(default_version STREQUAL "")
      set(default_version "0.0.0")
    endif()

    data("{id:$default_id, version:$default_version}")
    return_ans()
  endfunction()

# File: source/package/package_handle/package_handle.cmake


  function(package_handle)
    map_tryget("${ARGN}" package_descriptor)
    ans(pd)
    map_tryget("${ARGN}" content_dir)
    ans(content_dir)

    path_qualify(content_dir)

    is_map("${pd}")
    ans(ismap)
    if(ismap AND content_dir AND IS_DIRECTORY "${content_dir}")
      creturn(${ARGN})
    endif()

    set(args ${ARGN})
    list_extract(args content_dir package_descriptor)

    path_qualify(content_dir)



    obj("${package_descriptor}")
    ans(pd)

    if(NOT pd)
      if(NOT IS_DIRECTORY "${content_dir}")
        creturn()
      endif()

      json_read("${content_dir}/package.cmake")
      ans(pd)
 
      if(NOT pd)
        creturn()
      endif()

    endif()


    map_new()
    ans(package_handle)
    map_set(${package_handle} package_descriptor ${pd})
    map_set(${package_handle} content_dir ${content_dir})
    creturn(${package_handle})

  endfunction()

# File: source/package/package_handle/package_handle_dependencies.cmake

## 
## ensures that the package_descriptor.package_handle exists
function(package_handle_dependencies package_handle)
  map_tryget(${package_handle} package_descriptor)
  ans(package_descriptor)
  if(NOT package_descriptor)
    map_new()
    ans(package_descriptor)
    map_set(${package_handle} package_descriptor ${package_descriptor})
  endif()
  map_tryget(${package_descriptor} dependencies)
  ans(dependencies)
  if(NOT dependencies)
    map_new()
    ans(dependencies)
    map_set(${package_descriptor} dependencies ${dependencies})
  endif()
  return_ref(dependencies)
endfunction()


# File: source/package/package_handle/package_handle_filter.cmake

function(package_handle_filter __handles uri)
      uri_coerce(uri)
  
      map_tryget(${uri} uri)
      ans(uri_string)

      ## return all handles if query uri is ?*
      if("${uri_string}" STREQUAL "?*")
        return_ref(${__handles})
      endif()

      foreach(package_handle ${${__handles}})
        map_tryget(${package_handle} uri)
        ans(package_uri)
        if("${package_uri}" STREQUAL "${uri_string}")
          creturn(${package_handle})
        endif()
      endforeach()

      assign(id_query = uri.params.id)
      if(id_query)
        set(result)
        foreach(package_handle ${${__handles}})
          assign(pid = package_handle.package_descriptor.id)
          if("${pid}_" STREQUAL "${id_query}_")
            list(APPEND result ${package_handle})
          endif() 
        endforeach()
        return_ref(result)
      endif()

      ## todo...

      creturn()


    endfunction()

# File: source/package/package_handle/package_handle_invoke_hook.cmake


## 
## 
## invokes a package descriptors hook in the correct context
## the pwd is set to content_dir and the var args are passed along
## the result of the hook or nothing is returned
## 
## the scope of the function inherits package_handle and package_descriptor
function(package_handle_invoke_hook package_handle path)
  assign(package_descriptor = package_handle.package_descriptor)
  assign(content_dir = package_handle.content_dir)
  assign(hook = "package_descriptor.${path}")
  if(NOT "${hook}_" STREQUAL "_")
    pushd(--force)
    if(EXISTS "${content_dir}")
      cd("${content_dir}")
    endif()
      call("${hook}"(${ARGN}))
      ans(res)
    popd(--force)
    return_ref(res)
  endif()
  creturn()
endfunction()

# File: source/package/package_handle/package_handle_is_ready.cmake

## 
## checks if every dependencies all_dependencies_materialized are set
##
function(package_handle_is_ready package_handle)
  map_tryget(${package_handle} materialization_descriptor)
  ans(is_materialized)
  if(NOT is_materialized)
    creturn(false)
  endif()
  map_tryget(${package_handle} dependencies)
  map_flatten(${__ans})
  ans(dependencies)
  set(all_dependencies_materialized true)
  foreach(dependency ${dependencies})
    map_get_map(${dependency} dependency_descriptor)
    ans(dependency_dependency_descriptor)
    map_tryget(${dependency_dependency_descriptor} is_ready)
    ans(dependency_all_dependencies_materialized)
    if(NOT dependency_all_dependencies_materialized)
      set(all_dependencies_materialized false)
      break()
    endif()
  endforeach()
  return_ref(all_dependencies_materialized)
endfunction()

# File: source/package/package_source/archive/archive_package_source.cmake

##
##
##
function(archive_package_source)
  obj("{
    source_name:'archive',
    pull:'package_source_pull_archive',
    query:'package_source_query_archive',
    resolve:'package_source_resolve_archive',
    rate_uri:'package_source_rate_uri_archive'
  }")
  return_ans()
endfunction()



# File: source/package/package_source/archive/package_source_pull_archive.cmake

## package_source_pull_archive(<~uri> <?target_dir>)-><package handle>
##
## pulls the specified archive into the specified target dir
## 
  function(package_source_pull_archive uri)
    set(args ${ARGN})

    list_pop_front(args)
    ans(target_dir)

    path_qualify(target_dir)

    uri("${uri}")
    ans(uri)

    ## get package from uri

    package_source_resolve_archive("${uri}")
    ans(package_handle)

    if(NOT package_handle)
      error("could not resolve specified uri {uri.uri} to a package file")
      creturn()
    endif()

    assign(archive_path = package_handle.archive_descriptor.path)

    ## uncompress compressed file to target_dir
    pushd("${target_dir}" --create)
      ans(target_dir)
      uncompress("${archive_path}")
    popd()

    ## set content_dir
    map_set(${package_handle} content_dir "${target_dir}")


    return_ref(package_handle)
  endfunction()


# File: source/package/package_source/archive/package_source_push_archive.cmake


  function(package_source_push_archive)
    if("${ARGN}" MATCHES "(.*);=>;?(.*)")
        set(source_args "${CMAKE_MATCH_1}")
        set(args "${CMAKE_MATCH_2}")
    else()
        set(source_args ${ARGN})
        set(args)
    endif()
    list_pop_front(source_args)
    ans(source)

    list_extract_flag(args --force)
    ans(force)

    list_pop_front(args)
    ans(target_file)

    ## used to pass format along
    list_extract_labelled_keyvalue(args --format)
    ans(format)


    path_qualify(target_file)

    path_temp()
    ans(temp_dir)

    assign(package_handle = source.pull(${source_args} "${temp_dir}"))
    assign(content_dir = package_handle.content_dir)# get content dir because pull may return somtehing different in case --reference is specified
    
    ## possibly generate a filename if ${target_file} is a directory
    if(IS_DIRECTORY "${target_file}")
        set(mimetype ${format})
        list_extract_labelled_value(mimetype --format)
        ans(mimetype)
        if(NOT mimetype)
            set(mimetype "application/x-gzip")
        endif()
        mime_type_get_extension("${mimetype}")
        ans(extension)
        format("{package_handle.package_descriptor.id}-{package_handle.package_descriptor.version}.{extension}")
        ans(filename)
        set(target_file "${target_file}/${filename}")
    endif()
    if(EXISTS "${target_file}")
        if(NOT force)
            error("cannot push: ${target_file} already exists")
            creturn()
        endif()
        if(IS_DIRECTORY "${target_file}")
            error("cannot push forced: ${target_file} is a directory")
            creturn()
        endif()
        rm("${target_file}")
    endif()

    ## compress all files in temp_dir into package
    pushd("${content_dir}")
      compress("${target_file}" "**" ${format})
    popd()

    ## cleanup
    rm("${temp_dir}")

    package_source_query_archive("${target_file}")
    ans(package_uri)


    ## set altered uri (now contains hash)
    map_set(${package_handle} uri "${package_uri}")

    return_ref(package_handle)
  endfunction()

# File: source/package/package_source/archive/package_source_query_archive.cmake

  ## package_source_query_archive(<~uri>)->
  ## 
  function(package_source_query_archive uri)
    set(args ${ARGN})
        
    log("querying for local archive at {uri.uri}" --trace --function package_source_query_archive)

    list_extract_flag(args --package-handle)
    ans(return_package_handle)


    uri_coerce(uri)

    ## uri needs to be local
    map_tryget(${uri} normalized_host)
    ans(host)
    if(NOT host STREQUAL "localhost")
      creturn()
    endif()

    ## get the local_path of the uri
    uri_to_localpath("${uri}")
    ans(local_path)

    path_qualify(local_path)

    ## check that file exists and is actually a archive
    archive_isvalid("${local_path}")
    ans(is_archive)

    if(NOT is_archive)
        log("'{local_path}' is not an archive" --trace --function package_source_query_archive)
      creturn()
    endif()

    assign(expected_hash = uri.params.hash)
    ##
    checksum_file("${local_path}")
    ans(hash)


    if(NOT "${expected_hash}_" STREQUAL "_" AND NOT "${expected_hash}" STREQUAL "${hash}" )
        error("expected hash did not match hash of ${local_path}")
        creturn()
    endif()

    ## qualify uri to absolute path
    uri("${local_path}")
    ans(qualified_uri)
    uri_format("${qualified_uri}")
    ans(resource_uri)

    set(package_uri "${resource_uri}?hash=${hash}")
    log("found archive package at '{uri.uri}'" --function package_source_query_archive --trace)
    if(return_package_handle)
        set(package_handle)
        assign(!package_handle.uri = package_uri)
        assign(!package_handle.query_uri = uri.uri)
        assign(!package_handle.resource_uri = resource_uri)
        assign(!package_handle.archive_descriptor.hash = hash)
        assign(!package_handle.archive_descriptor.path = local_path)
        assign(!package_handle.archive_descriptor.pwd = pwd())
        return_ref(package_handle)
    endif()



    return_ref(package_uri)
  endfunction()


# File: source/package/package_source/archive/package_source_rate_uri_archive.cmake



##
function(package_source_rate_uri_archive uri)
  uri_coerce(uri)
  uri_to_localpath("${uri}")
  ans(localpath)
  archive_isvalid("${localpath}")
  ans(isarchive)

  if(isarchive)
    creturn(999)
  endif()

  creturn(0)

endfunction()

# File: source/package/package_source/archive/package_source_resolve_archive.cmake

## package_source_resolve_archive(<~uri>)-> <package handle>
## 
## resolves the specified uri to a unqiue immutable package handle 
function(package_source_resolve_archive uri)
    uri_coerce(uri)


    ## query for uri and return if no single uri is found
    package_source_query_archive("${uri}" --package-handle)
    ans(package_handle)
    list(LENGTH package_handle uri_count)
    if(NOT uri_count EQUAL 1)
      error("archive package source could not resolve a single immutable package for {uri.uri}")
      creturn()
    endif()

    ## uncompress package descriptor
    assign(archive_path = package_handle.archive_descriptor.path)

    ## search for the first package.cmake file in the archive 
    archive_match_files("${archive_path}" "([^;]+/)?package\\.cmake"  --single)
    ans(package_descriptor_path)    


    if(package_descriptor_path)
        archive_read_file("${archive_path}" "${package_descriptor_path}")
        ans(package_descriptor_content)
    endif()

    json_deserialize("${package_descriptor_content}")
    ans(package_descriptor)


    ## set package descriptor defaults
    assign(file_name = uri.file_name)
    package_descriptor_parse_filename("${file_name}")
    ans(default_package_descriptor)

    map_defaults("${package_descriptor}" "${default_package_descriptor}")
    ans(package_descriptor)


    ## update package handle
    assign(package_handle.package_descriptor = package_descriptor)
    assign(package_handle.archive_descriptor.package_descriptor_path = package_descriptor_path)

    return_ref(package_handle)
endfunction()


# File: source/package/package_source/bitbucket/bitbucket_package_source.cmake

  function(bitbucket_package_source)
    obj("{
      source_name:'bitbucket',
      pull:'package_source_pull_bitbucket',
      query:'package_source_query_bitbucket',
      resolve:'package_source_resolve_bitbucket'
    }")
    return_ans()
  endfunction()



# File: source/package/package_source/bitbucket/package_source_pull_bitbucket.cmake


  function(package_source_pull_bitbucket uri)
    set(args ${ARGN})

    uri_coerce(uri)

    list_extract_flag(args --use-ssh)
    ans(use_ssh)

    package_source_resolve_bitbucket("${uri}")
    ans(package_handle)

    if(NOT package_handle)
      creturn()
    endif()

    list_pop_front(args)
    ans(target_dir)

    map_tryget(${package_handle} package_descriptor)
    ans(package_descriptor)

    assign(repo_descriptor = package_handle.bitbucket_descriptor.repository)

    map_tryget(${repo_descriptor} scm)
    ans(scm)

    assign(clone_locations = repo_descriptor.links.clone)
    map_new()
    ans(clone)
    foreach(clone_location ${clone_locations})
      map_import_properties(${clone_location} name href)
      map_set(${clone} ${name} ${href})
    endforeach()

    if(use_ssh)
      set(clone_method ssh)
    else()
      set(clone_method https)
    endif()

    map_tryget(${clone} "${clone_method}")
    ans(clone_uri)


    ## depending on scm pull git or hg
    if(scm STREQUAL "git")
      package_source_pull_git("${clone_uri}" "${target_dir}")
      ans(scm_package_handle)
    elseif(scm STREQUAL "hg")
      package_source_pull_hg("${clone_uri}" "${target_dir}")
      ans(scm_package_handle)
    else()
      message(FATAL_ERROR "scm not supported: ${scm}")
    endif()

    assign(package_handle.repo_descriptor = scm_package_handle.repo_descriptor)

    map_tryget("${scm_package_handle}" package_descriptor)
    ans(scm_package_descriptor)

    map_tryget("${scm_package_handle}" content_dir)
    ans(scm_content_dir)
    
    if(NOT scm_package_descriptor)
      map_new()
      ans(scm_package_descriptor)
    endif()  
    map_defaults("${package_descriptor}" "${scm_package_descriptor}")

    map_set("${package_handle}" content_dir "${scm_content_dir}")

    return_ref(package_handle)
  endfunction()

# File: source/package/package_source/bitbucket/package_source_query_bitbucket.cmake


## `(<~uri> [--package-handle])->`
## 
##
## 
  parameter_definition(package_source_query_bitbucket
    <--uri:<uri>>
    [--package-handle=>return_package_handle]
  )
function(package_source_query_bitbucket uri)
  arguments_extract_defined_values(0 ${ARGC} package_source_query_bitbucket)    
  ans(args)

  #list_extract_flag(args --package-handle)
  #ans(return_package_handle)


  uri_check_scheme(${uri} "bitbucket?")
  ans(scheme_ok)
  if(NOT scheme_ok)
    error("scheme {uri.scheme} is not supported - only bitbucket: or empty scheme allowed")
    creturn()
  endif()


  assign(segments = uri.normalized_segments)
  list_extract(segments user repo ref_type ref)
  assign(hash = uri.params.hash)

  if(NOT repo)
    set(repo *)
  endif()
  set(default false)
  if(NOT ref AND NOT ref_type)
    set(default true)
  endif()
  if(NOT ref AND NOT "${ref_type}" MATCHES "^(branches)|(tags)$")
    set(ref "${ref_type}")
    set(ref_type *)
  endif()
  if(NOT ref)
    set(ref "*")
  endif()


  map_new()
  ans(package_handles)

  if(hash)
    bitbucket_remote_ref("${user}" "${repo}" "commits" "${hash}")
    ans(remote_ref)

    map_import_properties(${remote_ref} ref_type ref)
    map_set(${package_handles} "bitbucket:${user}/${repo}/${name}/${ref_type}/${ref}" "${remote_ref}")
  elseif(user)
    if("${repo}" STREQUAL "*")
      ## get all repositories of user - no hash
      bitbucket_repositories("${user}")
      ans(names)

      foreach(name ${names})
        map_set(${package_handles} "bitbucket:${user}/${name}")
      endforeach()
    else()
      if(default)
        bitbucket_default_branch("${user}" "${repo}")
        ans(default_branch)
        if(default_branch)
          bitbucket_remote_ref("${user}" "${repo}" "branches" "${default_branch}")
          ans(ref)
          if(ref)
            map_tryget("${ref}" commit)
            ans(hash)
            set(package_uri "bitbucket:${user}/${repo}/branches/${default_branch}?hash=${hash}")
            map_set(${package_handles} "${package_uri}" ${ref})
          endif()
        endif()
      else()
        ## get all refs of the specified ref_type(s)
        bitbucket_remote_refs("${user}" "${repo}" "${ref_type}" "${ref}")
        ans(refs)

        foreach(ref ${refs})
          map_tryget(${ref} commit)
          ans(commit)
          map_tryget(${ref} ref_type)
          ans(ref_type)
          map_tryget(${ref} ref)
          ans(ref_name)

          map_set(${package_handles} "bitbucket:${user}/${repo}/${ref_type}/${ref_name}?hash=${commit}" ${ref})

        endforeach()

      endif()
    endif()
  else()
    error("you need to at least specify a bitbucket user")
    creturn()
  endif()


  ## create package handles if necessary

  map_keys(${package_handles})
  ans(keys)
  if(return_package_handle)
    set(map ${package_handles})
    set(package_handles)
    foreach(key ${keys})
      map_tryget(${map} ${key})
      ans(ref)
      set(package_handle)
      
      assign(!package_handle.uri = key)
      assign(!package_handle.query_uri = uri.uri)
      assign(!package_handle.bitbucket_descriptor.remote_ref = ref)
      list(APPEND package_handles ${package_handle})
    endforeach()

  else()
    set(package_handles ${keys})
  endif()
  return_ref(package_handles)
endfunction()


# File: source/package/package_source/bitbucket/package_source_resolve_bitbucket.cmake


  function(package_source_resolve_bitbucket uri)
    uri_coerce(uri)

    package_source_query_bitbucket("${uri}" --package-handle)
    ans(package_handle)

    list(LENGTH package_handle count)
    if(NOT "${count}" EQUAL 1)
      error("could not resolve {uri.uri} to a single package handle (got {count}) ")
      creturn()
    endif()

    assign(user = package_handle.bitbucket_descriptor.remote_ref.user)
    assign(repo = package_handle.bitbucket_descriptor.remote_ref.repo)
    assign(hash = package_handle.bitbucket_descriptor.remote_ref.commit)
    assign(ref = package_handle.bitbucket_descriptor.remote_ref.ref)
    assign(ref_type = package_handle.bitbucket_descriptor.remote_ref.ref_type)

    if(NOT hash)
      error("could not resolve {uri.uri} to a immutable package")
      creturn()
    endif()

    bitbucket_api("repositories/${user}/${repo}" --json --silent-fail)
    ans(repository)
    if(NOT repository)
      error("could not get information on the bitbucket repository" --aftereffect)
      creturn()
    endif()
    assign(package_handle.bitbucket_descriptor.repository = repository)


    bitbucket_read_file("${user}" "${repo}" "${hash}" "package.cmake")
    ans(package_descriptor_content)
    set(package_descriptor)
    if(package_descriptor_content)
      json_deserialize("${package_descriptor_content}")
      ans(package_descriptor)
    endif()


    set(default_version ${hash})
    if("${ref_type}" STREQUAL "tags")
      set(default_version "${ref}")
    endif()

    map_defaults("${package_descriptor}" "{
      id:$repository.full_name,
      version:$default_version,
      description:$repository.description,
      owner:$repository.owner.display_name
    }")
    ans(package_descriptor)


    map_set(${package_handle} package_descriptor ${package_descriptor})

    return_ref(package_handle)

    creturn()
    uri("${uri}")
    ans(uri)
    
    ## query for a valid and single  bitbucket uris 
    package_source_query_bitbucket("${uri}")
    ans(valid_uri_string)
    list(LENGTH valid_uri_string uri_count)
    if(NOT uri_count EQUAL 1)
      creturn()
    endif()

    ## get owner repo and ref
    uri("${valid_uri_string}")
    ans(valid_uri)

    map_tryget(${valid_uri} normalized_segments)
    ans(segments)

    list_extract(segments owner repo ref)


    ## get repo descriptor (return if not found)
    set(api_uri "https://api.bitbucket.org/2.0")
    set(request_uri "${api_uri}/repositories/${owner}/${repo}" )

    http_get("${request_uri}" "" --json)
    ans(repo_descriptor)

    if(NOT repo_descriptor)
      creturn()
    endif()

    ## if no ref is set query the bitbucket api for main branch
    if("${ref}_" STREQUAL "_")
      ## get the main branch
      set(main_branch_request_uri "https://api.bitbucket.org/1.0/repositories/${owner}/${repo}/main-branch")

      http_get("${main_branch_request_uri}" "" --json)
      ans(response)
      assign(main_branch = response.name)
      set(ref "${main_branch}")  
    endif()

    set(path package.cmake)

    ## try to get an existing package descriptor by downloading from the raw uri
    set(raw_uri "https://bitbucket.org/${owner}/${repo}/raw/${ref}/${path}")

    http_get("${raw_uri}" "" --json)
    ans(package_descriptor)

    ## setup package descriptor default value

    map_defaults("${package_descriptor}" "{
      id:$repo_descriptor.full_name, 
      version:'0.0.0',
      description:$repo_descriptor.description
    }")
    ans(package_descriptor)

    ## response
    map_new()
    ans(result)
    map_set(${result} package_descriptor "${package_descriptor}")
    map_set(${result} uri "${valid_uri_string}")
    map_set(${result} repo_descriptor "${repo_descriptor}")

    creturn(${result})
  endfunction()

# File: source/package/package_source/cached/cached_package_source.cmake

function(cached_package_source inner)
  set(args ${ARGN})
  list_pop_front(args)
  ans(cache_dir)

  if(NOT cache_dir)
    cmakepp_config(cache_dir)
    ans(cache_dir)
    set(cache_dir "${cache_dir}/package_cache")
  endif()

  path_qualify(cache_dir)

  set(this)
  assign(!this.cache_dir = cache_dir)
  assign(!this.inner = inner)

  assign(!this.indexed_store = indexed_store("${cache_dir}/store"))
  assign(index = this.indexed_store.index_add("package_handle.uri"))
  assign(index = this.indexed_store.index_add("package_handle.query_uri"))
  assign(index = this.indexed_store.index_add("package_handle.package_descriptor.id"))
  assign(this.indexed_store.key = "'[](container) ref_nav_get({{container}} package_handle.uri)'")


  assign(!this.clear_cache = 'package_source_cached_clear_cache')
  assign(!this.query = 'package_source_query_cached')
  assign(!this.resolve = 'package_source_resolve_cached')
  assign(!this.pull = 'package_source_pull_cached')

  return_ref(this)
endfunction()

function(package_source_cached_clear_cache)
  this_get(cache_dir)
  rm(-r "${cache_dir}")
endfunction()

# File: source/package/package_source/cached/package_source_pull_cached.cmake

function(package_source_pull_cached uri)
  set(args ${ARGN})
  list_extract_labelled_keyvalue(args --refresh)
  ans(refresh)

  uri_coerce(uri)

  list_pop_front(args)
  ans(target_dir)
  path_qualify(target_dir)


  package_source_resolve_cached("${uri}" ${refresh} --cache-container)
  ans(cache_container)

  if(NOT cache_container)
    creturn()
  else()
    assign(uri = cache_container.package_handle.uri)
    uri_coerce(uri)
  endif()


  this_get(cache_dir)
  map_tryget(${cache_container} cache_key)
  ans(cache_key)

  set(content_dir "${cache_dir}/content/${cache_key}")
  if(NOT EXISTS "${content_dir}")
    #message(FORMAT "PULL_MISS {uri.uri}")
    ## pull
    assign(package_handle = this.inner.pull("${uri}" "${content_dir}"))
    if(NOT package_handle)
      error("failed to pull {uri.uri} after cache miss")
      creturn()
    endif()
  else()
    #message(FORMAT "PULL_HIT {uri.uri}")
    assign(package_handle = cache_container.package_handle)
  endif()
  
  cp_dir("${content_dir}" "${target_dir}")
  assign(package_handle.content_dir = target_dir )

  return_ref(package_handle)
endfunction()

# File: source/package/package_source/cached/package_source_query_cached.cmake

function(package_source_query_cached uri)
  set(args ${ARGN})
  list_extract_flag(args --cache-container)
  ans(return_cache_container)
  list_extract_flag(args --package-handle)
  ans(return_package_handle)
  list_extract_flag(args --refresh)
  ans(refresh)
  uri_coerce(uri)

  ## find stored package handles
  set(cache_containers)
  if(NOT refresh)
    assign(query_string = uri.uri)
    assign(id_query = uri.params.id)
    assign(container_keys = this.indexed_store.find_keys(
      "package_handle.query_uri==${query_string}"
      "package_handle.uri==${query_string}"
      "package_handle.package_descriptor.id==${id_query}"
    ))
    foreach(container_key ${container_keys})
      assign(container = this.indexed_store.load("${container_key}"))
      map_set(${container} cache_key ${container_key})
      list(APPEND cache_containers ${container})
    endforeach()
  endif()

  ## if none were found query for them and save them
  if(NOT cache_containers)
    #message(FORMAT "QUERY_MISS {uri.uri}")
    assign(package_handles = this.inner.query("${uri}" --package-handle))
    foreach(package_handle ${package_handles})
      map_new()
      ans(container)
      map_set(${container} package_handle ${package_handle})
      assign(cache_key = this.indexed_store.save("${container}"))
      map_set(${container} cache_key ${cache_key})
      list(APPEND cache_containers ${container})
    endforeach()
  else()
    #message(FORMAT "QUERY_HIT {uri.uri}")

  endif()

  if(return_cache_container)
    return_ref(cache_containers)
  endif()

  list_select_property(cache_containers package_handle)
  ans(package_handles)

  if(return_package_handle)
    return_ref(package_handles)
  endif()

  list_select_property(package_handles uri)
  ans(package_uris)

  return_ref(package_uris)
endfunction()

# File: source/package/package_source/cached/package_source_resolve_cached.cmake

function(package_source_resolve_cached uri)
  set(args ${ARGN})
  list_extract_labelled_keyvalue(args --refresh)
  ans(refresh)
  list_extract_flag(args --cache-container)
  ans(return_cache_container)
  
  uri_coerce(uri)

  package_source_query_cached("${uri}" ${refresh} --cache-container)
  ans(cache_container)


  if("${cache_container}" MATCHES ";")  
    error("multiple matches found")
    creturn()
  endif()

  set(is_resolved false)

  if(cache_container)
    map_tryget(${cache_container} is_resolved)
    ans(is_resolved)
    assign(uri = cache_container.package_handle.uri)
    ans(uri)
    uri_coerce(uri)
  else()
    map_new()
    ans(cache_container)
  endif()

  if(NOT is_resolved)

    assign(package_handle = this.inner.resolve("${uri}"))
    if(NOT package_handle)
      error("cache package source: inner package source could not resolve {uri.uri}")
      creturn()
    endif()
    map_set(${cache_container} is_resolved true)
    map_set(${cache_container} package_handle ${package_handle})
    assign(success = this.indexed_store.save("${cache_container}"))
  else()
    #message(FORMAT "RESOLVE_HIT {uri.uri}")
  endif()

  if(return_cache_container)
    return_ref(cache_container)
  endif()


  map_tryget(${cache_container} package_handle)
  ans(package_handle)

  return_ref(package_handle)
endfunction()

# File: source/package/package_source/composite/composite_package_source.cmake


  function(composite_package_source source_name)
    set(sources ${ARGN})
    obj("{
      source_name:$source_name,
      query:'package_source_query_composite',
      resolve:'package_source_resolve_composite',
      pull:'package_source_pull_composite',
      add:'composite_package_source_add'
    }")
    ans(this)

    foreach(source ${sources})
      composite_package_source_add(${source})      
    endforeach()
    return_ref(this)
  endfunction()


# File: source/package/package_source/composite/composite_package_source_add.cmake

## adds a package soruce to the composite package soruce
function(composite_package_source_add source)
  map_tryget(${source} source_name)
  ans(source_name)

  if(NOT source_name)
    message(FATAL_ERROR "source_name needs to be set")
  endif()
  assign("!this.children.${source_name}" = source)
  creturn()
endfunction()

# File: source/package/package_source/composite/package_source_pull_composite.cmake

## package_source_pull_composite(<~uri?>) -> <package handle>
##
## pulls the specified package from the best matching child sources
## returns the corresponding handle on success else nothing is returned
parameter_definition(
  package_source_pull_composite 
  <uri{"the uri"}:<uri>> 
)
function(package_source_pull_composite)
  arguments_extract_defined_values(0 ${ARGC} package_source_pull_composite)
  ans(args)
    
  ## resolve package and return if none was found
  package_source_resolve_composite("${uri}")
  ans(package_handle)

  if(NOT package_handle)
    message("could not pull package '${uri}'")
    creturn()
  endif()

  ## get package source and uri from handle
  ## because current uri might not be fully qualified
  map_tryget(${package_handle} package_source_name)
  ans(package_source_name)

  if(NOT package_source_name)
    error("no package source name in package handle")
  endif()

  assign(package_source = "this.children.${package_source_name}")
  if(NOT package_source)
    error("unknown package source '${package_source_name}'")
  endif()

  map_tryget(${package_handle} query_uri)
  ans(package_uri)
  if(NOT package_uri)
    map_tryget(${package_handle} uri)
    ans(package_uri)
  endif()
  
  log("delegating pull to package source '${package_source_name}'")

  ## use the package package source to pull the correct package
  ## and return the result
  assign(package_handle = package_source.pull("${package_uri}" ${args}))

  log("done pulling '${package_uri}' from '${package_source_name}'")

  return_ref(package_handle)
endfunction()




# File: source/package/package_source/composite/package_source_query_composite.cmake

## package_source_query_composite(<~uri> [--package-handle]) -> <uri..>|<pacakage handle...>
##
## --package-handle  flag specifiec that not a uri but a <package handle> should be returned
##
## queries the child sources (this.children) for the specified uri
## this is done by first rating and sorting the sources depending on 
## the uri so the best source is queryied first
## if a source returns a rating of 999 all other sources are disregarded
function(package_source_query_composite uri)
  arguments_extract_defined_values(0 ${ARGC} package_source_query_composite)
  uri_coerce(uri)

  log("querying for '{uri.uri}'")


  set(args ${ARGN})

  list_contains(args --package-handle)
  ans(return_package_handle)

  

  ## rate and sort sources for uri    
  this_get(children)
  map_values(${children})
  ans(children)

  rated_package_source_sort("${uri}" ${children})
  ans(rated_children)


  ## loop through every source and query it for uri
  ## append results to result. 
  ## if the rating is 0 break because all following sources will
  ## also be 0 and this indicates that the source is incompatible 
  ## with the uri
  ## if the rating is 999 break after querying the source as this 
  ## source has indicated that it is solely responsible for this uri
  set(result)
  while(true)
    if(NOT rated_children)
      break()
    endif()

    list_pop_front(rated_children)
    ans(current)

    map_tryget(${current} rating)
    ans(rating)
    ## source and all rest sources are incompatible 
    if(rating EQUAL 0)
      break()
    endif()




    map_tryget(${current} source)
    ans(source)
    log("querying package source '{source.source_name}' (rating: {rating})")
    ## query the source
    ## args (especially --package-handle will be passed along)
    assign(current_result = source.query("${uri}" ${args}))
    if(return_package_handle)
      foreach(handle ${current_result})
        map_tryget(${source} source_name)
        ans(source_name) 
        map_set(${handle} package_source_name ${source_name})
      endforeach()
    endif()
    ## append to result
    list(APPEND result ${current_result})
    ## source has indicated it is solely responsible for uri
    ## all further sources are disregarded
    if(NOT rating LESS  999)
      break()
    endif()
  endwhile()
  return_ref(result)
endfunction()



# File: source/package/package_source/composite/package_source_rate_uri.cmake

## function used to rate a package source and a a uri
## default rating is 1 
## if a scheme of uri matches the source_name property
## of a package source the rating is 999
## else package_source's rate_uri function is called
## if it exists which can return a custom rating
function(package_source_rate_uri package_source uri)
  uri("${uri}")
  ans(uri)

  set(rating 1)

  map_tryget(${uri} schemes)
  ans(schemes)
  map_tryget(${package_source} source_name)
  ans(source_name)

  ## contains scheme -> rating 999
  list_contains(schemes "${source_name}")
  ans(contains_scheme)

  if(contains_scheme)
    set(rating 999)
  endif()

  ## package source may override default behaviour
  map_tryget(${package_source} rate_uri)
  ans(rate_uri)
  if(rate_uri)
    call(source.rate_uri(${uri}))
    ans(rating)
  endif()

  return_ref(rating)
endfunction()

# File: source/package/package_source/composite/package_source_resolve_composite.cmake

## package_source_resolve_composite(<~uri>) -> <package handle>
## returns the package handle for the speciified uri
## the handle's package_source property will point to the package source used
parameter_definition(package_source_resolve_composite
  <uri{"the query uri"}:<uri>> 
  )
function(package_source_resolve_composite)
  arguments_extract_defined_values(0 ${ARGC} package_source_resolve_composite)
  ans(args)  
  

  #message(FORMAT "package_source_resolve_composite: {uri.uri}")
  uri_coerce(uri)

  ## query composite returns the best matching package_uris first
  ## specifiying --package-handle returns the package handle as 
  ## containing the package_uri and the package_source
  package_source_query_composite("${uri}" --package-handle)
  ans(package_handles)

  ## loops through every package handle and tries to resolve
  ## it. returns the handle on the first success
  while(true)

    if(NOT package_handles)
      creturn()
    endif()

    list_pop_front(package_handles)
    ans(package_handle)
    
    map_tryget(${package_handle} package_source_name)
    ans(package_source_name)

    assign(package_source = "this.children.${package_source_name}")
    
    if(NOT package_source)
      message(FATAL_ERROR "package handle missing package_source property")
    endif()
    #map_tryget(${package_handle} uri)
    #ans(uri)  removed so that the original uri can stay same
    # and because of the small time daly between query and resolve
    # the uri will be stable enough

    assign(package_handle = package_source.resolve("${uri}"))

    if(package_handle)        
      ## copy over package source to new package handle
      assign(package_handle.package_source_name = package_source_name)
     # assign(package_handle.rating = source_uri.rating)
      return_ref(package_handle)
    endif()

  endwhile()
  creturn()
endfunction() 



# File: source/package/package_source/composite/rated_package_source_compare.cmake


  ## compares two rated package sources and returns a number
  ## pointing to the lower side
  function(rated_package_source_compare lhs rhs)
      map_tryget(${rhs} rating)
      ans(rhs)
      map_tryget(${lhs} rating)
      ans(lhs)
      math(EXPR result "${lhs} - ${rhs}")
      return_ref(result)
  endfunction()

# File: source/package/package_source/composite/rated_package_source_sort.cmake


  ## sorts the rated package sources by rating
  ## and returns them
  function(rated_package_source_sort uri)
    rated_package_sources(${ARGN})
    ans(rated_sources)


    list_sort(rated_sources rated_package_source_compare)
    ans(rated_sources)
    return_ref(rated_sources)
  endfunction()


# File: source/package/package_source/composite/rated_package_sources.cmake


  ## creates rated package sources from the specified sources
  ## { rating:<number>, source:<package source>}
  function(rated_package_sources)
    set(result)
    foreach(source ${ARGN})
      map_new() 
      ans(map)
      map_set(${map} source ${source})
      package_source_rate_uri(${source} ${uri})
      ans(rating)
      map_set(${map} rating ${rating}) 
      list(APPEND result ${map})
    endforeach()
    return_ref(result)
  endfunction()


# File: source/package/package_source/default/default_package_source.cmake



function(default_package_source)
  map_tryget(global default_package_source)
  ans(result)
  if(NOT result)
    set(sources)

    path_package_source()
    ans_append(sources)
    
    archive_package_source()
    ans_append(sources)

    webarchive_package_source()
    ans_append(sources)

    host_package_source()
    ans_append(sources)

    find_package(Git)
    find_package(Hg)
    find_package(Subversion)

    if(GIT_FOUND)
      github_package_source()
      ans_append(sources)
    endif()    

    if(GIT_FOUND AND HG_FOUND)
      bitbucket_package_source()
      ans_append(sources)
    endif()
    
    if(GIT_FOUND)
      git_package_source()
      ans_append(sources)
    endif()

    if(HG_FOUND)
      hg_package_source()
      ans_append(sources)
    endif()

    if(SUBVERSION_FOUND)
      svn_package_source()
      ans_append(sources)
    endif()

    composite_package_source("" ${sources})
    ans(inner)

    set(default_package_source ${inner})
#    cached_package_source("${inner}")
 #   ans(default_package_source)

    map_set(global default_package_source ${default_package_source})
  endif()
  function(default_package_source)
    map_get(global default_package_source)
    return_ans()
  endfunction()
  return_ans()  
endfunction()


# File: source/package/package_source/default/default_package_source_set.cmake

## sets the default package source
function(default_package_source_set source)
  package_source(${source} ${ARGN})
  ans(source)
  if(NOT source)
    message(FATAL_ERROR "invalid package source")
  endif()
  map_set(global default_package_source "${source}")
endfunction()

# File: source/package/package_source/default/pull_package.cmake

## pull_package(<~uri> <?target dir>|[--reference]) -> <package handle>
##
## --reference flag causes pull to return an existing content_dir in package handle if possible
##             <null> is returned if pulling a reference is not possbile
##
## <target dir> the <unqualified path< were the package is to be pulled to
##              the default is the current directory
##
##  pull the specified package to the target location. the package handle contains
##  meta information about the package like the package uri, package_descriptor, content_dir ...
function(pull_package)
  default_package_source()
  ans(source)
  call(source.pull(${ARGN}))
  return_ans()
endfunction()


# File: source/package/package_source/default/query_package.cmake

## query_package(<~uri> [--package-handle]) -> <uri string>|<package handle>
## queries the default package source for a package
function(query_package)
  default_package_source()
  ans(source)
  call(source.query(${ARGN}))
  return_ans()
endfunction()


# File: source/package/package_source/default/resolve_package.cmake

## resolve_package(<~uri>) -> <package handle>
## 
function(resolve_package)
  default_package_source()
  ans(source)
  call(source.resolve(${ARGN}))
  return_ans()
endfunction()



# File: source/package/package_source/directory/directory_package_source.cmake


  function(directory_package_source source_name directory)
    path_qualify(directory)
    obj("{
      source_name:$source_name,
      directory:$directory,
      pull:'package_source_pull_directory',
      query:'package_source_query_directory',
      resolve:'package_source_resolve_directory'
    }")
    return_ans()
  endfunction()


# File: source/package/package_source/directory/package_source_pull_directory.cmake

  ## package_source_pull_directory(<~uri> [--reference]) -> <package handle>
  ## --reference flag 
  function(package_source_pull_directory uri)
    set(args ${ARGN})

    package_source_resolve_directory("${uri}")
    ans(package_handle)

    if(NOT package_handle)
      creturn()
    endif()

    list_extract_flag(args --reference)
    ans(reference)

    if(NOT reference)
      list_pop_front(args)
      ans(target_dir)
      path_qualify(target_dir)
    
      map_tryget(${package_handle} content_dir)
      ans(source_dir)

      cp_dir("${source_dir}" "${target_dir}")
      map_set(${package_handle} content_dir "${target_dir}")  
    endif()
    
    return_ref(package_handle)
  endfunction()


# File: source/package/package_source/directory/package_source_query_directory.cmake

  ## package_source_query_directory(<~uri>) -> <uri string>
  function(package_source_query_directory uri)
    set(args ${ARGN})

    list_extract_flag(args --package-handle)
    ans(return_package_handle)

    this_get(directory)
    this_get(source_name)

    uri_coerce(uri)

    ## return if scheme is either empty or equal to source_name       
    assign(scheme = uri.scheme)

    uri_check_scheme("${uri}" "${source_name}?")
    ans(scheme_ok)
    if(NOT scheme_ok)
      error("expected either ${source_name} or nothing as scheme. {uri.uri}")
      creturn()
    endif() 

    map_tryget(${uri} segments)
    ans(segments)
    list(LENGTH segments segment_length)

    ## if uri has a single segment it is interpreted as a hash
    if(segment_length EQUAL 1 AND IS_DIRECTORY "${directory}/${segments}")
      set(result "${source_name}:${segments}")
    elseif(NOT segment_length EQUAL 0)
      ## multiple segments are not allowed and are a invliad uri
      set(result)
    else()
      ## else parse uri's query (uri starts with ?)

      map_tryget(${uri} query)
      ans(query)
      if("${query}" MATCHES "=")
        ## if query contains an equals it is a map
        ## else it is a value
        map_tryget(${uri} params)
        ans(query)        
      endif()

      ## empty query returns nothing
      if(query STREQUAL "")
        creturn()
      endif()

      ## read all package indices
      file(GLOB folders RELATIVE "${directory}" "${directory}/*")

      is_map("${query}")
      ans(ismap)
    
      ## query may be a * which returns all packages 
      ## or a regex /[regex]/
      ## or a map which will uses the properties to match values
      if(query STREQUAL "*")
        set(result)
        foreach(folder ${folders})
          list(APPEND result "${source_name}:${folder}")
        endforeach()
      elseif("${query}" MATCHES "^/(.*)/$")
        ## todo
        set(result)
      elseif(ismap)
        ## todo
        set(result)
      endif()
    endif()

    if(return_package_handle)
      set(package_handles)
      foreach(item ${result})
        set(package_handle)
        assign(!package_handle.uri = item)
        assign(!package_handle.query_uri = uri.uri)
        list(APPEND package_handles ${package_handle})
      endforeach()
      set(result ${package_handles})
    endif()

    return_ref(result)

  endfunction()



# File: source/package/package_source/directory/package_source_resolve_directory.cmake

## package_source_resolve_directory(<~uri>) -> <package handle>
  function(package_source_resolve_directory uri)
    uri("${uri}")
    ans(uri)

    package_source_query_directory("${uri}")
    ans(valid_uri_string)

    list(LENGTH valid_uri_string count)
    if(NOT count EQUAL 1)
      creturn()
    endif()

    ## if uri contains query return
    map_tryget(${uri} query)
    ans(query)
    if(NOT "${query}_" STREQUAL "_")
      creturn()
    endif()

    this_get(directory)

    ## parse uri
    uri("${valid_uri_string}")
    ans(uri)

    map_tryget(${uri} scheme_specific_part)
    ans(subdir)

    set(content_dir "${directory}/${subdir}")

    package_handle("${content_dir}")
    ans(package_handle)

    map_tryget("${package_handle}" package_descriptor)
    ans(package_descriptor)

    map_defaults("${package_descriptor}" "{
      id:$subdir,
      version:'0.0.0'
    }")
    ans(package_descriptor)

    ## response
    map_new()
    ans(package_handle)
    map_set(${package_handle} package_descriptor "${package_descriptor}")
    map_set(${package_handle} uri "${valid_uri_string}")
    map_set(${package_handle} content_dir "${content_dir}")

    return_ref(package_handle)
  endfunction()


# File: source/package/package_source/git/git_package_source.cmake



  function(git_package_source)
    obj("{
      source_name:'gitscm',
      pull:'package_source_pull_git',
      query:'package_source_query_git',
      resolve:'package_source_resolve_git'
    }")
    return_ans()
  endfunction()


# File: source/package/package_source/git/package_source_pull_git.cmake

## package_source_pull_git(<~uri> <path?>) -> <package handle>
##
## pulls the package described by the uri  into the target_dir
## e.g.  package_source_pull_git("https://github.com/toeb/cutil.git?ref=devel")
  function(package_source_pull_git uri)
    set(args ${ARGN})

    list_pop_front(args)
    ans(target_dir)

    path_qualify(target_dir)

    log("package_source_pull_git: pulling '${uri}' to '${target_dir}'...")

    package_source_resolve_git("${uri}")
    ans(package_handle)

    if(NOT package_handle)
        error("package_source_pulll_git: could not resolve package '${uri}'")
        creturn()
    endif()

    log("package_source_pull_git: resolved {package_handle.package_descriptor.id}@{package_handle.package_descriptor.version} from '${uri}'")

    assign(remote_uri = package_handle.scm_descriptor.ref.uri)
    assign(revision = package_handle.scm_descriptor.ref.revision)

    git_cached_clone("${remote_uri}" "${target_dir}" --ref "${revision}" ${args})
    ans(target_dir)

    map_set(${package_handle} content_dir "${target_dir}")

    return_ref(package_handle)
  endfunction()   



# File: source/package/package_source/git/package_source_query_git.cmake


parameter_definition(
  package_source_query_git 
  <uri{"the query uri of a git package"}:<uri>> 
  [--package-handle{"if set, return a package handle instead of <unique_uri>"}=>return_package_handle]
  "#returns a list of valid `<package uri>`s. You can specify a query for ref/branch/tag by adding `?ref=*`, `?ref=name`, `?ref=<hash>`. Only when using `?ref=*` are multiple `<package uri>`s returned."
)
function(package_source_query_git)
  arguments_extract_defined_values(0 ${ARGC} package_source_query_git)
  ans(args)

  uri_coerce(uri)

  log("git_package_source: querying for {uri.uri}" --trace)


  uri_qualify_local_path("${uri}")
  ans(uri)

  uri_format("${uri}" --no-query)
  ans(remote_uri)

  ## check if remote exists
  git_remote_exists("${remote_uri}")
  ans(remote_exists)


  ## remote does not exist
  if(NOT remote_exists)
    log("git_package_source: remote '{remote_uri}' does not exist")
    creturn()
  endif()

  ## get ref and check if it exists
  assign(ref = uri.params.ref)
  assign(branch = uri.params.branch)  
  assign(tag = uri.params.tag)
  assign(rev = uri.params.rev)

  ## todo: check if unused params are passed
  ## which should result in a warning


  set(ref ${ref} ${branch} ${tag})
  list_pop_front(ref)
  ans(ref)

  set(remote_refs)
  if(NOT "${rev}_" STREQUAL "_")
    ## todo validate rev furhter??
    if(NOT "${rev}" MATCHES "^[a-fA-F0-9]+$")
       error("git_package_source: invalid revision for {uri.uri}: '{rev}'")
      creturn()
    endif()

    obj("{
      revision:$rev,
      type:'rev',
      name:$rev,
      uri:$remote_uri  
    }")

    ans(remote_refs)
  elseif("${ref}_" STREQUAL "*_")
    ## get all remote refs and format a uri for every found tag/branch
    git_remote_refs("${remote_uri}")
    ans(refs)

    foreach(ref ${refs})
      map_tryget(${ref} type)
      ans(ref_type)
      if("${ref_type}" MATCHES "(tags|heads)")
        list(APPEND remote_refs ${ref})
      endif()
    endforeach()
  elseif(NOT "${ref}_" STREQUAL "_")
    ## ensure that the specified ref exists and return a valid uri if it does
    git_remote_ref("${remote_uri}" "${ref}" "*")
    ans(remote_refs)
  else()

    git_remote_ref("${remote_uri}" "HEAD" "*")
    ans(remote_refs)
  endif()


  ## generate result from the scm descriptors
  set(results)
  foreach(remote_ref ${remote_refs})
    git_scm_descriptor("${remote_ref}")
    ans(scm_descriptor)
    assign(rev = scm_descriptor.ref.revision)
    set(result "${remote_uri}?rev=${rev}")
    log("git_package_source: query '{uri.uri}' found '{result}'" --trace)
    if(return_package_handle)
      set(package_handle)
      assign(!package_handle.uri = result)
      assign(!package_handle.scm_descriptor = scm_descriptor)
      assign(!package_handle.query_uri = uri.uri)
      set(result ${package_handle})
    endif()
    list(APPEND results ${result})
  endforeach()


  
  return_ref(results)
endfunction()

# File: source/package/package_source/git/package_source_resolve_git.cmake

## returns a pacakge descriptor for the specified git uri 
## takes long for valid uris because the whole repo needs to be checked out
parameter_definition(
  package_source_resolve_git 
  <uri{"the query uri of a git package"}:<uri>> 
)
function(package_source_resolve_git)
  arguments_extract_defined_values(0 ${ARGC} package_source_resolve_git)
  ans(args) 
  
  log("package_source_resolve_git: resolving '{uri.uri}'...")

  package_source_query_git("${uri}" --package-handle)
  ans(package_handle)

  list(LENGTH package_handle count)
  
  if(NOT "${count}" EQUAL 1)
    error("could not get a unqiue uri for '{uri.uri}' (got {count})")
    creturn()
  endif()

  assign(remote_uri = package_handle.scm_descriptor.ref.uri)
  assign(rev = package_handle.scm_descriptor.ref.revision)
  assign(type = package_handle.scm_descriptor.ref.type)
  assign(default_version = package_handle.scm_descriptor.ref.name)
  ## tries to extract version from tag information by parsing the tag name
  if("${type}" STREQUAL "tags")
    semvers_extract("${default_version}")
    ans_extract(semver)
    if(semver)
      assign(default_version = semver.string)
    else()
      set(default_version "0.0.0")
    endif()
  else()
    set(default_version "0.0.0")
  endif()

  ## uses the uri filename as the default package name
  map_tryget(${uri} file_name)
  ans(default_id)

  ##  try to get package descriptor
  git_cached_clone("${remote_uri}" --ref ${rev} --read package.cmake)
  ans(package_descriptor_content)

  json_deserialize("${package_descriptor_content}")
  ans(package_descriptor)
  


  map_defaults("${package_descriptor}" "{
    id:$default_id,
    version:$default_version
  }")
  ans(package_descriptor)

  map_set(${package_handle} package_descriptor ${package_descriptor})

  log("package_source_resolve_git: successfully resolved {package_descriptor.id}@{package_descriptor.version}")

  return_ref(package_handle)
endfunction()

# File: source/package/package_source/github/github_package_source.cmake


  function(github_package_source)
    obj("{
      source_name:'github',
      pull:'package_source_pull_github',
      query:'package_source_query_github',
      resolve:'package_source_resolve_github'
    }")
    return_ans()
  endfunction()



# File: source/package/package_source/github/package_source_pull_github.cmake

## package_source_pull_github(<~uri> <?target_dir>) -> <package handle>
function(package_source_pull_github uri)
  set(args ${ARGN})
  uri_coerce(uri)
  log("pulling {uri.uri}" --trace --function package_source_pull_github)  

  ## get package descriptor 
  package_source_resolve_github("${uri}")
  ans(package_handle)
  if(NOT package_handle)
    creturn()
  endif()

  ## get path
  list_pop_front(args)
  ans(target_dir)
  path_qualify(target_dir)

  ## retreive the hidden/special repo_descriptor
  ## to gain access to the clone url
  map_tryget(${package_handle} github_descriptor)
  ans(repo_descriptor)

  map_tryget(${package_handle} package_descriptor)
  ans(package_descriptor)

  ## alternatives git_url/clone_url
  map_tryget(${repo_descriptor} clone_url)
  ans(clone_url)

  package_source_pull_git("${clone_url}" "${target_dir}")
  ans(scm_package_handle)

  if(NOT scm_package_handle)
    creturn()
  endif()

  map_tryget("${scm_package_handle}" package_descriptor)
  ans(scm_package_descriptor)

  assign(package_handle.repo_descriptor = scm_package_handle.repo_descriptor)

  map_defaults("${package_descriptor}" "${scm_package_descriptor}")

  map_tryget("${scm_package_handle}" content_dir)
  ans(scm_content_dir)

  map_set("${package_handle}" content_dir "${scm_content_dir}")

  return_ref(package_handle)

endfunction()

# File: source/package/package_source/github/package_source_query_github.cmake

## package_source_query_github([--package-handle])->
##
##
## "" => null 
## <github user> => <github user>/*
## <github user>/* => repo list
## <github user>/<repository> => <github user>/<repository>/branches/<default branch>?hash=<commit sha>
## <github user>/<repository>/* => <github user>/<repository>/(branches|tags)/<name>?hash=<commit sha> ...
## <github user>/<repository>/<ref name> => <github user>/<repository>/branches/<ref name>?hash=<commit sha>
## <github user>/<repository>/<ref type>/* => <github user>/<repository>/<ref type>/<ref name>?hash=<commit sha>
## <github user>/<repository>/<ref type>/<ref => <github user>/<repository>/<ref type>/<ref name>?hash=<commit sha>
function(package_source_query_github uri)
  set(args ${ARGN})


  list_extract_flag(args --package-handle)
  ans(return_package_handle)


  ## parse uri and extract the two first segments 
  uri_coerce(uri)

  log("querying for '{uri.uri}'" --trace --function package_source_query_github)


  assign(scheme = uri.scheme)
  uri_check_scheme("${uri}" "github?")
  ans(scheme_ok)
  if(NOT scheme_ok)
    log("invalid schmeme: '{uri.scheme}'" --trace --function package_source_query_github)
    creturn()
  endif()


  assign(segments = uri.normalized_segments)
  list_extract(segments user repo ref_type ref)
  
  set(repo_query)
  if("${repo}_" STREQUAL "*_")
    set(repo)
    set(repo_query *)
  endif()

  assign(hash = uri.params.hash)
  set(package_handles)

  if(hash)
    github_remote_refs("${user}" "${repo}" commits "${hash}")
    ans(res)
    format("github:${user}/${repo}?hash=${hash}")
    ans(package_handles)
  elseif(user AND repo AND ref_type)
    if(NOT "${ref_type}" MATCHES "\\*|branches|tags" )
      set(ref_query ${ref_type})
      set(ref_type *)
    else()
      set(ref_query "*")
    endif()

    github_remote_refs("${user}" "${repo}" "${ref_type}" "${ref_query}")
    ans(refs)
    foreach(current_ref ${refs})
      format("github:${user}/${repo}/{current_ref.ref_type}/{current_ref.ref}?hash={current_ref.commit}")
      ans_append(package_handles)
    endforeach()
  elseif(user AND repo)
    github_repository("${user}" "${repo}")
    ans(repository)
    assign(default_branch = repository.default_branch)
    github_remote_refs("${user}" "${repo}" "branches" "${default_branch}")
    ans(remote_ref)
    if(remote_ref)
      format("github:{repository.full_name}/branches/{repository.default_branch}?hash={remote_ref.commit}")
      ans(package_handles)
    endif()
    
  elseif(user)
    ## only  user results in non unique ids which have to be quried again
    github_repository_list("${user}")
    ans(repositories)
    set(package_handles)
    foreach(repo ${repositories})
      map_tryget(${repo} full_name)
      ans(repo_name)
      list(APPEND package_handles "github:${repo_name}")
    endforeach()
  else()
    ## no user (not queried) too many results
  endif()
  list(LENGTH package_handles count) 
  log("'{uri.uri}' resulted in {count} dependable uris" --trace --function package_source_query_github)

  if(return_package_handle)
    set(uris ${package_handles})
    set(package_handles)
    foreach(github_url ${uris})
      set(package_handle)
      assign(!package_handle.uri = github_url)
      assign(!package_handle.query_uri = uri.uri)
      list(APPEND package_handles ${package_handle})
    endforeach()
    return_ref(package_handles)
  endif()

    return_ref(package_handles)

endfunction()



# File: source/package/package_source/github/package_source_resolve_github.cmake



  ## package_source_resolve_github() -> <package handle> {}
  ##
  ## resolves the specifie package uri 
  ## and if uniquely identifies a package 
  ## returns its pacakge descriptor
  function(package_source_resolve_github uri)
    uri_coerce(uri)

    log("querying for '{uri.uri}'" --trace --function package_source_resolve_github)


    package_source_query_github("${uri}" --package-handle)
    ans(package_handle)

    list(LENGTH package_handle count)
    if(NOT "${count}" EQUAL 1)
        error("could not resolve '{uri.uri}' to a unique package (got {count})" --function package_source_resolve_github)
        creturn()
    endif() 

    assign(package_uri = package_handle.uri)
    uri("${package_uri}")
    ans(package_uri)
    assign(hash = package_uri.params.hash)
    if(NOT hash)
        error("package uri is not unique. requires a hash param: '{uri.uri}'" --function package_source_resolve_github)
        creturn()
    endif()

    assign(user = package_uri.normalized_segments[0])
    assign(repo = package_uri.normalized_segments[1])
    assign(ref_type = package_uri.normalized_segments[2])
    assign(ref_name = package_uri.normalized_segments[3])


    ## get the repository descriptor
    github_api("repos/${user}/${repo}" --json)
    ans(repo_descriptor)
    if(NOT repo_descriptor)
        error("could not resolve repository descriptor" --function package_source_resolve_github)
        creturn()
    endif()



    ## try to get the package descriptor remotely
    github_get_file("${user}" "${repo}" "${hash}" "package.cmake" --silent-fail)
    ans(content)
    json_deserialize("${content}")
    ans(package_descriptor)


    ## map default values on the packge descriptor 
    ## using the information from repo_descriptor
    assign(default_description = repo_descriptor.description)

    map_defaults("${package_descriptor}" "{
      id:$repo,
      version:'0.0.0',
      description:$default_description
    }")
    ans(package_descriptor)
    


    ## response
    map_set(${package_handle} package_descriptor "${package_descriptor}")
    map_set(${package_handle} github_descriptor "${repo_descriptor}")

    log("resolved package handle for '{package_handle.query_uri}': '{package_handle.uri}'" --trace --function package_source_resolve_github)

    return_ref(package_handle)
  endfunction()

# File: source/package/package_source/hg/hg_package_source.cmake


  function(hg_package_source)
    obj("{
      source_name:'hgscm',
      pull:'package_source_pull_hg',
      query:'package_source_query_hg',
      resolve:'package_source_resolve_hg'
    }")
    return_ans()
  endfunction()



# File: source/package/package_source/hg/package_source_pull_hg.cmake

## package_source_pull_hg
##
## 
  function(package_source_pull_hg uri)
    set(args ${ARGN})

    uri("${uri}")
    ans(uri)


    list_pop_front(args)
    ans(target_dir)

    path_qualify(target_dir)
    
    package_source_resolve_hg("${uri}")
    ans(package_handle)



    if(NOT package_handle)
        creturn()
    endif()



    assign(remote_uri = package_handle.scm_descriptor.ref.uri)
    assign(hash = package_handle.scm_descriptor.ref.hash)

    hg_cached_clone("${remote_uri}" --ref "${hash}" "${target_dir}")
    ans(target_dir)

    map_set(${package_handle} content_dir "${target_dir}")


    return_ref(package_handle)
  endfunction()

# File: source/package/package_source/hg/package_source_query_hg.cmake

## package_source_query_hg(<~uri>) -> <uri>|<package handle>

  function(package_source_query_hg uri)
    set(args ${ARGN})
    list_extract_flag(args --package-handle)
    ans(return_package_handle)

    uri("${uri}")
    ans(uri)

    uri_qualify_local_path("${uri}")
    ans(uri)

   # uri_format("${uri}" --no-query --remove-scheme hgscm)
    uri_format("${uri}" --no-query)
    ans(remote_uri)

    ## check if remote exists
    hg_remote_exists("${remote_uri}")
    ans(remote_exists)
    if(NOT remote_exists)
      creturn()
    endif()

    ## get ref 
    assign(rev = uri.params.rev)
    assign(ref = uri.params.ref)
    assign(branch = uri.params.branch)
    assign(tag = uri.params.tag)
    set(ref ${ref} ${branch} ${tag})
    list_pop_front(ref)
    ans(ref)

    hg_cached_clone("${remote_uri}" --readonly)
    ans(repo_dir)


    if(NOT ref AND NOT rev)
      set(ref "tip")
    endif()

    pushd("${repo_dir}")
    set(refs)
    if("${rev}" MATCHES "[0-9A-Fa-f]+" )
      map_new()
      ans(refs)
      map_set(${refs} inactive false)
      map_set(${refs} name ${rev})
      map_set(${refs} number 0)
      map_set(${refs} hash ${rev})
      map_set(${refs} type "rev")
    elseif(NOT "${ref}_" STREQUAL "_")
      hg_get_refs()
      ans(refs)
      if(NOT "${ref}" STREQUAL "*")
        set(selected_refs)
        foreach(current_ref ${refs})
          map_tryget(${current_ref} name)
          ans(name)
          if("${name}" STREQUAL "${ref}")
            list(APPEND selected_refs ${current_ref})
          endif()
        endforeach()
        set(refs ${selected_refs})
      endif()
    endif()

    popd()    

    set(result)
    foreach(ref ${refs})
      map_tryget(${ref} hash)
      ans(hash)
      set(immutable_uri "${remote_uri}?rev=${hash}")
      if(return_package_handle)
        set(package_handle)
        assign(!package_handle.uri = immutable_uri)
        assign(!package_handle.scm_descriptor.scm = 'hg')
        assign(!ref.uri = remote_uri)
        assign(!package_handle.scm_descriptor.ref =  ref)
        assign(!package_handle.query_uri = uri.uri)

        list(APPEND result ${package_handle})
      else()
        list(APPEND result ${immutable_uri})
      endif()

    endforeach()
    return_ref(result)
  endfunction() 

# File: source/package/package_source/hg/package_source_resolve_hg.cmake

## package_source_resolve_hg
##
## resolves a uri package to a immutable unqiue uri 
##
  function(package_source_resolve_hg uri)
    set(args ${ARGN})
    uri("${uri}")
    ans(uri)

    package_source_query_hg("${uri}" --package-handle)
    ans(package_handle)

    list(LENGTH package_handle count)
    if(NOT "${count}" EQUAL 1)
      error("could not uniquely resolve {uri.uri}" uri package_handle)
      creturn()
    endif()


    assign(remote_uri = package_handle.scm_descriptor.ref.uri)
    assign(hash = package_handle.scm_descriptor.ref.hash)


    hg_cached_clone("${remote_uri}" --ref "${hash}" --read package.cmake)
    ans(package_descriptor_content)

    json_deserialize("${package_descriptor_content}")
    ans(package_descriptor)

    assign(default_id = uri.file_name)
    map_defaults("${package_descriptor}" "{
      id:$default_id,
      version:'0.0.0'
    }")
    ans(package_descriptor)
    map_set(${package_handle} package_descriptor "${package_descriptor}")

    return_ref(package_handle)

  endfunction()


# File: source/package/package_source/host/host_package_source.cmake

## `()-> <package source>`
##
## creates a host package source which provides information
## on the host system
function(host_package_source)
  map_new()
  ans(this)
  map_set(${this} source_name "host")
  map_set(${this} query package_source_query_host)
  map_set(${this} resolve package_source_resolve_host)
  map_set(${this} pull package_source_pull_host)
  map_set(${this} rate_uri package_source_rate_uri_host)
  creturn(${this})
endfunction()



# File: source/package/package_source/host/package_source_pull_host.cmake

## `(<uri> [<target dir>])-> <package handle>`
##
## pulls the specified host package into the target_dir
## this functions currently just creates a directory with nothing in it
function(package_source_pull_host uri)
  set(args ${ARGN})
  uri_coerce(uri)
  package_source_resolve_host("${uri}")
  ans(package_handle)

  list_pop_front(args)
  ans(target_dir)
  if(NOT package_handle)
    creturn()
  endif()

  path_qualify(target_dir)

  mkdir("${target_dir}")

  assign(package_handle.content_dir = target_dir)

  return_ref(package_handle)
endfunction()

# File: source/package/package_source/host/package_source_query_host.cmake


  function(package_source_query_host uri)
    set(args ${ARGN})

    list_extract_flag(args --package-handle)
    ans(return_package_handle)

    uri_coerce(uri)

    ## uri needs to have the host scheme
    uri_check_scheme("${uri}" host)
    ans(ok)

    map_tryget(${uri} scheme_specific_part)
    ans(hostname)

    if(NOT ok)
      creturn()
    endif()

    if(hostname AND NOT "${hostname}" STREQUAL "localhost")
      creturn()
    endif()


    cmake_environment()
    ans(environment)

    set(result "host:localhost")
    if(return_package_handle)
      set(package_handle)
      assign(!package_handle.uri = result)
      assign(!package_handle.query_uri = uri.uri)
      assign(!package_handle.environment_descriptor = environment)
      set(result "${package_handle}")
    endif()

    return_ref(result)
  endfunction()


# File: source/package/package_source/host/package_source_rate_uri.cmake


  function(package_source_rate_uri_host uri)
    uri_coerce(uri)
    uri_check_scheme("${uri}" host)
    ans(ok)
    if(NOT ok)
      creturn(0)
    endif()
    creturn(999)
  endfunction()


# File: source/package/package_source/host/package_source_resolve_host.cmake

## `(<uri>)-><package handle>`
## 
## tries to find the package identified by the uri 
function(package_source_resolve_host uri)
  uri_coerce(uri)
  package_source_query_host("${uri}" --package-handle)
  ans(package_handle)


  list(LENGTH package_handle count)

  if(NOT "${count}" EQUAL 1)
    error("could not unqiuely resolve {uri.uri} to a single package uri (got {count})")
    creturn()
  endif()

  map_tryget(${package_handle} environment_descriptor)
  ans(environment_descriptor)

  map_new()
  ans(package_descriptor)

  map_set(${package_descriptor} environment_descriptor ${environment_descriptor})
  map_set(${package_handle} package_descriptor ${package_descriptor})


  return_ref(package_handle)
endfunction()

# File: source/package/package_source/managed/managed_package_source.cmake


function(managed_package_source source_name directory)
  path_qualify(directory)
  obj("{
    source_name:$source_name,
    directory:$directory,
    pull:'package_source_pull_managed',
    push:'package_source_push_managed',
    query:'package_source_query_managed',
    resolve:'package_source_resolve_managed',
    delete:'package_source_delete_managed'
  }")
  return_ans()
endfunction()




# File: source/package/package_source/managed/package_handle_hash.cmake

  ## package_handle_hash(<~package handle>) -> <string>
  ## creates a hash for an installed package the hash should be unique enough and readable enough
  function(package_handle_hash package_handle)
    package_handle("${package_handle}")
    ans(package_handle)

    assign(id = package_handle.package_descriptor.id)
    assign(version = package_handle.package_descriptor.version)

    set(hash "${id}_${version}")
    string(REPLACE "." "_" hash "${hash}")
    string(REPLACE "/" "_" hash "${hash}")
    return_ref(hash)
  endfunction()


# File: source/package/package_source/managed/package_source_delete_managed.cmake

function(package_source_delete_managed uri)
  uri_coerce(uri)

  package_source_resolve_managed("${uri}")
  ans(package_handle)


  if(NOT package_handle)
    creturn(false)
  endif()

  assign(location = package_handle.managed_descriptor.managed_dir)
  if(NOT EXISTS "${location}")
    message(FATAL_ERROR "the package is known but its directory does not exist")
  endif()

  rm(-r "${location}")

  creturn(true)
endfunction()

# File: source/package/package_source/managed/package_source_pull_managed.cmake


  ## package_source_pull_managed(<~uri>) -> <package handle>
  ## --reference returns the package with the content still pointing to the original content dir
  function(package_source_pull_managed uri)
    set(args ${ARGN})

    uri_coerce(uri)

    package_source_resolve_managed("${uri}")
    ans(package_handle)
    if(NOT package_handle)
      creturn()
    endif()

    list_extract_flag(args --reference)
    ans(reference)


    ## if in reference mode copy package_handle content and set new content_dir
    if(NOT reference)
      list_pop_front(args)
      ans(target_dir)
      path_qualify(target_dir)
      
      map_tryget(${package_handle} content_dir)
      ans(source_dir)
      
      cp_dir("${source_dir}" "${target_dir}")
      map_set(${package_handle} content_dir "${target_dir}")
    endif()

    return_ref(package_handle)
  endfunction()




# File: source/package/package_source/managed/package_source_push_managed.cmake

  ## package_source_push_managed(<package handle> ) -> <uri string>
  ##
  ## returns a valid uri if the package was pushed successfully 
  ## else returns null
  ##
  ## expects a this object to be defined which contains directory and source_name
  ## --reference flag indicates that the content will not be copied into the the package source 
  ##             the already existing package dir will be used 
  ## --content-dir <dir> flag indicates where the package content will reside
  ## --package-dir <dir> flag indicates parent dir of content of package
  ## --force     flag indicates that existing package should be overwritten
  function(package_source_push_managed)
    if("${ARGN}" MATCHES "(.*);=>;?(.*)")
        set(source_args "${CMAKE_MATCH_1}")
        set(args "${CMAKE_MATCH_2}")
    else()
        set(source_args ${ARGN})
        set(args)
    endif()
    list_pop_front(source_args)
    ans(source)

    list_extract_labelled_value(source_args --content-dir)
    ans(content_dir)

    list_extract_labelled_value(source_args --package-dir)
    ans(package_dir)

    list_extract_flag(args --force)
    ans(force)

    this_get(directory)

    list_pop_front(source_args)
    ans(uri)

    uri_coerce(uri)

    assign(package_handle = source.resolve(${uri}))

    if(NOT package_handle)
      error("could not resolve ${source_args} to a package handle")
      creturn()
    endif()

    package_handle_hash("${package_handle}")
    ans(hash)

    set(managed_dir "${directory}/${hash}")

    if(EXISTS "${managed_dir}" AND NOT force)
      error("package (${hash}) already exists ")
      creturn()
    endif()

    if(NOT content_dir)
      if(NOT package_dir)
        this_get(package_dir)
      endif()
      if(package_dir)
        assign(id = package_handle.package_descriptor.id)
        assign(version = package_handle.package_descriptor.version)
        

        path("${package_dir}/${id}")
        ans(content_dir)
        if(EXISTS "${content_dir}")
          path("${package_dir}/${id}@${version}")
          ans(content_dir)
          if(EXISTS "${content_dir}")
            path("${package_dir}/${hash}")
          endif()
        endif()
      else()
        set(content_dir "${managed_dir}/content")
      endif()
    else()
      path_qualify(content_dir)
    endif()

    assign(package_handle = source.pull("${uri}" ${source_args} "${content_dir}"))
    if(NOT package_handle)
      error("failed to pull {uri.uri} to {content_dir}")
      creturn()
    endif()
    assign(!package_handle.managed_descriptor.hash = hash)
    assign(!package_handle.managed_descriptor.managed_dir = managed_dir)
    assign(!package_handle.managed_descriptor.remote_source_name = source.source_name)
    assign(!package_handle.managed_descriptor.remote_uri = uri.uri)
    assign(!package_handle.working_dir = '${managed_dir}/workspace')

    qm_write("${managed_dir}/package_handle.qm" "${package_handle}")


    return_ref(package_handle)


  endfunction()






# File: source/package/package_source/managed/package_source_query_managed.cmake

  ## package_source_query_managed(<~uri>) -> <uri string>
  ## 
  ## expects a this object to be defined which contains directory and source_name
  ## 
  function(package_source_query_managed uri)
    set(args ${ARGN})


    list_extract_flag(args --package-handle)
    ans(return_package_handle)

    this_get(directory)
    this_get(source_name)

    uri_coerce(uri)

    ### read all package handles (new objects)
    ### also set the query_uri field
    file(GLOB package_handle_files "${directory}/*/package_handle.qm")
    set(package_handles)

    ## this is slow and may be made faster
    foreach(package_handle_file ${package_handle_files})
      qm_read("${package_handle_file}")
      ans(package_handle)
      assign(package_handle.query_uri = uri.uri)
      list(APPEND package_handles ${package_handle})
    endforeach()


    ## filter package handles by query
    package_handle_filter(package_handles "${uri}")
    ans(filtered_handles)

    if(NOT return_package_handle)
      set(package_uris)
      foreach(package_handle ${filtered_handles})
        map_tryget(${package_handle} uri)
        ans(uri)
        list(APPEND package_uris ${uri})
      endforeach()
      return_ref(package_uris)
    else()
      return_ref(filtered_handles)
    endif() 


    creturn()
  endfunction()

# File: source/package/package_source/managed/package_source_resolve_managed.cmake

  ## package_source_resolve_managed(<~uri>) -> <package_handle>
  ##
  ## expects a var called this exist which contains the properties 'directory' and 'source_name'
  ## 
  function(package_source_resolve_managed uri)
    uri_coerce(uri)


    ## query for package uri
    package_source_query_managed("${uri}" --package-handle)
    ans(package_handle)


    list(LENGTH package_handle count)
    if(NOT "${count}" EQUAL 1)
      creturn()
    endif()

    return_ref(package_handle)


    creturn()

  endfunction()

# File: source/package/package_source/metadata/metadata_package_source.cmake


  function(metadata_package_source source_name)
    map_new()
    ans(this)
    map_set(${this} source_name ${source_name})
    map_set(${this} query package_source_query_metadata)
    map_set(${this} resolve package_source_resolve_metadata)
    map_set(${this} pull package_source_pull_metadata)
    map_set(${this} push package_source_push_metadata)
    map_set(${this} add_package_descriptor package_source_metadata_add_descriptor)
    map_new()
    ans(metadata)
    map_set(${this} metadata ${metadata})
    return_ref(this)
  endfunction()


# File: source/package/package_source/metadata/package_source_metadata_add_descriptor.cmake


  function(package_source_metadata_add_descriptor package_descriptor)
    obj("${package_descriptor}")
    ans(package_descriptor)

    if(NOT package_descriptor)
      message(FATAL_ERROR "package_source_metadata_add_descriptor: no valid package_descriptor")
    endif()

    map_import_properties(${package_descriptor} id version make_current)
    if(NOT version)
      set(version "0.0.0")
    endif()
    map_remove("${package_descriptor}" make_current)

    this_get(metadata)

    assign(id = package_descriptor.id)
    if(NOT id)
      message(FATAL_ERROR "no valid package id")
    endif()
    

    map_clone_deep("${package_descriptor}")
    ans(new_package_descriptor)
    map_tryget(${metadata} "${id}@${version}")
    ans(package_descriptor)
    if(package_descriptor)
      map_clear(${package_descriptor})
      map_copy_shallow(${package_descriptor} ${new_package_descriptor})
      creturn(${package_descriptor})
    endif()
    set(package_descriptor ${new_package_descriptor})


    map_append(${metadata} "${id}@*" ${package_descriptor})
    map_append(${metadata} "*" ${package_descriptor})

    map_has(${metadata} ${id})
    ans(has_current)
    if(make_current OR NOT has_current)
      map_set(${metadata} ${id} ${package_descriptor})
    endif()  
    map_set(${metadata} "${id}@${version}" ${package_descriptor})
    
    return_ref(package_descriptor)
  endfunction()

# File: source/package/package_source/metadata/package_source_pull_metadata.cmake


  function(package_source_pull_metadata uri)
    set(args ${ARGN})
    list_pop_front(args)
    ans(content_dir)
    path_qualify(content_dir)

    package_source_resolve_metadata("${uri}")
    ans(package_handle)

    if(NOT package_handle)
      creturn()
    endif()

    mkdir("${content_dir}")
    map_set(${package_handle} content_dir "${content_dir}")
    return_ref(package_handle)
  endfunction()


# File: source/package/package_source/metadata/package_source_push_metadata.cmake


  function(package_source_push_metadata)
    if("${ARGN}" MATCHES "(.*);=>;?(.*)")
        set(source_args "${CMAKE_MATCH_1}")
        set(args "${CMAKE_MATCH_2}")
    else()
        set(source_args ${ARGN})
        set(args)
    endif()
    list_pop_front(source_args)
    ans(source)

    list_pop_front(source_args)
    ans(uri)

    uri_coerce(uri)

    assign(package_handle = source.resolve(${uri}))
    if(NOT package_handle)
      error("could not resolve {uri.uri} to a package handle")
      creturn()
    endif()

    map_tryget(${package_handle} package_descriptor)
    ans(package_descriptor)

    package_source_metadata_add_descriptor(${package_descriptor})
    return_ref(package_handle)
  endfunction() 


# File: source/package/package_source/metadata/package_source_query_metadata.cmake


  function(package_source_query_metadata input_uri)
    set(args ${ARGN})
    uri_coerce(input_uri)
    list_extract_flag(args --package-handle)
    ans(return_package_handle)

    this_get(metadata)
    this_get(source_name)

    uri_check_scheme(${input_uri} "${source_name}?")
    ans(scheme_ok)
    if(NOT scheme_ok)
      creturn()
    endif()


    map_tryget(${input_uri} normalized_segments)
    ans(ids)
    if(NOT ids)
      creturn()
    endif()

    map_tryget(${metadata} ${ids})
    ans(package_descriptors)
    
    set(result)
    foreach(package_descriptor ${package_descriptors})
      map_import_properties(${package_descriptor} id version)
      map_tryget(${metadata} ${id})
      ans(current)
      if("${current}" STREQUAL "${package_descriptor}")
        set(uri "${source_name}:${id}")
      else()
        set(uri "${source_name}:${id}@${version}")
      endif()
      if(return_package_handle)
        map_tryget(${input_uri} uri)
        ans(query_uri)
        map_capture_new(uri query_uri package_descriptor)
        ans_append(result)
      else()
        list(APPEND result "${uri}")
      endif()
    endforeach()

    return_ref(result)



  endfunction()


# File: source/package/package_source/metadata/package_source_resolve_metadata.cmake


  function(package_source_resolve_metadata uri)
    uri_coerce(uri)
    package_source_query_metadata("${uri}" --package-handle)
    ans(handles)

    list(LENGTH handles count)
    if(NOT "${count}" EQUAL 1)
      error("could not uniquely resolve {uri.uri} (got {count}) packages")
      creturn()
    endif()    
    return_ref(handles)
  endfunction()


# File: source/package/package_source/mock_package_source.cmake

## 
##
## package source to be used for testing purposes 
## allows easy definition of packages and dependency relationsships
## to define a package write "<package id>[@<verion>][ <package descriptor obj>]"
## e.g. "A" "A@3.2.1" "A@3.4.1 {cmakepp:{hooks:{on_ready:'[]()message(ready)'}}}"
## to define a relationship write "<package id> => <package id>"
function(mock_package_source name)
  metadata_package_source("${name}")
  ans(package_source)
  map_new()
  ans(graph)
  foreach(arg ${ARGN})
    if("${arg}" MATCHES "(.+)=>(.+)")
      set(id "${CMAKE_MATCH_1}")
      set(dep "${CMAKE_MATCH_2}")
      map_tryget(${graph} "${id}")
      ans(pd)
      if(NOT pd)
        message(FATAL_ERROR "no package found called ${id}")
      endif()

      map_new()
      ans(ph)
      map_set("${ph}" package_descriptor "${pd}") 
      package_handle_update_dependencies("${ph}" "${dep}")
    else()
      if("${arg}" MATCHES "^([^ ]+) (.*)$")
        set(id "${CMAKE_MATCH_1}")
        set(config "${CMAKE_MATCH_2}")
      else()
        set(id "${arg}")
        set(config "")
      endif()

      set(unique_id "${id}")
      if("${id}" MATCHES "(.+)@(.+)")
        set(id "${CMAKE_MATCH_1}")
        set(version "${CMAKE_MATCH_2}")
      else()
        set(version "0.0.0")
      endif()
      set(asd ${arg})
      map_capture_new(id version)
      ans(pd)
      if(config)
        obj("${config}")
        ans(config)
        map_copy_shallow(${pd} ${config})
      endif()
      map_set(${graph} "${unique_id}" "${pd}")
    endif()


  endforeach()
  map_values(${graph})
  ans(pds)
  foreach(pd ${pds})
    assign(success = package_source.add_package_descriptor("${pd}"))
  endforeach()
  return_ref(package_source)
endfunction()

# File: source/package/package_source/package_source.cmake

## `()-><package source>`
##
## returns the specified package source
## valid package soruces are returned
## valid package source types are created and returned
function(package_source source)
  is_map("${source}")
  ans(ismap)
  if(ismap)
    return_ref(source)
  endif()

  if(NOT COMMAND "${source}_package_source")
    creturn()
  endif()
  eval("${source}_package_source(${ARGN})")
  return_ans()
endfunction()


# File: source/package/package_source/package_source_query_resolve.cmake

## `(<admissable_uri> [--cache <map>])-> { <<package uri>:<package handle>>...}` 
##
##
function(package_source_query_resolve package_source admissable_uri)
  set(args ${ARGN})    

  ## get cache and if none exists create new
  list_extract_labelled_value(args --cache)
  ans(cache)
  if(NOT cache)
    map_new()
    ans(cache)
  endif()

  #message("uri ${admissable_uri}")

  set(resolved_handles)
  map_has("${cache}" "${admissable_uri}")
  ans(hit)
  if(hit)
    map_tryget("${cache}" "${admissable_uri}")
    ans(resolved_handles)
    #message("hit for ${admissable_uri} :${resolved_handles}")

  else()
    if(NOT package_source)
      message(FATAL_ERROR "no package source specified!")
    endif()
    call(package_source.query("${admissable_uri}"))
    ans(dependable_uris)

    ## resolve loop
    foreach(dependable_uri ${dependable_uris})
      package_source_resolve("${package_source}" "${dependable_uri}" --cache ${cache})
      ans(resolved_handle)
      if(resolved_handle)
        map_append_unique("${cache}" "${admissable_uri}" ${resolved_handle})
        list(APPEND resolved_handles ${resolved_handle})
      endif()
    endforeach()
  endif()

  map_new()
  ans(result)
  foreach(resolved_handle ${resolved_handles})
    map_tryget(${resolved_handle} uri)
    ans(resolved_uri)
    map_set(${result} ${resolved_uri} ${resolved_handle})
  endforeach()
  return_ref(result)
endfunction()


# File: source/package/package_source/package_source_query_resolve_all.cmake

## `(<admissable uri>... [--cache <map>])-> { <<admissable uri>:<package handle>>... }`
##
##
function(package_source_query_resolve_all package_source)
  set(args ${ARGN})
  list_extract_labelled_value(args --cache)
  ans(cache)
  if(NOT cache)
    map_new()
    ans(cache)
  endif()
  set(admissable_uris ${args})
  
  map_new()
  ans(result)


  ## loop througgh all admissable uris
  foreach(admissable_uri ${admissable_uris})
    package_source_query_resolve("${package_source}" "${admissable_uri}" --cache ${cache})
    ans(resolved)
    map_set(${result} ${admissable_uri} ${resolved})
  endforeach()

  return_ref(result)
endfunction()




# File: source/package/package_source/package_source_resolve.cmake

## `(<package source> <volatile uri> [--cache:<map>])-><package handle>?`
##
## resolves a package handle using the specified cache
function(package_source_resolve package_source uri)
  set(args ${ARGN})
  list_extract_labelled_value(args --cache)
  ans(cache)
  if(NOT cache)
    map_new()
    ans(cache)
  endif()

  map_has(${cache} "${uri}")
  ans(hit)
  if(hit)
    map_tryget(${cache} ${uri})
    ans(resolved_handle)
    list(LENGTH resolved_handle count)
    if(NOT ${count} EQUAL 1)
      creturn()
    endif()
  else()
    call(package_source.resolve("${uri}"))
    ans(resolved_handle)
    map_set(${cache} ${uri} ${resolved_handle})
    if(NOT resolved_handle)
      creturn()
    endif()
    map_tryget(${resolved_handle} uri)
    ans(dependable_uri)
    map_set(${cache} ${dependable_uri} ${resolved_handle})
  endif()

  return_ref(resolved_handle)
endfunction()

# File: source/package/package_source/package_source_transfer.cmake

function(package_source_transfer)
  if("${ARGN}" MATCHES "(.*)=>(.*)")
    set(source_args ${CMAKE_MATCH_1})
    set(sink_args ${CMAKE_MATCH_2})
  else()
    message(FATAL_ERROR "invalid arguments. expcted <source> <source args> => <sink> <sink args>")
  endif()
  list_pop_front(source_args)
  ans(source)

  list_pop_front(sink_args)
  ans(sink)

  assign(package_handle = sink.push(${source} ${source_args} => ${sink_args}))
    
  return_ref(package_handle)
endfunction()


# File: source/package/package_source/path/package_source_pull_path.cmake

## package_source_pull(<~uri> <?target_dir:<path>>) -> <package handle>
##
## pulls the content of package specified by uri into the target_dir 
## if the package_descriptor contains a content property it will interpreted
## as a glob/ignore expression list when copy files (see cp_content(...)) 
##
## --reference flag indicates that nothing is to be copied but the source 
##             directory will be used as content dir 
##
## 
function(package_source_pull_path uri)
    set(args ${ARGN})

    uri_coerce(uri)

    ## get package descriptor for requested uri
    package_source_resolve_path("${uri}")
    ans(package_handle)

    if(NOT package_handle)
        error("could not resolve {uri.uri} to a unique package")
      creturn()
    endif()


    list_extract_flag(args --reference)
    ans(reference)

    if(NOT reference)
        ## get and qualify target path
        list_pop_front(args)
        ans(target_dir)
        path_qualify(target_dir)


        assign(source_dir = package_handle.directory_descriptor.path)

        ## copy content to target dir
        assign(content_globbing_expression = package_handle.package_descriptor.content)

        cp_content("${source_dir}" "${target_dir}" ${content_globbing_expression})

        ## replace content_dir with the new target path and return  package_handle
        map_set("${package_handle}" content_dir "${target_dir}")
    else()
        assign(package_handle.content_dir = package_handle.directory_descriptor.path)
    endif()

    return_ref(package_handle)
endfunction()

# File: source/package/package_source/path/package_source_push_path.cmake

## (<installed package> <~uri> [--reference] [--consume] <package_content_copy_args:<args...>?>)
##
parameter_definition(package_source_push_path
  )
function(package_source_push_path)
    arguments_extract_defined_values(0 ${ARGC} package_source_push_path)
    ans(args)    
    if("${args}" MATCHES "(.*);=>;?(.*)")
        set(source_args "${CMAKE_MATCH_1}")
        set(args "${CMAKE_MATCH_2}")
    else()
        set(source_args ${args})
        set(args)
    endif()

    list_pop_front(source_args)
    ans(source)
        
    ## get target dir
    list_pop_front(args)
    ans(target_dir)
    if(NOT target_dir)
        pwd()
        ans(target_dir)        
    endif()

    
    path_qualify(target_dir)

    log("pushing {source.name}({source_args}) to '${target_dir}'...")    

    assign(package_handle = source.pull(${source_args} "${target_dir}"))

    if(NOT package_handle)
        error("could not pull `${source_args}` ")
        creturn()
    endif()

    log("pushed {package_handle.package_descriptor.id}@{package_handle.package_descriptor.version} to '${target_dir}'")
    
    if(NOT EXISTS "${target_dir}/package.cmake")
        log("no package descriptor existed.  writing package.cmake")
        assign(package_descriptor = package_handle.package_descriptor)
        json_write("${target_dir}/package.cmake" "${package_descriptor}")
    endif()

    return_ref(package_handle)
endfunction()

# File: source/package/package_source/path/package_source_query_path.cmake

## package_source_query_path(<uri> <?target_path>)
function(package_source_query_path uri)
  set(args ${ARGN})

  uri_coerce(uri)

  list_extract_flag(args --package-handle)
  ans(return_package_handle)



  ## check that uri is local
  map_tryget("${uri}" "normalized_host")
  ans(host)

  if(NOT "${host}" STREQUAL "localhost")
    creturn()
  endif()   

  uri_check_scheme("${uri}" "file?")
  ans(scheme_ok)
  if(NOT scheme_ok)
    error("path package query only accepts file and <none> as a scheme")
    creturn()
  endif()

  map_import_properties(${uri} query)
  
 if(NOT "_${query}" MATCHES "(^_$)|(_hash=[0-9a-zA-Z]+)")
    error("path package source only accepts a hash query in the uri.")
    creturn()
  endif()

  ## get localpath from uri and check that it is a dir and cotnains a package_descriptor
  uri_to_localpath("${uri}")
  ans(path)

  path_qualify(path)

  if(NOT IS_DIRECTORY "${path}")
    creturn()
  endif()


  ## old style package descriptor
  json_read("${path}/package.cmake")
  ans(package_descriptor)
  if(NOT package_descriptor)
    ## tries to open the package descriptor
    ## in any other format
    fopen_data("${path}/package")
    ans(package_descriptor)
  endif()
  


  ## compute hash
  set(content)


  
  assign(default_id = uri.last_segment)
  map_defaults("${package_descriptor}" "{id:$default_id,version:'0.0.0'}")
  ans(package_descriptor)
  assign(content = package_descriptor.content)

  if(content)
    pushd("${path}")
      checksum_glob_ignore(${content} --recurse)
      ans(hash)
    popd()
  else()
    checksum_dir("${path}")
    ans(hash)
  endif()
  assign(expected_hash = uri.params.hash)

  if(expected_hash AND NOT "${hash}" STREQUAL "${expected_hash}")
    error("hashes did not match for ${path}")
    creturn()
  endif()
  ## create the valid result uri (file:///e/t/c)
  uri("${path}?hash=${hash}")
  ans(result)

  ## convert uri to string
  uri_format("${result}")
  ans(result)

  if(return_package_handle)
    set(package_handle)
    assign(!package_handle.uri = result)
    assign(!package_handle.query_uri = uri.uri)
    assign(!package_handle.package_descriptor = package_descriptor)
    assign(!package_handle.directory_descriptor.hash = hash)
    assign(!package_handle.directory_descriptor.path = path)
    assign(!package_handle.directory_descriptor.pwd = pwd())

    set(result ${package_handle})
  endif()

return_ref(result)
endfunction()

# File: source/package/package_source/path/package_source_resolve_path.cmake

## returns a pacakge descriptor if the uri identifies a unique package
function(package_source_resolve_path uri)
    uri_coerce(uri)


    package_source_query_path("${uri}" --package-handle)
    ans(package_handle)

    list(LENGTH package_handle count)
    if(NOT "${count}" EQUAL 1)
        error("could not find a unique immutable uri for {uri.uri}")
        creturn()
    endif()


    return_ref(package_handle)

endfunction()



# File: source/package/package_source/path/package_source_uri_path.cmake

## `()`
##
## returns full rating if 
## dir/package.cmake exists 
## and a very high rating for a directory 
## else it returns 0
function(package_soure_rate_uri_path uri)
  uri_coerce(uri)
  uri_to_localpath("${uri}")
  ans(localpath)
  if(EXISTS "${localpath}/package.cmake")
    creturn(999)
  endif()
  if(IS_DIRECTORY "${localpath}")
    creturn(998)
  endif()
  path_qualify(localpath)
  if(EXISTS "${localpath}")
    creturn(500)
  endif()
  creturn(0)
endfunction()

# File: source/package/package_source/path/path_package_source.cmake

##
##
##
function(path_package_source)
  obj("{
    source_name:'file',
    pull:'package_source_pull_path',
    push:'package_source_push_path',
    query:'package_source_query_path',
    resolve:'package_source_resolve_path',
    rate_uri:'package_soure_rate_uri_path'
  }")
  return_ans()
endfunction()

# File: source/package/package_source/recipe/recipe_package_source_query.cmake

# <package_descriptor>
# {
#    content:<defaults to this file>,
#    cmakepp:{
#       export:<defaults to this file>
#       on_install: <...?>
#       on_load: <any function in this file>
#       on_uninstall: <any function in this file>
#    }
# }
# </package_descriptor>

function(package_source_query_recipe)
  

 

endfunction()

# File: source/package/package_source/svn/package_source_pull_svn.cmake



  function(package_source_pull_svn uri)
    set(args ${ARGN})

    package_source_query_svn("${uri}")
    ans(valid_uri_string)

    list(LENGTH valid_uri_string uri_count)
    if(NOT uri_count EQUAL 1)
      creturn()
    endif()

    uri("${valid_uri_string}")
    ans(uri)


    uri_format("${uri}" --no-query --remove-scheme svnscm)
    ans(remote_uri)

    list_pop_front(args)
    ans(target_dir)
    path_qualify(target_dir)

    ## branch / tag / trunk / revision
    assign(svn_revision = uri.params.revision)
    assign(svn_branch = uri.params.branch)
    assign(svn_tag = uri.params.tag)
    if(NOT svn_revision STREQUAL "")
      set(svn_revision --revision "${svn_revision}")
    endif() 

    if(NOT svn_branch STREQUAL "")
      set(svn_branch --branch "${svn_branch}")
    endif() 

    if(NOT svn_tag STREQUAL "")
      set(svn_tag --tag "${svn_tag}")
    endif() 

    svn_cached_checkout("${remote_uri}" "${target_dir}" ${revision} ${branch} ${tag})
    ans(success)

    if(NOT success)
      creturn()
    endif()


    ## package_descriptor
    package_handle("${target_dir}")
    ans(package_handle)

    map_tryget("${package_handle}" package_descriptor)
    ans(package_descriptor)


    ## response
    map_new()
    ans(result)
    map_set("${result}" package_descriptor "${package_descriptor}")
    map_set("${result}" uri "${valid_uri_string}")
    map_set("${result}" content_dir "${target_dir}")
    creturn(${result})

  endfunction()



# File: source/package/package_source/svn/package_source_query_svn.cmake

##
##
##
function(package_source_query_svn uri)
  set(args ${ARGN})
  list_extract_flag(args --package-handle)
  ans(return_package_handle)

  uri_coerce(uri)  

  svn_uri_analyze("${uri}")
  ans(svn_uri)

  svn_uri_format_ref("${svn_uri}")
  ans(ref_uri)

  svn_remote_exists("${ref_uri}")
  ans(remote_exists)

  if(NOT remote_exists)
    creturn()
  endif()

  svn_uri_format_package_uri("${svn_uri}")
  ans(package_uri)

  set(package_uri "svnscm+${package_uri}")

  if(return_package_handle)
    map_new()
    ans(package_handle)
    map_set(${package_handle} uri ${package_uri})
    assign(package_handle.query_uri = uri.uri)

    creturn(${package_handle})
  endif()

  creturn(${package_uri})

endfunction()

# File: source/package/package_source/svn/package_source_resolve_svn.cmake


  function(package_source_resolve_svn uri)
    package_source_query_svn("${uri}")
    ans(valid_uri_string)
    list(LENGTH valid_uri_string uri_count)

    if(NOT uri_count EQUAL 1)
      creturn()
    endif()



    svn_uri_analyze("${valid_uri_string}")
    ans(svn_uri)

    map_import_properties(${svn_uri} base_uri ref_type ref revision)

    string(REGEX REPLACE "^svnscm\\+" "" base_uri "${base_uri}")
    if(NOT revision)
      set(revision HEAD)
    endif()


    if("${ref_type}" STREQUAL "branch")
      set(ref_type branches)
    elseif("${ref_type}" STREQUAL "tag")
      set(ref_type tags)
    endif()
    set(checkout_uri "${base_uri}/${ref_type}/${ref}/package.cmake@${revision}")
    
    fwrite_temp("")
    ans(tmp)
    rm(${tmp})
    svn(export "${checkout_uri}" "${tmp}" --exit-code)
    ans(error)

    if(NOT error)
      package_handle("${tmp}")
      ans(package_handle)

      map_tryget("${package_handle}" package_descriptor)
      ans(package_descriptor)
      rm(tmp)
    endif()

    string(REGEX MATCH "[^/]+$" default_id "${base_uri}")

    map_defaults("${package_descriptor}" "{
      id:$default_id,
      version:'0.0.0'
    }")
    ans(package_descriptor)
    ## response
    map_new()
    ans(package_handle)

    map_set(${package_handle} package_descriptor "${package_descriptor}")
    map_set(${package_handle} uri "${valid_uri_string}")

    return_ref(package_handle)
  endfunction()

# File: source/package/package_source/svn/svn_package_source.cmake


  function(svn_package_source)
    obj("{
      source_name:'svnscm',
      pull:'package_source_pull_svn',
      query:'package_source_query_svn',
      resolve:'package_source_resolve_svn'
    }")
    return_ans()
  endfunction()


# File: source/package/package_source/webarchive/package_source_pull_webarchive.cmake


  function(package_source_pull_webarchive uri)
    set(args ${ARGN})

    uri_coerce(uri)

    list_extract_flag_name(args --refresh)
    ans(refresh)

    list_pop_front(args)
    ans(target_dir)

    path_qualify(target_dir)

    package_source_resolve_webarchive("${uri}")
    ans(package_handle)
    if(NOT package_handle)
        error("could not resolve webarchive {uri.uri}" --aftereffect)
        creturn()
    endif()
    assign(archive_path = package_handle.archive_descriptor.path)

    package_source_pull_archive("${archive_path}" ${target_dir})
    ans(archive_package_handle)
    if(NOT archive_package_handle)
        error("could not pull downloaded archive" --aftereffect)
        creturn()
    endif()

    map_set(${package_handle} content_dir ${target_dir})
    

    return_ref(package_handle)

  endfunction()



# File: source/package/package_source/webarchive/package_source_query_webarchive.cmake

## package_source_query_webarchive(<~uri> [--package-handle] [--refresh] <args...>) -> <package uri...>
##
## if uri identifies a package the <package uri> is returned - else nothing is returned  
##
## queries the specified uri for a remote <archive> uses `download_cached` to
## download it. (else it would have to be downloaded multiple times)
##
##   
function(package_source_query_webarchive uri)
  set(args ${ARGN})


  list_extract_flag(args --package-handle)
  ans(return_package_handle)

  ## parse and format uri
  uri_coerce(uri)

  uri_check_scheme("${uri}" http? https?)
  ans(scheme_ok)

  if(NOT scheme_ok)
    creturn()
  endif()

  assign(uri_string = uri.uri)
  ## remove the last instance of the hash query - if it exists
  ## an edge case were this woudl fail is when another hash is meant
  ## a solution then would be to prepend the hash with a magic string 
  string(REGEX REPLACE "hash=[0-9A-Fa-f]+$" "" uri_string "${uri_string}")

  ## use download cached to download a package (pass along vars like --refresh)
  download_cached("${uri_string}" --readonly ${args})
  ans(path)

  if(NOT EXISTS "${path}")
    error("could not download ${uri_string}")
    creturn()
  endif()

  assign(expected_hash = uri.params.hash)

  package_source_query_archive("${path}?hash=${expected_hash}" --package-handle)
  ans(package_handle)

  if(NOT package_handle)
    error("specified file uri {uri.uri} is not a supported archive or hash mismatch")
    creturn()
  endif()

  assign(hash = package_handle.archive_descriptor.hash)


  uri_format("${uri}" "{hash:$hash}")
  ans(package_uri)

  if(NOT return_package_handle)
    return_ref(package_uri)
  endif()

  assign(package_handle.uri = package_uri )
  assign(package_handle.query_uri = uri.uri )
  assign(package_handle.resource_uri = uri_string)

  return_ref(package_handle)

endfunction()


# File: source/package/package_source/webarchive/package_source_rate_uri_webarchive.cmake


  function(package_source_rate_uri_webarchive uri)
    uri_coerce(uri)

    uri_check_scheme(${uri} "http?" "https?")
    ans(scheme_ok)
    if(NOT scheme_ok)
      creturn(0)
    endif()



    map_tryget(${uri} file)
    ans(file)

    if("${file}" MATCHES "(tar\\.gz$)|(\\.gz$)")
      creturn(1000)
    endif()

    creturn(50)
  endfunction()

# File: source/package/package_source/webarchive/package_source_resolve_webarchive.cmake

## package_source_resolve_webarchive([--refresh])-><package handle>

  function(package_source_resolve_webarchive uri)
    set(args ${ARGN})
    
    uri("${uri}")
    ans(uri)

    package_source_query_webarchive("${uri}" ${args} --package-handle)
    ans(package_handle)

    list(LENGTH package_handle count)
    if(NOT count EQUAL 1)
      error("could not resolve {uri.uri} matches {count} packages - needs to be unqiue" --aftereffect)
      creturn()
    endif()

    assign(resource_uri = package_handle.resource_uri)

    download_cached("${resource_uri}" --readonly)
    ans(cached_archive_path)

   
    if(NOT cached_archive_path)
        error("could not download {resource_uri}" --aftereffect)
        creturn()
    endif()
    package_source_resolve_archive("${cached_archive_path}")
    ans(archive_package_handle)
    if(NOT archive_package_handle)
        error("{uri.uri} is not a supported archive file ")
        creturn()
    endif()


    map_remove(${package_handle} content_dir)
    assign(package_handle.package_descriptor = archive_package_handle.package_descriptor)
    assign(package_handle.archive_descriptor = archive_package_handle.archive_descriptor)

    return_ref(package_handle)

  endfunction()





# File: source/package/package_source/webarchive/webarchive_package_source.cmake



  function(webarchive_package_source)
    obj("{
      source_name:'webarchive',
      pull:'package_source_pull_webarchive',
      query:'package_source_query_webarchive',
      resolve:'package_source_resolve_webarchive',
      rate_uri:'package_source_rate_uri_webarchive'
    }")
    return_ans()
  endfunction()



# File: source/package/project/dependency/project_change_dependencies.cmake

## `(<project handle> <action...>)-><dependency changeset>`
##
## changes the dependencies of the specified project handle
## expects the project_descriptor to contain a valid package source
## returns the dependency changeset 
## **sideffects**
## * adds new '<dependency configuration>' `project_handle.project_descriptor.installation_queue`
## **events**
## * `project_on_dependency_configuration_changed(<project handle> <changeset>)` is called if dpendencies need to be changed
function(project_change_dependencies project_handle)
  set(args ${ARGN})

  map_tryget(${project_handle} project_descriptor)
  ans(project_descriptor)

  map_import_properties(${project_descriptor} 
    package_source
    package_cache
    )
  ## check for package source
  if(NOT package_source)
 #   message(FATAL_ERROR "no package source set up in project handle")
  endif()   

  ## get previous_configuration
  map_peek_back(${project_descriptor} installation_queue)
  ans(previous_configuration)

  if(NOT previous_configuration)
    map_new()
    ans(previous_configuration)
  endif()

  ## 
  package_dependency_configuration_update(
    "${package_source}"
    "${project_handle}"
    ${args}
    --cache ${package_cache}
    )
  ans(configuration)

  ## invalid configuration
  if(NOT configuration)
    creturn()
  endif()

  ## compute changeset  and return
  package_dependency_configuration_changeset(
    ${previous_configuration} 
    ${configuration}
  )
  ans(changeset)

  map_isempty(${changeset})
  ans(is_empty)
  if(is_empty)
    return_ref(changeset)
  endif()

  ## add the changeset to the installation queue
  map_append(${project_descriptor} installation_queue ${configuration})

  ## emit event
  event_emit(project_on_dependency_configuration_changed ${project_handle} ${changeset})

  return_ref(changeset)
endfunction()


# File: source/package/project/dependency/project_package_ready_state_update.cmake

## `(<project package> <package handle>)-><void>` 
##
## updates all dependencies starting at package
## **sideffects**
## * 
## **events**
## * project_on_package_all_dependencies_materialized(<project handle> <package handle>)
## * project_on_package_and_all_dependencies_materialized(<project handle> <package handle>)
function(project_package_ready_state_update project package)

  function(__dodfs_update_recurse current)
    ## recursion anchor: current is already visted or still being visited
    map_tryget(${context} ${current})
    ans(status)
    if(status)
      creturn()
    endif()
    map_set(${context} ${current} visiting)

    map_get_map(${current} dependency_descriptor)
    ans(dependency_descriptor)
          
    ## check if all dependencies of package are materialized
    package_handle_is_ready(${current})
    ans(is_ready)

    map_tryget(${dependency_descriptor} is_ready)
    ans(was_ready)


    if(is_ready AND NOT was_ready)
      event_emit(project_on_package_ready ${project} ${current})
    elseif(NOT is_ready AND was_ready)
      event_emit(project_on_package_unready ${project} ${current})
    else()
      ## no change
      map_set(${context} ${current} visited)
      creturn()
    endif()

    ## update dependency descriptor
    map_set(${dependency_descriptor} is_ready ${is_ready})

    ## visit each dependee to check if their ready state changed
    map_tryget(${current} dependees)
    map_flatten(${__ans})
    map_flatten(${__ans})
    ans(dependees)

    foreach(dependee ${dependees})
      __dodfs_update_recurse(${dependee})
    endforeach()

    map_set(${context} ${current} visited)
    creturn()
  endfunction()

  map_new()
  ans(context)
  __dodfs_update_recurse(${package})
  creturn()
endfunction()

## register event handles to automatically call 
## update ready state function
function(__project_ready_state_register_listeners)
  event_addhandler(project_on_package_dematerialized project_package_ready_state_update)
  event_addhandler(project_on_package_materialized project_package_ready_state_update)
  event_addhandler(project_on_dependency_configuration_changed "[](project) project_package_ready_state_update({{project}} {{project}})")
endfunction()
task_enqueue(__project_ready_state_register_listeners)

# File: source/package/project/extensions/cmake/cmake_export_handler.cmake

## ``
##
## exports (includes) all files spcified in `package_descriptor.cmake.export` glob ignore expressions
## which allow  the project to have access to the cmake specified
function(cmake_export_handler project_handle package_handle)

  ## load the exports and includes them once
  assign(content_dir = package_handle.content_dir)
  assign(export = package_handle.package_descriptor.cmake.export)
  if(IS_DIRECTORY "${content_dir}")
    pushd("${content_dir}")
      glob_ignore(${export})
      ans(paths)
    popd()

    log("{package_handle.uri}: loading exports '${paths}'" --trace --function cmake_export_handler)
    foreach(path ${paths})
      include_once("${path}")
    endforeach()
  endif()
endfunction()

# File: source/package/project/extensions/cmake/package_cmake_module_content.cmake


  function(package_cmake_module_content package module)
    map_import_properties(${package} content_dir)

    map_import_properties(${module} 
      add_as_subdirectory
      include_dirs
     )
    pushd(${content_dir})
    paths(${include_dirs})
    ans(include_dirs)
    if(NOT include_dirs)
      set(include_dirs ${content_dir})
    endif()
    popd()
    assign(module_name = package.package_descriptor.id)
   # string(TOUPPER "${module_name}" module_name)
    format("##
set({module_name}_DIR \"{content_dir}\")
set({module_name}_INCLUDE_DIRECTORIES ${include_dirs})
set({module_name}_FOUND \"{content_dir}\")

")
    ans(result)
    if(add_as_subdirectory)
      set(result "${result}add_subdirectory(\${${module_name}_DIR})" )
    endif()
    return_ref(result)
  endfunction()


# File: source/package/project/extensions/cmake/project_cmake_constants.cmake

  macro(project_cmake_constants)
    set(project_cmake_module_dir "cmake")
    set(project_cmake_module_include_dir "include")
  endmacro()


# File: source/package/project/extensions/cmake/project_cmake_export_config.cmake

function(project_cmake_export_config project package)
  assign(install = package.package_descriptor.cmake.install)
  if(NOT install)
    creturn()
  endif()


  map_tryget(${project} content_dir)
  ans(project_dir)
  map_tryget(${project} project_descriptor)
  ans(project_descriptor)
  map_tryget(${project_descriptor} config_dir)
  ans(config_dir)

  print_vars(config_dir project_dir install)

endfunction()





# File: source/package/project/extensions/cmake/project_cmake_export_module.cmake


  function(project_cmake_export_module project package)
    assign(module = package.package_descriptor.cmake.module)
    if(NOT module)
      creturn()
    endif()

    assign(module_name = package.package_descriptor.id)
    if(NOT module_name)
      error("project_cmake_export_module: package requires a id unique to project.")
      creturn()
    endif()

    set(module_file_name "Find${module_name}.cmake")

    project_cmake_constants()

    map_tryget(${package} content_dir)
    ans(package_dir)
    map_tryget(${project} content_dir)
    ans(project_dir)

    map_get_map(${project} cmake_descriptor)
    ans(cmake_descriptor)

    map_get_default(${cmake_descriptor} module_dir "${project_cmake_module_dir}")
    ans(module_dir)


    path_qualify_from("${project_dir}" "${module_dir}")
    ans(module_dir)

    print_vars(package_dir module_dir project_dir module_name)

    path_qualify_from("${module_dir}" "${module_file_name}")
    ans(module_file_path)


    if(NOT EXISTS "${module_file_path}")
      ## get module content
      package_cmake_module_content("${package}" "${module}")
      ans(module_content)
      fwrite("${module_file_path}" "${module_content}")
    endif()

    if(NOT EXISTS "${module_dir}/Findcmakepp.cmake")
      cmakepp_config(cmakepp_path)
      ans(cmakepp_path)
      fwrite("${module_dir}/Findcmakepp.cmake" "
        include(\"${cmakepp_path}\")
        " )


    endif()

    creturn()
  endfunction()


# File: source/package/project/extensions/generator/package_file_generator.cmake

## `(<project handle> <package handle>)-><void>`
##
## **automatically register to package_on_readY"
##
## generates files inside package's content_dir
## this is useful for packages which only consist of metadata
## 
## reads all keys of `package_descriptor.generate : { <<filename template:<string>>:<file content template|cmake function call> }`. 
## These keys are treated as filenames which are formatted using `format(...)` (this allows for customized filenames)
## the property value is interpreted as a template see `template_compile`. or if it exists 
## as a call to a cmake function.
## 
## **scope**
## the following variables are available in the scope for `format` and `template_compile` and calling a function
## * `project : <project handle>`
## * `package : <package handle>`
## 
## **Example**
##
function(package_file_generator project package)
  map_import_properties(${package} package_descriptor content_dir)
  map_tryget("${package_descriptor}" generate)
  ans(generate)

  if(NOT generate)
    creturn()
  endif()

  map_keys(${generate})
  ans(file_names)
  set(generated_files)
  regex_cmake()
  foreach(file_name ${file_names})
    
    map_tryget(${generate} ${file_name})
    ans(file_content)

    ## ensnure that all scope variables are set
    ## package 
    ## project 
    ## package_descriptor
    ## file_name


    format("${file_name}")
    ans(relative_file_name)

    path_qualify_from("${content_dir}" "${relative_file_name}") 
    ans(file_name)

    set(custom_command false)
    if("${file_content}" MATCHES "^${regex_cmake_command_invocation}")
      set(command "${${regex_cmake_command_invocation.regex_cmake_identifier}}")
      set(args "${${regex_cmake_command_invocation.arguments}}")
      if(COMMAND "${command}")
        data("${args}")
        ans(args)
        format("${args}")
        ans(args)
        call2("${command}" ${args})
        ans(file_content)
        set(custom_command true)
      endif()
    endif()


    if(NOT custom_command)
      template_run("${file_content}")
      ans(file_content)
    endif()
    log("generating file '${relative_file_name}' for '{package.uri}'" --function package_file_generator)
    fwrite("${file_name}" "${file_content}")


    list(APPEND generated_files ${file_name})

  endforeach()

  return_ref(generated_files)


endfunction()


## register package file generator as a event handler for project_on_package_ready
task_enqueue("[]() event_addhandler(project_on_package_ready package_file_generator)")


# File: source/package/project/extensions/hooks/on_dematerializing_hook.cmake


## 
## 
## hooks:
##   `package_descriptor.cmakepp.hooks.on_dematerializing(<project handle> <packag handle>)`
##     this hook is invoked if it exists. it is invoked before the on_load hook 
##     this means that the project's exports were not loaded when the hook is called
##     however since cmake files are callable you can specify a local path
function(on_dematerializing_hook project_handle package_handle)
  package_handle_invoke_hook("${package_handle}" hooks.on_dematerializing ${project_handle} ${package_handle})
endfunction()



# File: source/package/project/extensions/hooks/on_loaded_hook.cmake

## 
##
## imports all files specified in the package_handle's 
## package_descriptor.cmakepp.export property relative
## to the package_handle.content_dir.  the files are
## included in which they were globbed.
##
## hooks:
##   package_descriptor.cmakepp.hooks.on_load(<project handle> <package handle>):
##     after files were imported the hook stored under 
##     package_descriptor.cmakepp.hooks.on_load is called
##     the value of on_load may be anything callable (file,function lambda)
##     the functions which were exported in the previous step
##     can be such callables. 
## 
##
## events:  
function(on_loaded_hook project_handle package_handle)
  

  log("invoking on loaded hook for {package_handle.uri}" --trace --function on_loaded_hook)
  ## call on_load hook
  package_handle_invoke_hook(${package_handle} hooks.on_load ${project_handle} ${package_handle})
endfunction()




# File: source/package/project/extensions/hooks/on_materialized_hook.cmake

## `()->` 
##
## **config**
## 
## **hooks**:
##   `package_descriptor.cmakepp.hooks.on_materialized(<project handle> <packag handle>)`
##     this hook is invoked if it exists. it is invoked before the on_load hook 
##     this means that the project's exports were not loaded when the hook is called
##     however since cmake files are callable you can specify a local path
function(on_materialized_hook project_handle package_handle)
  package_handle_invoke_hook("${package_handle}" hooks.on_materialized ${project_handle} ${package_handle})
endfunction()



# File: source/package/project/extensions/hooks/on_ready_hook.cmake


function(on_ready_hook project_handle package_handle)
  package_handle_invoke_hook("${package_handle}" hooks.on_ready ${project_handle} ${package_handle})
endfunction()



# File: source/package/project/extensions/hooks/on_unloading_hook.cmake



function(on_unloading_hook project_handle package_handle)
  package_handle_invoke_hook(${package_handle} hooks.on_unloading ${project_handle} ${package_handle})
endfunction()


# File: source/package/project/extensions/hooks/on_unready_hook.cmake

## 
## 
## calls the package_descritpor's `cmakepp.hooks.on_unready` hook if the package is still available
function(on_unready_hook project_handle package_handle)
  map_tryget(${package_handle} materialization_descriptor)
  ans(is_materialized)
  if(is_materialized)
    package_handle_invoke_hook(
      "${package_handle}" 
      hooks.on_unready 
      ${project_handle} 
      ${package_handle}
      )
  endif()
endfunction()


# File: source/package/project/extensions/loading/project_load.cmake

## `(<project>)-><bool>`
##
## @TODO extract dfs algorithm, extreact dependency_load function which works for single dependencies
## 
## loads the specified project and its dependencies
##  
## **events**
## * `project_on_loading`
## * `project_on_loaded`
## * `project_on_package_loading`
## * `project_on_package_loaded`
## * `project_on_package_reload`
## * `project_on_package_cycle`
function(project_load project_handle)
  map_tryget(${project_handle} project_descriptor)
  ans(project_descriptor)

  ## load dependencies
  map_import_properties(${project_descriptor} package_materializations)
  map_values(package_materializations)
  ans(package_materializations)
  set(materialized_packages)
  map_tryget(${project_handle} content_dir)
  ans(project_dir)

  ## set content_dir for every package handle
  ## it is obtained by qualifying the materialization descriptors content_dir
  ## with the project's content_dir
  foreach(materialization ${package_materializations})
    map_tryget(${materialization} package_handle)
    ans_append(materialized_packages)
    ans(package_handle)
    map_tryget(${materialization} content_dir)
    ans(package_dir)
    path_qualify_from(${project_dir} ${package_dir})
    map_set(${package_handle} content_dir ${package_dir})
  endforeach()
  
  
  event_emit(project_on_loading ${project_handle})
  
  map_new()
  ans(context)
  function(__project_load_recurse)

    foreach(package_handle ${ARGN})
      
      map_tryget(${context} ${package_handle})
      ans(state)
      if("${state}_" STREQUAL "visiting_")
        event_emit(project_on_package_cycle ${project_handle} ${package_handle})
      elseif("${state}_" STREQUAL "visited_")
        event_emit(project_on_package_reload ${project_handle} ${package_handle})
      else()
        map_set(${context} ${package_handle} visiting)
          
        ## pre order callback
        event_emit(project_on_package_loading ${project_handle} ${package_handle})
        set(parent_parent_package ${parent_package})
        set(parent_package ${package_handle})
        

        ## expand
        map_tryget(${package_handle} dependencies)
        ans(dependency_map)
        if(dependency_map)
          map_values(${dependency_map})
          ans(dependencies)

          __project_load_recurse(${dependencies})
          
        endif()
        
        map_set(${context} ${package_handle} visited)

        ## post order callback
        set(parent_package ${parent_parent_package})
        event_emit(project_on_package_loaded ${project_handle} ${package_handle})

      endif()
    endforeach()
  endfunction()

  set(parent_parent_package)
  set(parent_package)
  __project_load_recurse(${project_handle} ${materialized_packages})

  event_emit(project_on_loaded ${project_handle})
 
  creturn(true)
endfunction()




# File: source/package/project/extensions/loading/project_loader.cmake


function(project_loader project)
  map_tryget(${project} dependency_descriptor)
  ans(dependency_descriptor)
  map_tryget("${dependency_descriptor}" is_ready)
  ans(is_ready)
  if(NOT is_ready)
    creturn()
  endif()
  if("${ARGN}_" STREQUAL "_" OR "${project}" STREQUAL "${ARGN}")
    project_load(${project})
  endif()
endfunction()


# File: source/package/project/extensions/loading/project_unload.cmake

## `(<project>)-><bool>`
##
## unloads the specified project and its dependencies
##  
## **events**
## * `project_on_unloading`  called before an packages is unloaded
## * `project_on_unloaded`  called after all packages were unloaded
## * `project_on_package_unloading` called before the package's dependencies are unloaded 
## * `project_on_package_unloaded` called after the package's dependencies are unloaded
function(project_unload project_handle)
  ## load dependencies
  map_import_properties(${project_handle} project_descriptor)
  map_import_properties(${project_descriptor} package_materializations)
  map_values(${package_materializations})
  ans(package_materializations)
  ans(package_handles)
  foreach(materialization ${package_materializations})
    map_tryget(${materialization} package_handle)
    ans_append(package_handles)
  endforeach()

  event_emit(project_on_unloading ${project_handle})
  
  map_new()
  ans(context)
  function(__project_unload_recurse)

    foreach(package_handle ${ARGN})
      
      map_tryget(${context} ${package_handle})
      ans(state)
      if("${state}_" STREQUAL "visiting_")
      elseif("${state}_" STREQUAL "visited_")
      else()
        map_set(${context} ${package_handle} visiting)
          
        ## pre order callback
        event_emit(project_on_package_unloading ${project_handle} ${package_handle})
        set(parent_parent_package ${parent_package})
        set(parent_package ${package_handle})
        

        ## expand
        map_tryget(${package_handle} dependencies)
        ans(dependency_map)
        if(dependency_map)
          map_values(${dependency_map})
          ans(dependencies)

          __project_unload_recurse(${dependencies})
          
        endif()
        
        map_set(${context} ${package_handle} visited)

        ## post order callback
        set(parent_package ${parent_parent_package})
        event_emit(project_on_package_unloaded ${project_handle} ${package_handle})

      endif()
    endforeach()
  endfunction()

  set(parent_parent_package)
  set(parent_package)
  __project_unload_recurse(${project_handle} ${package_handles})


  event_emit(project_on_unloaded ${project_handle})
 
  creturn(true)
endfunction()




# File: source/package/project/extensions/loading/project_unloader.cmake


function(project_unloader project)
  map_tryget(${project} dependency_descriptor)
  ans(dependency_descriptor)
  map_tryget("${dependency_descriptor}" is_ready)
  ans(is_ready)
  if(NOT is_ready)
    creturn()
  endif()
  if("${ARGN}_" STREQUAL "_" OR "${project}" STREQUAL "${ARGN}")
    project_unload(${project})
  endif()
endfunction()

# File: source/package/project/extensions/materialize/package_materialization_check.cmake

## `(<project handle> <materialization handle>)-><bool>`
## 
## checks wether an expected materialization actually exists and is valid
## return true if it is
function(package_materialization_check project_handle package_handle)
  ## if package does not have an materialization descriptor it is not materialized
  map_tryget(${package_handle} materialization_descriptor)
  ans(materialization_handle)
  if(NOT materialization_handle)
    creturn(false)
  endif()

  map_tryget(${materialization_handle} content_dir )
  ans(package_dir)

  map_tryget("${project_handle}" content_dir)
  ans(project_dir)

  path_qualify_from("${project_dir}" "${package_dir}")
  ans(content_dir)

  package_content_check("${package_handle}" "${content_dir}" )
  return_ans()
endfunction()


# File: source/package/project/extensions/materialize/project_dematerialize.cmake

## `(<project handle> <package uri>)-><package handle>`
##
## **sideeffects**
## * removes `project_handle.project_descriptor.package_installations.<package_uri>` 
## * removes `package_handle.materialization_descriptor`
## 
##
## **events**:
## * `[pwd=package content dir]project_on_package_dematerializing(<project handle> <package handle>)`
## * `[pwd=package content dir]project_on_package_dematerialized(<project handle> <package handle>)`
## 
function(project_dematerialize project_handle package_uri)
  map_import_properties(${project_handle} project_descriptor)
  map_tryget(${project_handle} uri)
  ans(project_uri)

  map_import_properties(${project_descriptor} 
    package_source
    package_cache
    package_materializations

    )


  ## special treatment for project - dematerialization is allowed
  ## however it will only be virtual and not actualle affect the
  ## content_dir
  if("${project_uri}" STREQUAL "${package_uri}")
    map_tryget(${package_materializations} ${project_uri})
    ans(project_handle)
    map_tryget(${project_handle} content_dir)
    ans(content_dir)
    pushd(${content_dir})
      event_emit(project_on_package_dematerializing ${project_handle} ${project_handle})
        map_remove(${package_materializations} ${project_uri})    
        map_remove(${project_handle} materialization_descriptor)
      event_emit(project_on_package_dematerialized ${project_handle} ${project_handle})
    popd()
    creturn(${project_handle})
  endif()


  if(NOT package_source)
    message(FATAL_ERROR "project_dematerialize: no package source available")
  endif()

  package_source_resolve(${package_source} ${package_uri} --cache ${package_cache})
  ans(package_handle)

  if(NOT package_handle)
    creturn()
  endif()

  map_tryget(${package_handle} uri)
  ans(package_uri)

  map_tryget(${package_handle} materialization_descriptor)
  ans(materialization_handle)

  if(NOT materialization_handle)
    creturn()
  endif() 

  map_tryget(${project_handle} content_dir)
  ans(project_dir)

  map_tryget(${materialization_handle} content_dir)
  ans(package_content_dir)

  path_qualify_from(${project_dir} ${package_content_dir})
  ans(package_content_dir)

  ## emit events before and after removing package
  ## should also work if package doesnot exist anymore
  pushd("${package_content_dir}" --create)  

    event_emit(project_on_package_dematerializing ${project_handle} ${package_handle})

    map_remove(${package_materializations} ${package_uri})
    map_remove(${package_handle} materialization_descriptor)
    ## delete package content dir

    if("${project_dir}" STREQUAL "${package_content_dir}")
      message(WARNING "project_dematerialize: package dir is project dir will not delete")
    else()
      rm(-r "${package_content_dir}")
    endif()


    event_emit(project_on_package_dematerialized ${project_handle} ${package_handle})
  popd()
  creturn(${package_handle})
endfunction()


# File: source/package/project/extensions/materialize/project_derive_package_content_dir.cmake

## `(<project handle> <package handle>)-><path>`
##
##  creates a path which tries to be unqiue for the specified pcakge in the project
##
function(project_derive_package_content_dir project_handle package_handle)

  format("{package_handle.package_descriptor.id}")
  ans(package_id)
  string_normalize("${package_id}")
  ans(package_id)

  assign(uri = package_handle.uri)
  uri_coerce(uri)

  map_get("${uri}" scheme)
  ans(scheme)


  format("{project_handle.project_descriptor.dependency_dir}/${scheme}_{package_id}-{package_handle.package_descriptor.version}")
  ans(package_content_dir)
  return_ref(package_content_dir)
endfunction()

# File: source/package/project/extensions/materialize/project_materialization_check.cmake

## `(<project handle>)-><materialization handle>...`
##
## **events**
## * `project_on_package_materialization_missing`
##
## **sideffects**
## * removes missing materializations from `project_descriptor.package_materializations`
## * removes missing materializations from `package_handle.materialization_descriptor`
##
## checks all materializations of a project 
## if a materialization is missing it is removed from the 
## map of materializations
## returns all invalid materialization handles
function(project_materialization_check project_handle)
  map_import_properties(${project_handle} project_descriptor)
  map_import_properties(${project_descriptor} package_materializations)

  if(NOT package_materializations)
    creturn()
  endif()
  map_keys(${package_materializations})
  ans(package_uris)

  set(invalid_materializations)
  foreach(package_uri ${package_uris})
    map_tryget("${package_materializations}" "${package_uri}")
    ans(package_handle)
    package_materialization_check("${project_handle}" "${package_handle}")
    ans(ok)
    if(NOT ok)
      project_dematerialize("${project_handle}" "${package_uri}")    
      list(APPEND invalid_materializations ${package_handle})
    endif()
  endforeach()
  return_ref(invalid_materializations)
endfunction() 


# File: source/package/project/extensions/materialize/project_materialize.cmake

## `(<project handle> <volatile uri> <target dir>?)-><package handle>?`
##
## materializes a package for the specified project.
## if the package is already materialized the existing materialization handle
## is returned
## the target dir is treated relative to project root. if the target_dir
## is not given a target dir will be derived e.g. `<project root>/packages/mypackage-0.2.1-alpha`
##
## returns the package handle on success
## 
## **events**: 
## * `[pwd=target_dir]project_on_package_materializing(<project handle> <package handle>)`
## * `[pwd=target_dir]project_on_package_materialized(<project handle> <package handle>)`
##
## **sideffects**:
## * `IN` takes the package from the cache if it exits
## * adds the specified package to the `package cache` if it does not exist 
## * `project_handle.project_descriptor.package_materializations.<package uri> = <materialization handle>`
## * `package_handle.materialization_descriptor = <materialization handle>`
##
## ```
## <materialization handle> ::= {
##   content_dir: <path> # path relative to project root
##   package_handle: <package handle>
## }
## ```
function(project_materialize project_handle package_uri)
  set(args ${ARGN})

  list_pop_front(args)
  ans(package_content_dir)

  map_tryget(${project_handle} uri)
  ans(project_uri)

  map_tryget(${project_handle} project_descriptor)
  ans(project_descriptor)

  map_import_properties(${project_descriptor} 
    package_materializations
    package_source
    package_cache
    dependency_dir
  )

  ## special treatment  if package uri is project uri
  ## project is already materialized however 
  ## events still need to be emitted / materialization_handle 
  ## needs to be created
  if("${project_uri}" STREQUAL "${package_uri}")
    map_tryget(${package_materializations} ${project_uri})
    ans(materialization_handle)
    if(NOT materialization_handle)
      map_new()
      ans(materialization_handle)
      map_set(${materialization_handle} content_dir "")
      map_set(${materialization_handle} package_handle ${project_handle})
      event_emit(project_on_package_materializing ${project_handle} ${project_handle})
      map_set(${package_materializations} "${package_uri}" ${project_handle})
      map_set(${project_handle} materialization_descriptor ${materialization_handle})
      event_emit(project_on_package_materialized ${project_handle} ${project_handle})
    endif()
    creturn(${project_handle})
  endif()

  if(NOT package_source)
    message(FATAL_ERROR "project_materialize: no package source available")
  endif()

  ## get a package handle from uri
  package_source_resolve(${package_source} "${package_uri}" --cache ${package_cache})
  ans(package_handle)
  if(NOT package_handle)
    creturn()
  endif()


  map_tryget(${project_handle} content_dir)
  ans(project_dir)

  map_tryget(${package_handle} uri)
  ans(package_uri)

  map_tryget(${package_materializations} ${package_uri})
  ans(is_materialized)

  if(is_materialized)
    creturn(${package_handle})
  endif()

  
  ## generate the content dir for the package 
  if("${package_content_dir}_" STREQUAL "_")
    project_derive_package_content_dir(${project_handle} ${package_handle})
    ans(package_content_dir)
  endif()
  

  ## create materialization handle
  map_new()
  ans(materialization_handle)
  map_set(${materialization_handle} package_handle ${package_handle})
  map_set(${materialization_handle} content_dir ${package_content_dir})
  map_set(${package_handle} materialization_descriptor ${materialization_handle})

  ## make a qualified path
  path_qualify_from(${project_dir} ${package_content_dir})
  ans(package_content_dir)

  map_set(${package_handle} content_dir ${package_content_dir})

  if("${package_content_dir}" STREQUAL "${project_dir}")
    message(WARNING"project_materialize: invalid package dir '${package_content_dir}'")
    creturn()
  endif()

  pushd(${installation_dir} --create)

    event_emit(project_on_package_materializing ${project_handle} ${package_handle})

    call(package_source.pull("${package_uri}" "${package_content_dir}"))
    ans(pull_handle)
    ## todo content dir might not be the same
    
    if(NOT pull_handle)
      map_remove(${package_handle} materialization_descriptor)
      popd()
      creturn()
    endif()

    map_set(${package_materializations} ${package_uri} ${package_handle})

    event_emit(project_on_package_materialized ${project_handle} ${package_handle})
  
  popd()


  creturn(${package_handle})
endfunction()



# File: source/package/project/extensions/materialize/project_materialize_dependencies.cmake

## `(<project handle>)-><materialization handle>...`
##
##
## **returns**
## * the `materialization handle`s of all changed packages
##
## **sideffects**
## * see `project_materialize`
## * see `project_dematerialize`
##
## **events**
## * `project_on_dependencies_materializing(<project handle>)`
## * `project_on_dependencies_materialized(<project handle>)`
## * events from `project_materialize` and project `project_dematerialize`
function(project_materialize_dependencies project_handle)
  map_tryget(${project_handle} project_descriptor)
  ans(project_descriptor)
  map_import_properties(${project_descriptor} 
    package_materializations
    dependency_configuration
    installation_queue
    package_cache
    )

  set(changed_packages)

  event_emit(project_on_dependencies_materializing ${project_handle})


  set(current_configuration ${dependency_configuration})
  while(true)
    list_pop_front(installation_queue)
    ans(new_configuration)
    if(NOT new_configuration)
      break()
    endif()
    package_dependency_configuration_changeset(${current_configuration} ${new_configuration})
    ans(changeset)


    map_keys(${changeset})
    ans(package_uris)
    foreach(package_uri ${package_uris})
      map_tryget(${dependency_configuration} ${package_uri})
      ans(state)

      map_tryget(${changeset} ${package_uri})
      ans(action)

      if("${action}" STREQUAL "install")
        project_materialize(${project_handle} ${package_uri})
        ans(package_handle)
      elseif("${action}" STREQUAL "uninstall")
        project_dematerialize(${project_handle} ${package_uri})
        ans(package_handle)
      else()
        message(FATAL_ERROR "project_materialize_dependencies: invalid action `${action}`")    
      endif()

      if(NOT package_handle)
        message(WARNING "failed to materialize/dematerialize dependency ${package_uri}")
      endif()

      list(APPEND changed_packages ${package_handle})
      
    endforeach() 

    #map_pop_front(${project_descriptor} installation_queue)
    map_set(project_descriptor dependency_configuration ${new_configuration})
    set(current_configuration ${new_configuration})
  endwhile()


  ## emit event
  event_emit(project_on_dependencies_materialized ${project_handle})

  ## load the project anew
  project_load(${project_handle})


  return_ref(changed_packages)
endfunction()

# File: source/package/project/extensions/materialize/project_materializer.cmake


function(project_materializer project)
  ## materialize project if it is not materialized
  map_tryget(${project} materialization_descriptor)
  ans(is_materialized)
  if(NOT is_materialized)
    map_tryget(${project} uri)
    ans(project_uri)
    project_materialize(${project} "${project_uri}")
  endif()
endfunction()

# File: source/package/project/extensions/package_descriptor/project_package_descriptor_reader.cmake

## `(<project>)-><void>`
##
## reads the package descriptor from a project local file if 
## `project_handle.project_descriptor.project_descriptor_file` is configured
function(project_package_descriptor_reader project)
  map_get_map(${project} package_descriptor)
  ans(package_descriptor)

  map_import_properties(${project} project_descriptor content_dir)
  map_import_properties(${project_descriptor} package_descriptor_file)

  if(NOT package_descriptor_file)
    creturn()
  endif()


  map_set_special(${project_descriptor} project_package_descriptor_was_read true)

  path_qualify_from("${content_dir}" "${package_descriptor_file}")
  ans(package_descriptor_file)


  log("reading package descriptor from '${package_descriptor_file}'" --function project_package_descriptor_reader)
  fread_data("${package_descriptor_file}")
  ans(new_package_descriptor)
  if(new_package_descriptor)
    map_copy_shallow("${package_descriptor}" "${new_package_descriptor}")
  else()
    log("could not read package descriptor from '${package_descriptor_file}'" --function project_package_descriptor_reader)
  endif()

endfunction()


# File: source/package/project/extensions/package_descriptor/project_package_descriptor_writer.cmake


## `(<project>)-><void>`
##  
## writes the package_descriptor to a package_descriptor_file
## if it is configured. does not overwrite package_descriptor_file
## if it was newly set
function(project_package_descriptor_writer project)
  map_import_properties(${project} project_descriptor content_dir)
  map_import_properties(${project_descriptor} package_descriptor_file)
  if(NOT package_descriptor_file)

    creturn()
  endif()
  map_get_special(${project_descriptor} project_package_descriptor_was_read)
  ans(was_read)


  path_qualify_from("${content_dir}" "${package_descriptor_file}")
  ans(package_descriptor_file)

    
  map_tryget(${project_handle} package_descriptor)
  ans(package_descriptor)

  if(NOT was_read)
    fread_data("${package_descriptor_file}")
    ans(new_package_descriptor)
    if(new_package_descriptor)
      map_copy_shallow(${package_descriptor} ${new_package_descriptor})
    endif()
  endif()


  if(package_descriptor)
    log("writing package descriptor to '${package_descriptor_file}'" --function project_package_descriptor_reader)
    fwrite_data("${package_descriptor_file}" ${package_descriptor})
  endif()


endfunction()


# File: source/package/project/extensions/project_register_extensions.cmake

function(project_register_extensions)

  event_addhandler(project_on_open project_package_descriptor_reader)
  event_addhandler(project_on_open project_materialization_check)
  event_addhandler(project_on_open project_loader)

  event_addhandler(project_on_close project_unloader)
  event_addhandler(project_on_close project_package_descriptor_writer)
  
  event_addhandler(project_on_package_ready project_loader)
  event_addhandler(project_on_package_ready on_ready_hook)
  event_addhandler(project_on_package_ready package_dependency_symlinker)

  event_addhandler(project_on_package_dematerializing on_dematerializing_hook)
  event_addhandler(project_on_package_materialized on_materialized_hook)
  
  event_addhandler(project_on_package_loaded cmake_export_handler)
  event_addhandler(project_on_package_loaded on_loaded_hook)
  event_addhandler(project_on_package_loaded project_cmake_export_module)
  event_addhandler(project_on_package_loaded project_cmake_export_config)

  event_addhandler(project_on_package_unloading on_unloading_hook)

  event_addhandler(project_on_package_unready project_unloader)
  event_addhandler(project_on_package_unready "[]() package_dependency_symlinker({{ARGN}} --unlink)")
  event_addhandler(project_on_package_unready on_unready_hook)



endfunction()


## react to ready/unready events
task_enqueue(project_register_extensions)



# File: source/package/project/extensions/symlinker/package_dependency_symlinker.cmake

## `(<project handle> <package handle> [---unlink])-><void>`
##
## adds a symlink from dependees package folder to dependencies content folder 
## the symlink is relative to the package folder and configured in the package's dependency constraints using the symlink property
## 
## `{ id:'mypkg', dependencies:'some-dependency':{symlink:'pkg1'}}` this will cause the content of some-dependency to be symlinked to <package root>/pkg1
## 
## the symlinker is automatically executed when a package becomes ready (and unready)
## 
function(package_dependency_symlinker project package)
  set(args ${ARGN})
  list_extract_flag(args --unlink)
  ans(unlink)
  map_import_properties(${package} dependencies package_descriptor content_dir)
  map_tryget(${package_descriptor} dependencies)
  ans(dependency_constraints)
  if(NOT dependencies)
    creturn()
  endif()
  
  map_keys(${dependencies})
  ans(dependency_uris)

  ## loop through all admissable uris and get the dependency as well as the constraints
  foreach(dependency_uri ${dependency_uris})
    map_tryget(${dependencies} ${dependency_uri})
    ans(dependency)
    map_tryget(${dependency_constraints} ${dependency_uri})
    ans(constraints)

    ## if the constraints have the symlink property the symlinker
    ## creates a link from the dependee's content_dir/${symlink} to the dependencies ${content_dir}
    map_has(${constraints} symlink)
    ans(has_symlink)
    if(has_symlink)
      map_tryget(${constraints} symlink)
      ans(symlink)

      is_address("${symlink}")
      ans(isref)
      if(NOT isref)
        set(single_link "${symlink}")
        map_new()
        ans(symlink)
        map_set("${symlink}" "${single_link}" ".")
      endif()

      map_keys("${symlink}")
      ans(links)

      foreach(link ${links})          
        map_tryget("${symlink}" "${link}")
        ans(target)

        ## dependency
        ## project 
        ## package
        format("${link}")
        ans(relative_link)
        format("${target}")
        ans(relative_target)

        path_qualify_from("${content_dir}" "${relative_link}")
        ans(link)

        map_tryget(${dependency} content_dir)
        ans(dependency_content_dir)

        path_qualify_from("${dependency_content_dir}" "${relative_target}")
        ans(target)
        ## creates or destroys the link
        if(unlink)
         log("unlinking '${link}' from '${target}' ({package.uri})" --function package_dependency_symlinker)
          unlink("${link}")
        else()
          ## ensure that directory exists
          get_filename_component(dir "${link}" PATH)
          if(NOT EXISTS "${dir}")
            mkdir("${dir}")
          endif()
          log("linking '${link}' to '${target}' ({package.uri})" --function package_dependency_symlinker)
          ln("${target}" "${link}")
          ans(success)
          if(NOT success)
           error("failed to link '${link}' to '${target}' ({package.uri})" --function package_dependency_symlinker)
          endif()
        endif()

      endforeach()
    endif()
  endforeach()
endfunction()



# File: source/package/project/project_close.cmake

## `(<project handle>)-><project file:<path>>`
##
## closes the specified project.  All eventhandlers will be notified will emit their own events as well.
## after the project is closed it SHOULD NOT be modified.
##
## **events**
##  * `project_on_closing(<project handle>)`
##  * `project_on_close(<project handle>)`
##  * `project_on_closed(<project handle>)`
function(project_close project_handle)
  project_state_assert("${project_handle}" "opened")

  event_emit(project_on_closing ${project_handle})

  map_tryget(${project_handle} content_dir)
  ans(project_content_dir)

  event_emit(project_on_close ${project_handle})

  pushd("${project_content_dir}" --create)

    ## ensure portability by removing content_dir which is an absolute path
    assign(package_handles = project_handle.project_descriptor.package_materializations)
    map_values(${package_handles})
    ans(package_handles)

    foreach(package_handle ${package_handles})
      map_remove(${package_handle} content_dir)
    endforeach()

    assign(project_file = project_handle.project_descriptor.project_file)
    path_qualify(project_file)

    map_remove("${project}" content_dir)

  popd()

  project_state_change("${project_handle}" "closed")

  event_emit(project_on_closed ${project_handle})

  project_state_assert("${project_handle}" "^closed$")
  return_ref(project_file)
endfunction()


# File: source/package/project/project_open.cmake

## `(<content_dir> [<~project handle>])-><project handle>` 
##
## opens the specified project by setting default values for the existing or new project handle and setting its content_dir property to the fully qualified path specified.
## if no project handle was given a new one is created.
## if the state of the project handle is `unknown` it was never opened before. It is first transitioned to `closed` after emitting the `project_on_new` event.
## then the project handle is transitioned from `closed` to `open` first the `project_on_opening` event is emitted followed by `project_on_open`.  Afterwards the state is changed to `open` and then the `project_on_opened` event us emitted.  
## returns the project handle of the project on success. fails if the project handle is in a state other than `unknown` or `closed`. 
## 
## *note* that the default project does not contain a package source. it will have to be configured once manually for every new project
##
##
## **events**
##  * `project_on_new(<project handle>)`
##  * `project_on_opening(<project handle>)`
##  * `project_on_open(<project handle>)`
##  * `project_on_opened(<project handle>)`
##  * `project_on_state_enter(<project handle>)`
##  * `project_on_state_leave(<project handle>)`
##  * extensions also emit events.
##
## **assumes** 
## * `project_handle.project_descriptor.state` is either `unknown`(null) or `closed`
## 
## **ensures**
## * `content_dir` is set to the absolute path of the project
## * `project_descriptor.state` is set to `open`
function(project_open content_dir)
  set(args ${ARGN})

  ## try to parse args as structured data
  obj("${args}")
  ans(project_handle)

  ## fill out default necessary values
  project_handle_default()
  ans(project_handle_defaults)
  map_defaults("${project_handle}" "${project_handle_defaults}")
  ans(project_handle)

  ## set content dir
  path_qualify(content_dir)
  map_set(${project_handle} content_dir "${content_dir}")


  ## setup scope
  set(project_dir "${content_dir}")
  

  ## emit events


  ## if project is new emit that event
  project_state_matches("${project_handle}" "^(unknown)$")
  ans(is_new)
  if(is_new)
    event_emit(project_on_new ${project_handle})
    project_state_change("${project_handle}" closed)
  endif()

  
  ## open starting
  event_emit(project_on_opening ${project_handle})
  
  ## open
  event_emit(project_on_open ${project_handle})
  project_state_change("${project_handle}" opened)

  project_state_assert("${project_handle}" "^(opened)$")
  ## open complete
  event_emit(project_on_opened ${project_handle})

  return_ref(project_handle)
endfunction()

# File: source/package/project/project_read.cmake

## `(<package handle> | <project dir> | <project file>)-><project handle>`
## 
##  Opens a project at `<project dir>` which defaults to the current directory (see `pwd()`). 
##  If a project file is specified it is openend and the project dir is derived.  
## 
##  Checks wether the project is consistent and if not acts accordingly. Loads the project and all its dependencies
##  also loads all materialized packages which are not part of the project's dependency graph
## 
## **returns** 
## * `<project handle>` the handle to the current project (contains the `project_descriptor`) 
## 
## **events**
## * `project_on_opening(<project handle>)` emitted when the `<project handle>` exists but nothing is loaded yet
## * `project_on_open(<project handle>)` emitted  so that custom handlers can perform actions like loading, initializing, etc
## * `project_on_opened(<project handle>)` emitted after the project was checked and loaded
## * events have access to the follwowing in their scope: 
##   * `project_dir:<qualified path>` the location of this projects root directory
##   * `project_handle:<project handle>` the handle to the project 
function(project_read)
  project_constants()
  path("${ARGN}")
  ans(location)
  if(EXISTS "${location}" AND NOT IS_DIRECTORY "${location}")
    set(project_file "${location}")
  else()    
    file_find_anchor("${project_constants_project_file}" ${location})
    ans(project_file)
  endif()

  if(NOT project_file)
    error("no project file found for location '{location}' " --function project_read)
    creturn()
  endif()


  fread_data("${project_file}")
  ans(project_handle)

  if(NOT project_handle)
    error("not a valid project file '{project_file}' " --function project_read)
    creturn()
  endif()


  ## derive content dir from configured relative project file path
  assign(project_file_path = project_handle.project_descriptor.project_file)
  if(NOT project_file_path)
    error("project_descriptor.project_file is missing" --function project_read)
    creturn()
  endif()
  string_remove_ending("${project_file}" "/${project_file_path}")
  ans(content_dir)


  project_open("${content_dir}" "${project_handle}")
  ans(project_handle)



  return_ref(project_handle)
endfunction()


# File: source/package/project/project_write.cmake

## `(<project handle>)-><path>`
##
## saves the project to the configure project file.
## the project will be closed after it was written.
## returns the path of the qualified file were the project was written to
function(project_write project_handle)
  project_close("${project_handle}")
  ans(project_file)
  fwrite_data("${project_file}" "${project_handle}")
  return_ref(project_file)
endfunction() 

# File: source/package/project/utility/project_constants.cmake

## `()->() *package constants are set` 
##
## defines constants which are used in project management
macro(project_constants)
  if(NOT __project_constants_loaded)
    set(__project_constants_loaded true)
    set(project_constants_dependency_dir "packages")
    set(project_constants_config_dir ".cps")
    set(project_constants_project_file "${project_constants_config_dir}/project.scmake")



  endif()
endmacro()



# File: source/package/project/utility/project_descriptor_new.cmake



function(project_descriptor_new)

  map_new()
  ans(package_handle)
  map_set(${package_handle} uri "project")
  map_new()
  ans(package_descriptor)
  map_set(${package_handle} package_descriptor ${package_descriptor})
  map_new()
  ans(package_dependencies)
  map_set(${package_descriptor} dependencies ${package_dependencies})


  foreach(arg ${ARGN})
    if("${arg}" MATCHES "!(.+)")
      map_set("${package_dependencies}" "${CMAKE_MATCH_1}" false)
    else()
      map_set("${package_dependencies}" "${arg}" true)
    endif()
  endforeach()
  return_ref(package_handle)
endfunction()

# File: source/package/project/utility/project_handle_default.cmake


## `()-><project handle>`
## 
## creates the default project handle:
## ```
## {
##   uri:'project:root',
##   package_descriptor: {}
##   project_descriptor: {
##     package_cache:{}
##     package_materializations:{}
##     dependency_configuration:{}
##     dependency_dir: '${project_constants_dependency_dir}'
##     config_dir: "${project_constants_config_dir}"
##     project_file: "${project_constants_project_file}"
##     package_descriptor_file: <null>
##   }
## }
## ```
function(project_handle_default)
  project_constants()

  map_new()
  ans(package_descriptor)
  map_new()
  ans(project_descriptor)
  map_new()
  ans(package_cache)
  map_new()
  ans(package_materializations)
  map_new()
  ans(dependency_configuration)
  map_set(${project_descriptor} package_cache ${package_cache})
  map_set(${project_descriptor} package_materializations ${package_materializations})
  map_set(${project_descriptor} dependency_configuration ${dependency_configuration})
  map_set(${project_descriptor} dependency_dir "${project_constants_dependency_dir}")
  map_set(${project_descriptor} config_dir "${project_constants_config_dir}")
  map_set(${project_descriptor} project_file "${project_constants_project_file}")

  map_new()
  ans(project_handle)
  map_set(${project_handle} uri "project:root")
  map_set(${project_handle} package_descriptor "${package_descriptor}")
  map_set(${project_handle} project_descriptor "${project_descriptor}")
  
  return_ref(project_handle)
endfunction()

# File: source/package/project/utility/project_install.cmake

## `()->`
##
## performs the install operation which first optionally changes the dependencies and then materializes
function(project_install project_handle)
  set(args ${ARGN})
  project_change_dependencies(${project_handle} ${args})
  ans(changeset)
 

  project_materialize_dependencies(${project_handle})
  ans(changes_handles)
  
  creturn(${changeset})
endfunction()

# File: source/package/require_package_binary.cmake

# if(NOT EXISTS "${soci_path}")
#   message("getting package soci")
#   pull_package("github:soci/soci" external/soci)  
# endif()

# `(<uri> <cmake config args>...)-> <path>`
# loads and builds the specified package.  returns the path where to where the package was installed.
#  
function(require_package_binary package_uri package_path)
  path("${package_path}")
  ans(package_path)
  # message("resolving '${package_uri}'...")
  # resolve_package("${package_uri}")
  # ans(pkg)

  # if(NOT pkg)
  #   message("could not resolve '${package_uri}'")
  #   creturn()
  # endif()

  # map_tryget("${pkg}" package_descriptor)
  # ans(pd)
  # map_tryget("${pd}" id)
  # ans(package_id)


  # path("${package_id}")
  # ans(package_path)


  if(NOT EXISTS "${package_path}")
    pull_package("${package_uri}" "${package_path}")
  endif()

  pushd("${package_path}" --create)
  

  #pushd("${package_id}" --create)
  if(NOT EXISTS "${package_path}/build")
    mkdir("build")
    pushd("build")

    message("package is not built... building")
    cmake(.. ${ARGN} -DCMAKE_INSTALL_PREFIX=stage --passthru)
    cmake(--build . --target install --config Release --passthru)
    cmake(--build . --target install --config Debug --passthru)
 
    message("done building ${package_id}")


    popd()

  endif()


  popd()

  set(package_stage_dir "${package_path}/build/stage")
  message("result is at ${package_stage_dir}")
  return_ref(package_stage_dir)



endfunction()

function(require_package_headeronly package_uri package_path)
   path("${package_path}")
  ans(package_path)


  if(NOT EXISTS "${package_path}")
    pull_package("${package_uri}" "${package_path}")
  endif()

  pushd("${package_path}" --create)
  #...
  popd()

  set(package_stage_dir "${package_path}")
  message("result is at ${package_stage_dir}")
  return_ref(package_stage_dir)



endfunction()

# File: source/package/scaffold.cmake

function(scaffold)
  
  message(INFO "not implemented")


endfunction()

# File: source/package/state/project_state.cmake


function(project_state project_handle)
  set(new_state ${ARGN})
  if(new_state)
    project_state_change("${project_handle}" "${new_state}")
    ans(state)
  else()
    project_state_get("${project_handle}")
    ans(state)
  endif()
  return_ref(state)
endfunction()



# File: source/package/state/project_state_assert.cmake


function(project_state_assert project_handle)
  project_state_matches("${project_handle}" "${ARGN}")  
  ans(is_match)
  if(NOT is_match)
    message(FATAL_ERROR FORMAT "invalid project state (expected '${ARGN}' actual '{project_handle.project_descriptor.state}')")
  endif()
endfunction()


# File: source/package/state/project_state_change.cmake


function(project_state_change project_handle new_state)
  project_state_get("${project_handle}")
  ans(old_state)
  if("${old_state}_" STREQUAL "${new_state}_")
    return_ref(old_state)
  endif()
  if("${old_state}_" STREQUAL "invalid_")
    message(FATAL_ERROR "invalid state")
  endif()
  set(current_state "${old_state}")
  event_emit(project_on_state_leave ${project_handle} ${old_state} ${new_state})
  assign(!project_handle.project_descriptor.state = new_state)
  set(current_state "${new_state}")
  event_emit(project_on_state_enter ${project_handle} ${old_state} ${new_state})
  return_ref(old_state)
endfunction()


# File: source/package/state/project_state_get.cmake


function(project_state_get project_handle)
  if(NOT project_handle)
    creturn(invalid)
  endif()
  assign(state = project_handle.project_descriptor.state)
  if("${state}_" STREQUAL "_")
    creturn(unknown)
  endif()
  return_ref(state)
endfunction()


# File: source/package/state/project_state_matches.cmake



function(project_state_matches project_handle expected_state)
  project_state("${project_handle}")
  ans(actual_state)
  if("${actual_state}" MATCHES "${expected_state}")
    creturn(true)
  endif()
  creturn(false)
endfunction()


# File: source/parser/parse_any.cmake

  function(parse_any rstring)
    # get defintiions for any
    map_get(${definition} any)
    ans(any)

    is_address("${any}")
    ans(isref)
    if(isref)
      address_get(${any})
      ans(any)
    endif()
    # loop through defintions and take the first one that works
    foreach(def_id ${any})
      parse_string("${rstring}" "${def_id}")
      ans(res)

      list(LENGTH res len)
      if("${len}" GREATER 0)
        return_ref(res)
      endif()

    endforeach()

    # return nothing if nothing matched
    creturn()
  endfunction()


# File: source/parser/parse_many.cmake


  function(parse_many rstring)
    map_tryget(${definition} begin)
    ans(begin)
    map_tryget(${definition} end)
    ans(end)
    map_tryget(${definition} element)
    ans(element)
    map_tryget(${definition} separator)
    ans(separator)         

    # create copy of input string
    address_get(${rstring})
    ans(str)
    address_set_new("${str}")
    ans(str)

    if(begin)
      parse_string(${str} ${begin})
      ans(res)
      list(LENGTH res len)
      if(${len} EQUAL 0)
        creturn()
      endif()
    endif()
    set(result_list)
    while(true)

      # try to parse end of list if it was parsed stop iterating
      if(end)
        parse_string(${str} ${end})
        ans(res)
        list(LENGTH res len)
        if(${len} GREATER 0)
          break()
        endif()
      endif()

      if(separator)
        if(result_list)
          parse_string(${str} ${separator})
          ans(res)
          list(LENGTH res len)
          if(${len} EQUAL 0)
            if(NOT end)
              break()
            endif()
            creturn()
          endif()
        endif()
      endif()

      parse_string("${str}" "${element}")
      ans(res)
      list(LENGTH res len)
      if(${len} EQUAL 0)
        if(NOT end)
          break()
        endif()
        creturn()
      endif()
      
      list(APPEND result_list "${res}")
    endwhile()    

    # set rstring
    address_get(${str})
    ans(str)
    address_set(${rstring} "${str}")
    
    list(LENGTH return_list len)
    if(NOT len)
      #creturn("")
    endif()
    return_ref(result_list)
  endfunction()


# File: source/parser/parse_match.cmake


  function(parse_match rstring)
    address_get(${rstring})
    ans(str)

    map_get(${definition} search)
    ans(search)

   # message("parsing match with '${parser_id}' (search: '${search}') for '${str}'")
    map_tryget(${definition} ignore_regex)
    ans(ignore_regex)
   #message("ignore: ${ignore_regex}")
    list(LENGTH ignore_regex len)
    if(len)
     # message("ignoring ${ignore_regex}")
        string_take_regex(str "${ignore_regex}")
    endif()

    string_take(str "${search}")
    ans(match)

    if(NOT match)
      creturn()
    endif()

    address_set(${rstring} "${str}")

    return_ref(match)
  endfunction()

# File: source/parser/parse_object.cmake


function(parse_object rstring)
  
    # create a copy from rstring 
    address_get(${rstring})
    ans(str)
    address_set_new("${str}")
    ans(str)

    # get definitions
    map_tryget(${definition} begin)
    ans(begin_id)

    map_tryget(${definition} end)
    ans(end_id)
    
    map_tryget(${definition} keyvalue)
    ans(keyvalue_id)

    map_tryget(${definition} separator)
    ans(separator_id)         

    if(begin_id)
      parse_string(${str} ${begin_id})
      ans(res)
      list(LENGTH res len)
      if(${len} EQUAL 0)
        creturn()
      endif()
    endif()

    map_new()
    ans(result_object)

    set(has_result)

    while(true)
      # try to parse end of list if it was parsed stop iterating
      if(end_id)
        parse_string(${str} "${end_id}")
        ans(res)

        list(LENGTH res len)
        if(${len} GREATER 0)
          break()
        endif()
      endif()

      if(separator_id)
        if(has_result)
          parse_string(${str} "${separator_id}")
          ans(res)
          list(LENGTH res len)
          if(${len} EQUAL 0)
            if(NOT end)
              break()
            endif()
            creturn()
          endif()
        endif()
      endif()

      parse_string(${str} "${keyvalue_id}")
      ans(keyvalue)

      if(NOT keyvalue)
        if(NOT end)
          break()
        endif()
        creturn()
      endif()

      map_get(${keyvalue} key)
      ans(object_key)

      map_get(${keyvalue} value)
      ans(object_value)

      if(NOT has_result)
        set(has_result true)
      endif()

      if("${object_value}_" STREQUAL "_")
        
        set(object_value "")
      endif()
      
      map_set("${result_object}" "${object_key}" "${object_value}")

    endwhile()    


    # if every element was  found set rstring to rest of string
    address_get(${str})
    ans(str)
    address_set(${rstring} "${str}")

    # return result
    return_ref(result_object)
endfunction()

# File: source/parser/parse_ref.cmake

 function(parse_ref rstring)
    address_get(${rstring})
    ans(str)
    string_take_regex(str ":[a-zA-Z0-9_-]+")
    ans(match)
    if(NOT DEFINED match)
      creturn()
    endif()
  #  message("match ${match}")
    is_address("${match}")
    ans(isvalid)

    if(NOT  isvalid)
      creturn()
    endif()



    map_tryget(${definition} matches)
    ans(matches)
    #json_print(${matches})
    is_map(${matches})
    ans(ismap)

    if(NOT ismap)
      address_get(${match})
      ans(ref_value)

      if("${matches}" MATCHES "${ref_value}")
        return_ref(match)
      endif()
      creturn()
    else()
      map_keys(${matches})
      ans(keys)
      foreach(key ${keys})
        map_tryget(${match} "${key}")
        ans(val)

        map_tryget(${matches} "${key}")
        ans(regex)

        if(NOT "${val}" MATCHES "${regex}")
          creturn()
        endif()
      endforeach()
    endif()
    address_set(${rstring} "${str}")
    return_ref(match)
  endfunction()

# File: source/parser/parse_regex.cmake


  function(parse_regex rstring)
    # deref rstring
    address_get(${rstring})
    ans(str)
   # message("string ${str}")
    # get regex from defintion
    map_get(${definition} regex)
    ans(regex)
   # message("${regex}")

 #   message("parsing '${parser_id}' parser (regex: '${regex}') for '${str}'")
    # try to take regex from string
    
    map_tryget(${definition} ignore_regex)
    ans(ignore_regex)
   # message("ignore: ${ignore_regex}")
    list(LENGTH ignore_regex len)
    if(len)
   # message("ignoring ${ignore_regex}")
        string_take_regex(str "${ignore_regex}")
    endif()
#   message("str is '${str}'")
    string_take_regex(str "${regex}")
    ans(match)

    #message("match ${match}")
    # if not success return
    list(LENGTH match len)
    if(NOT len)
      creturn()
    endif()
 #   message("matched '${match}'")

    map_tryget(${definition} replace)
    ans(replace)
    if(replace)        
        string_eval("${replace}")
        ans(replace)
        #message("replace ${replace}")
        string(REGEX REPLACE "${regex}" "${replace}" match "${match}")
        #message("replaced :'${match}'")

    endif()

    map_tryget(${definition} transform)
    ans(transform)
    if(transform)
        #message("transforming ")
        call("${transform}"("match"))
        ans(match)
    endif()

    if("${match}_" STREQUAL "_")
        set(match "")
    endif()
    # if success set rstring to rest of string
    address_set(${rstring} "${str}")

    # return matched element
    return_ref(match)
  endfunction()

# File: source/parser/parse_sequence.cmake


  function(parse_sequence rstring) 
    # create a copy from rstring 
    address_get(${rstring})
    ans(str)
    address_set_new("${str}")
    ans(str)

    # get sequence definitions
    map_get(${definition} sequence)
    ans(sequence)

    map_keys(${sequence})
    ans(sequence_keys)

    function(eval_sequence_expression rstring key res_map expression set_map)
      is_map("${expression}")
      ans(ismap)

      if(ismap)
        map_new()
        ans(definition)

        map_set(${definition} "parser" "sequence")
        map_set(${definition} "sequence" "${expression}")
        
#        json_print(${definition})
        parse_sequence("${rstring}")
        ans(res)

        if("${res}_" STREQUAL "_")
          creturn(false)
        endif()

        map_set(${result_map} "${key}" ${res})
        map_set(${set_map} "${key}" true)
        creturn(true)

      endif()      



      #message("Expr ${expression}")
      if("${expression}" STREQUAL "?")
        creturn(true)
      endif()
      # static value
      if("${expression}" MATCHES "^@")
        string(SUBSTRING "${expression}" 1 -1 expression)
        map_set("${res_map}" "${key}" "${expression}")
        creturn(true)
      endif()
      
      # null coalescing
      if("${expression}" MATCHES "[^@]*\\|")
        string_split_at_first(left right "${expression}" "|")
        eval_sequence_expression("${rstring}" "${key}" "${res_map}" "${left}" "${set_map}")
        ans(success)
        if(success)
          creturn(true)
        endif()
       # message("parsing right")
        eval_sequence_expression("${rstring}" "${key}" "${res_map}" "${right}" "${set_map}")
        return_ans()
      endif()

      # ternary operator ? :
      if("${expression}" MATCHES "[a-zA-Z0-9_-]+\\?.+")
        string_split_at_first(left right "${expression}" "?")
        set(else)
        if(NOT "${right}" MATCHES "^@")
          string_split_at_first(right else "${right}" ":")
        endif()
        map_tryget(${set_map} "${left}")
        ans(has_value)
        if(has_value)
          eval_sequence_expression("${rstring}" "${key}" "${res_map}" "${right}" "${set_map}")
          ans(success)
          if(success)
            creturn(true)
          endif()
          creturn(false)
        elseif(DEFINED else)
          eval_sequence_expression("${rstring}" "${key}" "${res_map}" "${else}" "${set_map}")
          ans(success)
          if(success)
            creturn(true)
          endif()

          creturn(false)
        else()
          creturn(true)
        endif()

      endif() 



      set(ignore false)
      set(optional false)
      set(default)


      if("${expression}" MATCHES "^\\?")
        string(SUBSTRING "${expression}" 1 -1 expression)
        set(optional true)
      endif()
      if("${expression}" MATCHES "^/")
        string(SUBSTRING "${expression}" 1 -1 expression)
        set(ignore true)
      endif()


      parse_string("${rstring}" "${expression}")
      ans(res)

      list(LENGTH res len)


      if(${len} EQUAL 0 AND NOT optional)
        creturn(false)
      endif()

      if(NOT "${ignore}" AND DEFINED res)
   #     message("setting at ${key}")
        map_set("${res_map}" "${key}" "${res}")
      endif()
      
      if(NOT ${len} EQUAL 0)
        map_set(${set_map} "${key}" "true")

      endif()
      creturn(true)
    endfunction()

    # match every element in sequence
    map_new()
    ans(result_map)

    map_new()
    ans(set_map)


    foreach(sequence_key ${sequence_keys})

      map_tryget("${sequence}" "${sequence_key}")
      ans(sequence_id)

      eval_sequence_expression("${str}" "${sequence_key}" "${result_map}" "${sequence_id}" "${set_map}")
      ans(success)
      if(NOT success)
        creturn()
      endif()
    endforeach()




    # if every element was  found set rstring to rest of string
    address_get(${str})
    ans(str)
    address_set(${rstring} "${str}")

    # return result
    return_ref(result_map)
  endfunction()



#    foreach(sequence_key ${sequence_keys})
#
#      map_tryget("${sequence}" "${sequence_key}")
#      ans(sequence_id)
#
#      if("${sequence_id}" MATCHES "^@")
#        string(SUBSTRING "${sequence_id}" 1 -1 sequence_id)
#        map_set("${result_map}" "${sequence_key}" "${sequence_id}")
#     
#      else()
#        set(ignore false)
#        set(optional false)
#        if("${sequence_id}" MATCHES "^\\?")
#          string(SUBSTRING "${sequence_id}" 1 -1 sequence_id)
#          set(optional true)
#        endif()
#        if("${sequence_id}" MATCHES "^/")
#          string(SUBSTRING "${sequence_id}" 1 -1 sequence_id)
#          set(ignore true)
#        endif()
#
#
#        parse_string("${str}" "${sequence_id}")
#        ans(res)
#
#        list(LENGTH res len)
#
#
#        if(${len} EQUAL 0 AND NOT optional)
#          creturn()
#        endif()
#
#        if(NOT "${ignore}")
#          map_set("${result_map}" "${sequence_key}" "${res}")
#        endif()
#      endif()
#    endforeach()

# File: source/parser/parse_string.cmake

  function(parse_string rstring definition_id)
    # initialize
    if(NOT __parse_string_initialized)
      set(args ${ARGN})
      set(__parse_string_initialized true)
      list_extract(args definitions parsers language)
      function_import_table(${parsers} __call_string_parser)
    endif()

    # 
    map_get("${definitions}" "${definition_id}")
    ans(definition)
    
    #
    map_get("${definition}" parser)
    ans(parser_id)
    
    #
  #  message(FORMAT "${parser_id} parser parsing ${definition_id}..")
    message_indent_push()
    __call_string_parser("${parser_id}" "${rstring}")
    ans(res)
    message_indent_pop()
   # message(FORMAT "${parser_id} parser returned: ${res} rest is")
   #list(LENGTH res len)
 #  if(len)
   #  message("parsed '${res}' with ${parser_id} parser")
   #endif()   
    return_ref(res)
  endfunction()

# File: source/persistence/fallback_data/fallback_data_get.cmake


  function(fallback_data_get dirs id)
    set(res)
    foreach(dir ${dirs})
      file_data_get("${dir}" "${id}" ${ARGN})
      ans(res)
      if(res)
        break()
      endif()
    endforeach()
    return_ref(res)
  endfunction()

# File: source/persistence/fallback_data/fallback_data_read.cmake





  function(fallback_data_read dirs id)    
    set(maps )
    foreach(dir ${dirs})
      file_data_read("${dir}" "${id}")
      ans(res)
      list(APPEND maps "${res}")
    endforeach()
    list(REVERSE maps)
    map_merge(${maps})
    ans(res)
    return_ref(res)
  endfunction()


# File: source/persistence/fallback_data/fallback_data_set.cmake



  function(fallback_data_set dirs id nav)
    list_pop_front(dirs)
    ans(dir)

    file_data_set("${dir}" "${id}" "${nav}" ${ARGN})
    return_ans()
  endfunction()

# File: source/persistence/fallback_data/fallback_data_source.cmake

## returns the source dir for the specified navigation argument
function(fallback_data_source dirs id)
  set(res)
  foreach(dir ${dirs})
    file_data_get("${dir}" "${id}" ${ARGN})
    ans(res)
    if(res)
      return_ref(dir)
    endif()
  endforeach()
  creturn()
endfunction()

# File: source/persistence/file_data/file_anchor_require_dir.cmake


function(file_anchor_require_dir anchorName)
  file_find_anchor(.packages)
  ans(packageAnchor)

  if("${packageAnchor}_" STREQUAL "_")
    path(".packages")
    ans(packageAnchor)
    mkdir("${packageAnchor}")
  endif()

  return_ref(packageAnchor) 
endfunction()


# File: source/persistence/file_data/file_data_clear.cmake



function(file_data_clear dir id)
  file_data_path("${dir}" "${id}")
  ans(path)
  if(NOT EXISTS "${path}")
    creturn(false)
  endif()
  rm("${path}")
  creturn(true)
endfunction()

# File: source/persistence/file_data/file_data_dir.cmake


## returns all identifiers for specified file data directory
function(file_data_ids dir)
  path("${dir}")
  ans(dir)
  glob("${dir}/*.cmake")

  ans(files)
  set(keys)
  foreach(file ${files})
    path_component("${file}" --file-name)
    ans(key)
    list(APPEND keys "${key}")
  endforeach()
  return_ref(keys)
endfunction()

# File: source/persistence/file_data/file_data_get.cmake



function(file_data_get dir id)
  set(nav ${ARGN})
  file_data_read("${dir}" "${id}")
  ans(res)
  if("${nav}_" STREQUAL "_" OR "${nav}_" STREQUAL "._")
    return_ref(res)
  endif()
  nav(data = "res.${nav}")
  return_ref(data)
endfunction()

# File: source/persistence/file_data/file_data_path.cmake




function(file_data_path dir id)
  path("${dir}/${id}.cmake")
  ans(path)
  return_ref(path)    
endfunction()

# File: source/persistence/file_data/file_data_read.cmake



function(file_data_read dir id)
  file_data_path("${dir}" "${id}")      
  ans(path)
  if(NOT EXISTS "${path}")
    creturn()
  endif()
  qm_read("${path}")
  return_ans()
endfunction()


# File: source/persistence/file_data/file_data_set.cmake



function(file_data_set dir id nav)
  set(args ${ARGN})

  if("${nav}" STREQUAL "." OR "${nav}_" STREQUAL "_")
    file_data_write("${dir}" "${id}" ${ARGN})
    return_ans()
  endif()
  file_data_read("${dir}" "${id}")
  ans(res)
  map_navigate_set("res.${nav}" ${ARGN})
  file_data_write("${dir}" "${id}" ${res})
  return_ans()
endfunction()


   
  

# File: source/persistence/file_data/file_data_write.cmake




function(file_data_write dir id)
  file_data_path("${dir}" "${id}")
  ans(path)
  qm_write("${path}" ${ARGN})
  return_ref(path)
endfunction()

# File: source/persistence/file_data/file_data_write_obj.cmake


  ## same as file_data_write except that an <obj> is parsed 
  function(file_data_write_obj dir id obj)
    obj("${obj}")
    ans(obj)
    file_data_write("${dir}" "${id}" "${obj}")
    return_ans()
  endfunction()


# File: source/persistence/file_data/file_find_anchor.cmake

## `(<search file:<file name>> [<location:<path>>])-><path>|<null>`
##
## an anchor file is what I call a file that exists somewhere in the
## specified location, any parent directory, or in the current directory
## for example git normally uses an anchorfile in every repository
## (in that cast the `.git` folder)
## also alot of projects use a local file system and in the project;'s
## root folder there exists an anchor file e.g. `.cps` `.cps/project.scmake` 
##
function(file_find_anchor search_file)
  set(search ${ARGN})
  path("${search}")
  ans(search)
  set(current_path "${search}")
  set(last_path)
  while(true)
    if("${last_path}_" STREQUAL "${current_path}_")
      creturn()
    endif()
    set(anchor_file "${current_path}/${search_file}")
    if(EXISTS "${anchor_file}")
      break()
    endif()
    set(last_path "${current_path}")
    path_parent_dir("${current_path}")
    ans(current_path)
  endwhile()
  return_ref(anchor_file)
endfunction()


# File: source/persistence/indexed/indexed_store.cmake


  function(indexed_store store_dir)
    path_qualify(store_dir)
    ans(store_dir)

    map_new()
    ans(this)
    assign(this.store_dir = store_dir)
    assign(this.save = 'indexed_store_save')
    assign(this.load = 'indexed_store_load')
    assign(this.index_add = 'indexed_store_index_add')
    assign(this.find_keys = 'indexed_store_find_keys')
    assign(this.find = 'indexed_store_find')
    assign(this.delete = 'indexed_store_delete')
    assign(this.list = 'indexed_store_list')
    assign(this.keys = 'indexed_store_keys')
    assign(this.key = '')
    creturn(${this})
  endfunction()


  function(indexed_store_list)
    indexed_store_keys()
    ans(keys)
    set(itms)
    foreach(key ${keys})
      indexed_store_load(${key})
      ans_append(itms)
    endforeach()
    return_ref(itms)
  endfunction()



# File: source/persistence/indexed/indexed_store_delete.cmake


function(indexed_store_delete)
  set(key ${ARGN})
  this_get(store_dir)
  file(GLOB files "${store_dir}/*${key}*")
  if(NOT files)
    creturn(false)
  endif()
  file(REMOVE ${files})
  creturn(true)
endfunction()




# File: source/persistence/indexed/indexed_store_find.cmake


  function(indexed_store_find)
    indexed_store_find_keys("${ARGN}")
    ans(keys)
    set(result)
    foreach(key ${keys})
      assign(result[] = this.load("${key}"))
    endforeach()
    return_ref(result)
  endfunction()

# File: source/persistence/indexed/indexed_store_find_keys.cmake


  function(indexed_store_find_keys)
    set(keys)
    this_get(store_dir)

    set(globs)
    foreach(query ${ARGN})
      checksum_string("${query}")
      ans(hash)
      list(APPEND globs "${store_dir}/${hash}*")
    endforeach()
    if(NOT globs)
      creturn()
    endif()

    file(GLOB store_keys RELATIVE "${store_dir}" ${globs})
    string(REGEX REPLACE "([a-fA-F0-9]+)-([a-fA-F0-9]+)-([a-fA-F0-9]+)" "\\2" keys "${store_keys}")
  
    list_remove_duplicates(keys)
    return_ref(keys)
  endfunction()
  

# File: source/persistence/indexed/indexed_store_index_add.cmake




  function(indexed_store_index_add)
    obj("${ARGN}")
    ans(index)
    if(NOT index)
      map_new()
      ans(index)
      map_set(${index} name "${ARGN}")
      set(selector "[]() ref_nav_get({{ARGN}} '${ARGN}')")
    else()
      map_tryget(${index} selector)
      ans(selector)
    endif()  
    callable("${selector}")
    ans(selector)
    map_set(${index} selector "${selector}")
    assign(this.indices[] = index)
    return_ref(index)
  endfunction()

# File: source/persistence/indexed/indexed_store_keys.cmake


function(indexed_store_keys)
  this_get(store_dir)
  file(GLOB keys RELATIVE "${store_dir}" "${store_dir}/*" )
  string(REGEX REPLACE "[a-fA-F0-9]+-([a-fA-F0-9]+)-[a-fA-F0-9]+" "\\1" keys "${keys}")
  
  list_remove_duplicates(keys)
  return_ref(keys)
endfunction()

# File: source/persistence/indexed/indexed_store_load.cmake


function(indexed_store_load )
  set(key ${ARGN})
  this_get(store_dir)
  set(path "${store_dir}/${key}-${key}-${key}")
  if(NOT EXISTS "${path}")
    creturn()
  endif()
  cmake_read("${path}")
  return_ans()

endfunction()

# File: source/persistence/indexed/indexed_store_save.cmake


  function(indexed_store_save )
    this_get(indices)
    this_get(store_dir)
    cmake_serialize("${ARGN}")
    ans(serialized)

    this_get(key)
    if(key)
      call2("${key}" ${ARGN})
      ans(key_value)
      checksum_string("${key_value}")
      ans(key)
    else()
      checksum_string("${serialized}")
      ans(key)
    endif()


    set(store_key "${key}-${key}-${key}")
    fwrite("${store_dir}/${store_key}" "${serialized}")
    foreach(index ${indices})
      map_get(${index} name)
      ans(name)
      map_get(${index} selector)
      ans(selector)
      call2("${selector}" "${ARGN}")
      ans(value)
      if(NOT "${value}_" STREQUAL "_")
        checksum_string("${name}==${value}")
        ans(hash)
        checksum_string("${name}")
        ans(index_hash)
        set(index_key "${store_dir}/${hash}-${key}-${index_hash}")
        fwrite("${index_key}" "${value}")
      endif()
    endforeach()
    return_ref(key)
  endfunction()



# File: source/persistence/key_value/key_value_store.cmake


  function(key_value_store key_function)
    set(args ${ARGN})
    list_pop_front(args)
    ans(store_dir)

    path_qualify(store_dir)

    map_new()
    ans(this)

    assign(this.store_dir = store_dir)
    assign(this.save = 'key_value_store_save')
    assign(this.load = 'key_value_store_load')
    assign(this.list = 'key_value_store_list')
    assign(this.keys = 'key_value_store_keys')
    assign(this.delete = 'key_value_store_delete')
    assign(this.key = key_function)
    creturn(${this})
  endfunction()

# File: source/persistence/key_value/key_value_store_delete.cmake


  function(key_value_store_delete key)
    this_get(store_dir)
    if(EXISTS "${store_dir}/${key}")
      rm("${store_dir}/${key}")
      creturn(true)
    endif()
    creturn(false)
  endfunction()

# File: source/persistence/key_value/key_value_store_keys.cmake



  function(key_value_store_keys)
    this_get(store_dir)
    file(GLOB keys RELATIVE "${store_dir}" "${store_dir}/*")
    return_ref(keys)
  endfunction()

# File: source/persistence/key_value/key_value_store_list.cmake



  function(key_value_store_list)
    key_value_store_keys()
    ans(keys)
    set(values)
    foreach(key ${keys})
      key_value_store_load("${key}")
      ans_append(values)
    endforeach()  
    return_ref(values)
  endfunction()

  

# File: source/persistence/key_value/key_value_store_load.cmake


  function(key_value_store_load key)
    this_get(store_dir)
    if(NOT EXISTS "${store_dir}/${key}")
      creturn()
    endif()
    qm_read("${store_dir}/${key}")
    return_ans()
  endfunction()


# File: source/persistence/key_value/key_value_store_save.cmake


  function(key_value_store_save)
    this_get(store_dir)
    assign(key = this.key(${ARGN}))
    qm_write("${store_dir}/${key}" ${ARGN})    
    return_ref(key)
  endfunction()

# File: source/persistence/user_data/user_data_clear.cmake

## signature user_data_clear(<id:identifier>^"--all")
### removes the user data associated to identifier id
## WARNING: if --all flag is specified instead of an id all user data is deleted
## 
function(user_data_clear)
  set(args ${ARGN})
  list_extract_flag(args --all)
  ans(all)
  set(id ${args})
  if(all)
    user_data_ids()
    ans(ids)
    foreach(id ${ids})
      user_data_clear("${id}")
    endforeach()
  endif()
  user_data_path("${id}")
  ans(res)
  if(EXISTS "${res}")
    rm("${res}")
    creturn(true)
  endif()
  creturn(false)
endfunction()


# File: source/persistence/user_data/user_data_dir.cmake

## returns the <qualified directory> where the user data is stored
# this is the home dir/.cmakepp
function(user_data_dir)    
  home_dir()
  ans(home_dir)
  set(storage_dir "${home_dir}/.cmakepp")
  if(NOT EXISTS "${storage_dir}")
    mkdir("${storage_dir}")
  endif()
  return_ref(storage_dir)
endfunction()

# File: source/persistence/user_data/user_data_get.cmake


## returns data (read from storage) for the current user which is identified by <id>
## if no navigation arg is specified then the root data is returned
## else a navigation expression can be specified which returns a specific VALUE
## see nav function
function(user_data_get id)
  set(nav ${ARGN})
  user_data_read("${id}")
  ans(res)
  if("${nav}_" STREQUAL "_" OR "${nav}_" STREQUAL "._")
    return_ref(res)
  endif()
  nav(data = "res.${nav}")
  return_ref(data)
endfunction()

# File: source/persistence/user_data/user_data_ids.cmake

## returns all identifiers for user data
function(user_data_ids)
  user_data_dir()
  ans(dir)
  glob("${dir}/*.cmake")
  ans(files)
  set(keys)
  foreach(file ${files})
    path_component("${file}" --file-name)
    ans(key)
    list(APPEND keys "${key}")
  endforeach()
  return_ref(keys)
endfunction()

# File: source/persistence/user_data/user_data_path.cmake

## returns the user data path for the specified id
## id can be any string that is also usable as a valid filename
## it is located in %HOME_DIR%/.cmakepp
function(user_data_path id)  
  if(NOT id)
    message(FATAL_ERROR "no id specified")
  endif()
  user_data_dir()
  ans(storage_dir)
  set(storage_file "${storage_dir}/${id}.cmake")
  return_ref(storage_file)
endfunction()



# File: source/persistence/user_data/user_data_read.cmake

### returns the user data stored under the index id
## user data may be any kind of data  
function(user_data_read id)
  user_data_path("${id}")
  ans(storage_file)

  if(NOT EXISTS "${storage_file}")
    creturn()
  endif()

  qm_read("${storage_file}")
  return_ans()
endfunction()

# File: source/persistence/user_data/user_data_set.cmake

## sets and persists data for the current user specified by identified by <id> 
## nav can be empty or a "." which will set the data at the root level
## else it can be a navigation expressions which (see map_navigate_set)
## e.g. user_data_set(common_directories cmakepp.base_dir /home/user/mydir)
## results in common_directories to contain
## {
##   cmakepp:{
##     base_dir:"/home/user/mydir"
##   }
## }
function(user_data_set id nav)
  set(args ${ARGN})

  if("${nav}" STREQUAL "." OR "${nav}_" STREQUAL "_")
    user_data_write("${id}" ${ARGN})
    return_ans()
  endif()
  user_data_read("${id}")
  ans(res)
  map_navigate_set("res.${nav}" ${ARGN})
  user_data_write("${id}" ${res})
  return_ans()
endfunction()



# File: source/persistence/user_data/user_data_write.cmake

## writes all var args into user data, accepts any typ of data 
## maps are serialized
function(user_data_write id)
  user_data_path("${id}")
  ans(path)
  qm_write("${path}" ${ARGN})
  return_ans()
endfunction()


# File: source/persistence/user_data/user_data_write_obj.cmake


  ## same as user_data_write except that an <obj> is parsed 
  function(user_data_write_obj id obj)
    obj("${obj}")
    ans(obj)
    user_data_write("${id}" "${obj}")
    return_ans()
  endfunction()



# File: source/platform/windows/bash/win32_bash.cmake

# wraps the the win32 bash shell if available (Cygwin)
function(win32_bash)
  find_package(Cygwin )
  if(NOT Cygwin_FOUND)
    message(FATAL_ERROR "Cygwin was not found on your system")
  endif()
  wrap_exectuable(win32_bash "${Cygwin_EXECUTABLE}")
  win32_bash(${ARGN})
  return_ans()
endfunction()


# File: source/platform/windows/cmd/win32_cmd.cmake

# wraps the win32 console executable cmd.exe
function(win32_cmd)
  wrap_executable(win32_cmd cmd.exe)
  win32_cmd(${ARGN})
  return_ans()
endfunction()



# File: source/platform/windows/cmd/win32_cmd_lean.cmake


function(win32_cmd_lean)
  wrap_executable_bare(win32_cmd_lean cmd.exe)
  win32_cmd_lean(${ARGN})
  return_ans()
endfunction()

# File: source/platform/windows/msi/msi_package_ids.cmake


## `()-><ms guid>`
##
## queries the windows registry for packages installed with msi
## returns their ids (which are microsoft guid)
function(msi_package_ids)
  reg_lean(query "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
  ans_extract(error)
  ans(entries)
  if(error)
    message(FATAL_ERROR "could not query register for msi installed packages")
  endif()
  string(REPLACE "\n" ";" entries "${entries}")
  regex_common()

  set(installations)
  foreach(entry ${entries})
    if("${entry}" MATCHES "\\\\(${regex_guid_ms})$")
      list(APPEND installations "${CMAKE_MATCH_1}")
    endif()
  endforeach()
  return_ref(installations)
endfunction()

# File: source/platform/windows/msi/msiexec.cmake




# wraps the win32 console executable cmd.exe
function(msiexec)
  if(NOT CMAKE_HOST_WIN32)
    message(FATAL_ERROR "not supported on your os - only Windows")
  endif()
  wrap_executable(msiexec msiexec.exe)
  msiexec(${ARGN})
  return_ans()
endfunction()


# File: source/platform/windows/msi/msiexec_lean.cmake


#
function(msiexec_lean)
    if(NOT CMAKE_HOST_WIN32)
    message(FATAL_ERROR "not supported on your os - only Windows")
  endif()

  wrap_executable_bare(msiexec_lean msiexec.exe)
  msiexec_lean(${ARGN})
  return_ans()
endfunction()

# File: source/platform/windows/nuget/nuget.cmake

## ''
##
## wraps nuget inside an easy to use function, downloading it if it does not exist
function(nuget)
  if(NOT CMAKE_HOST_WIN32)
    message(FATAL_ERROR "you currently cannot use nuget on non windows systems")
  endif()

  download_cached("https://dist.nuget.org/win-x86-commandline/latest/nuget.exe" --readonly)
  ans(nuget_exe)

  if(NOT EXISTS "${nuget_exe}")
    message(FATAL_ERROR "nuget.exe could not be located")
  endif()

  wrap_executable(nuget "${nuget_exe}")
  nuget(${ARGN})
  return_ans()
endfunction()  


# File: source/platform/windows/nuget/nuspec.cmake


    function(nuspec package_handle)
        assign(package_handle.package_descriptor.tags = ['a','b'])
        assign(package_handle.package_descriptor.copyright = '2017')
        template_run(
            #<authors>@package_handle.package_descriptor.authors</authors>
    #         <authors>myauthor</authors>
    # <owners>owner</owners>
    # <licenseUrl>http://mylicense</licenseUrl>
    # <projectUrl>http://myproject@package_handle.package_descriptor.project_url</projectUrl>
    # <iconUrl>@package_handle.package_descriptor.icon_url</iconUrl>
#    <description>@package_handle.package_descriptor.description</description>
"<package xmlns=\"http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd\">
  <metadata>
    <id>@package_handle.package_descriptor.id</id>
    <version>@package_handle.package_descriptor.version</version>
    <authors>tobitob</authors>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>some description</description>
    <summary>@package_handle.package_descriptor.summary</summary>
    <releaseNotes>@package_handle.package_descriptor.release_notes</releaseNotes>
    <copyright>@package_handle.package_descriptor.copyright</copyright>
    <tags>@string_combine(' ', $package_handle.package_descriptor.tags)</tags>
  </metadata>  
  <files>
    <file src=\"@package_handle.content_dir/**\" target=\"native\"/>
  </files>
 </package>"
)
        ans(result)
        return_ref(result)        
endfunction()



function(package_source_push_nuget)
     if("${ARGN}" MATCHES "(.*);=>;?(.*)")
        set(source_args "${CMAKE_MATCH_1}")
        set(args "${CMAKE_MATCH_2}")
    else()
        set(source_args ${ARGN})
        set(args)
    endif()

    list_pop_front(source_args)
    ans(source)
        
    ## get target dir
    ## or target uri...
    list_pop_front(args)
    ans(target_dir)
    if(NOT target_dir)
        pwd()
        ans(target_dir)        
    endif()

    path_qualify(target_dir)

    pushtmp()
    ans(tmpdir)

    assign(package_handle = source.pull(${source_args} "${tmpdir}"))


    if(NOT package_handle)
        error("could not pull `${source_args}` ")        
        poptmp()
        creturn()
    endif()

    nuspec(${package_handle})
    ans(nuspec)
    message("tempdir ${tmpdir}")
    message("${nuspec}")
    fwrite("package.nuspec" "${nuspec}")
    message("pack package.nuspec -BasePath \"${tmpdir}\" -OutputDirectory \"${target_dir}\" --passthru")
    nuget(pack package.nuspec -BasePath "${tmpdir}" -OutputDirectory "${target_dir}" --passthru)



    # package handle set uri to nuget file?    



    #poptmp()
popd()

    return_ref(package_handle)

endfunction()


# File: source/platform/windows/powershell/win32_powershell.cmake


  ## wraps the win32 powershell command
  function(win32_powershell)
    wrap_executable(win32_powershell PowerShell)
    win32_powershell(${ARGN})
    return_ans()
  endfunction()


# File: source/platform/windows/powershell/win32_powershell_create_array.cmake


## creates a  powershell array from the specified args
function(win32_powershell_create_array)

    ## compile powershell array for argument list
    set(arg_list)
    foreach(arg ${ARGN})
      string_encode_delimited("${arg}" \")
      ans(arg)
      list(APPEND arg_list "${arg}")
    endforeach()
    string_combine("," ${arg_list})
    ans(arg_list)
    set("${arg_list}" "@(${arg_list})")

    return_ref(arg_list)

endfunction()


# File: source/platform/windows/powershell/win32_powershell_lean.cmake

## wraps the CMAKE_HOST_WIN32 powershell command in a lean wrapper
function(win32_powershell_lean)
  wrap_executable_bare(win32_powershell_lean PowerShell)
  win32_powershell_lean(${ARGN})
  return_ans()
endfunction()


# File: source/platform/windows/powershell/win32_powershell_run_script.cmake


  ## runs the specified code as a powershell script
  ## and returns the result
  function(win32_powershell_run_script code)
    mktemp()
    ans(path)

    fwrite("${path}/script.ps1" "${code}")
    ans(script_file)
    win32_powershell(
      -NoLogo                   # no info output 
      -NonInteractive           # no interaction
      -ExecutionPolicy ByPass   # bypass execution policy 
     # -NoNewWindow              
      #-WindowStyle Hidden       # hide window
      -File "${script_file}"    # the file to execute
      ${ARGN}                   # add further args to command line
      )
    return_ans()
  endfunction()


# File: source/platform/windows/taskkill/win32_taskkill.cmake

# wraps the win32 taskkill command
function(win32_taskkill)
  wrap_executable(win32_taskkill "taskkill")
  win32_taskkill(${ARGN})
  return_ans()
endfunction()

# File: source/platform/windows/tasklist/win32_tasklist.cmake

## wraps the windows task lisk programm which returns process info
function(win32_tasklist)
  wrap_executable(win32_tasklist "tasklist")
  win32_tasklist(${ARGN})
  return_ans()
endfunction()


# File: source/platform/windows/tasklist/win32_tasklist_bare.cmake

## a bare wrapper for tasklist
function(win32_tasklist_bare)
  wrap_executable_bare(win32_tasklist_bare "tasklist")
  win32_tasklist_bare(${ARGN})
  return_ans()
endfunction()


# File: source/platform/windows/wmic/win32_wmic.cmake

## wraps the windows wmic command (windows XP and higher )
# since wmic does outputs unicode and does not take forward slash paths the usage is more complicated 
# and wrap_executable does not work
function(win32_wmic)
  pwd()
  ans(pwd)
  fwrite_temp("")
  ans(tmp)
  file(TO_NATIVE_PATH "${tmp}" out)

  execute_process(COMMAND wmic /output:${out} ${ARGN} RESULT_VARIABLE res WORKING_DIRECTORY "${pwd}")  
  if(NOT "${res}" EQUAL 0 )
    creturn()
  endif()

  fread_unicode16("${tmp}")        
  return_ans()
endfunction()


# File: source/platform/windows/wmic/win32_wmic_call_create.cmake

# returns a <process handle>
# currently does not play well with arguments
function(win32_wmic_call_create command)
  path("${command}")
  ans(cmd)
  pwd()
  ans(cwd)  
  set(args)


  message("cmd ${cmd}")
  file(TO_NATIVE_PATH "${cwd}" cwd)
  file(TO_NATIVE_PATH "${cmd}" cmd)


  if(ARGN)
    string(REPLACE ";" " " args "${ARGN}")
    set(args ",${args}")
  endif()
  win32_wmic(process call create ${cmd},${cwd})#${args}
  ans(res)
  set(pidregex "ProcessId = ([1-9][0-9]*)\;")
  set(retregex "ReturnValue = ([0-9]+)\;")
  string(REGEX MATCH "${pidregex}" pid_match "${res}")
  string(REGEX MATCH "${retregex}" ret_match "${res}")

  string(REGEX REPLACE "${retregex}" "\\1" ret "${ret_match}")
  string(REGEX REPLACE "${pidregex}" "\\1" pid "${pid_match}")
  if(NOT "${ret}" EQUAL 0)
    creturn()
  endif() 
  process_handle(${pid})
  ans(res)
  map_set(${res} status running)
  return_ref(res)
endfunction()

# File: source/process/async.cmake

## async(<callable>(<args...)) -> <process handle>
##
## executes a callable asynchroniously 
##
## todo: 
##   capture necessary scope vars
##   include further files for custom functions     
##   environment vars
  function(async callable)
    cmakepp_config(base_dir)
    ans(base_dir)
    set(args ${ARGN})
    list_pop_front(args)
    list_pop_back(args)
    qm_serialize(${args})
    ans(arguments)
    path_temp()
    ans(result_file)
    pwd()
    ans(pwd)
    set(code
      "
        include(\"${base_dir}/cmakepp.cmake\")
        cd(\"${pwd}\")
        ${arguments}
        ans(arguments)
        address_get(\"\${arguments}\")
        ans(arguments)
        function_import(\"${callable}\" as __async_call)
        message(\${arguments})
        __async_call(\${arguments})
        ans(async_result)
        qm_write(\"${result_file}\" \"\${async_result}\")
      ")
    process_start_script("${code}")
    ans(process_handle)
    map_set(${process_handle} result_file "${result_file}")
    return_ref(process_handle)
  endfunction()


# File: source/process/await.cmake


  function(await handle)
    process_wait(${handle})

    map_tryget("${handle}" result_file)
    ans(result_file)
    qm_read("${result_file}")
    return_ans()
  endfunction()

# File: source/process/command_line.cmake


function(command_line)
  is_map("${ARGN}")
  ans(ismap)
  if(ismap)
    map_has("${ARGN}" command)
    ans(iscommand_line)
    if(iscommand_line)
      creturn("${ARGN}")
    endif()
    creturn()
  endif()
  command_line_parse(${ARGN})
  return_ans()


endfunction()

# File: source/process/command_line_args_combine.cmake

## combines the list of command line args into a string which separates and escapes them correctly
  function(command_line_args_combine)
    command_line_args_escape(${ARGN})
    ans(args)
    string_combine(" " ${args})
    ans(res)
    string_decode_list("${res}")
    ans(res)    
    return_ref(res)
  endfunction()


# File: source/process/command_line_args_escape.cmake

## escapes a command line quoting arguments as needed 
function(command_line_args_escape) 
  set(whitespace_regex "( )")
  set(result)
  
  string(ASCII  31 us)

  foreach(arg ${ARGN})
    string(REGEX MATCH "[\r\n]" m "${arg}")
    if(NOT "_${m}" STREQUAL "_")
      message(FATAL_ERROR "command line argument '${arg}' is invalid - contains CR NL - consider escaping")
    endif()

    string(REGEX MATCH "${whitespace_regex}|\"" m "${arg}")
    if("${arg}" MATCHES "${whitespace_regex}|\"")
      string(REPLACE "\"" "\\\"" arg "${arg}")
      set(arg "\"${arg}\"")
    elseif("${arg}" MATCHES "${us}")
      set(arg "\"${arg}\"")
    endif()




    list(APPEND result "${arg}")

  endforeach()    
  return_ref(result)
endfunction()


# File: source/process/command_line_parse.cmake

## command_line_parse 
## parses the sepcified cmake style  command list which starts with COMMAND 
## or parses a single command line call
## returns a command line object:
## {
##   command:<string>,
##   args: <string>...
## }
function(command_line_parse)
  set(args ${ARGN})

  if(NOT args)
    creturn()
  endif()


  list_pop_front(args)
  ans(first)

  list(LENGTH args arg_count)

  if("${first}_" STREQUAL "COMMAND_")
    list_pop_front(args)
    ans(command)

    command_line_args_combine(${args})
    ans(arg_string)


    set(command_line "\"${command}\" ${arg_string}")      
  else()
    if(arg_count)
     message(FATAL_ERROR "either use a single command string or a list of 'COMMAND <command> <arg1> <arg2> ...'")
    endif()
    set(command_line "${first}")
  endif()


  command_line_parse_string("${command_line}")
  return_ans()
endfunction()

# File: source/process/command_line_parse_string.cmake



  function(command_line_parse_string str)
    uri_parse("${str}")
    ans(uri)

    map_tryget(${uri} rest)
    ans(rest)   


    uri_to_localpath("${uri}")
    ans(command)
    
    set(args)
    while(true)
      string_take_commandline_arg(rest)
      ans(arg)
      string_decode_delimited("${arg}")
      ans(arg)

      list(APPEND args "${arg}")
      if("${arg}_" STREQUAL "_")
        break()
      endif()
    endwhile()

    map_capture_new(command args)
    return_ans()
  endfunction()

# File: source/process/command_line_to_string.cmake

function(command_line_to_string)
    command_line(${ARGN})
    ans(cmd)

    scope_import_map(${cmd})

    command_line_args_combine(${args})
    ans(arg_string)
    if(NOT "${arg_string}_" STREQUAL "_")
      set(arg_string " ${arg_string}")
    endif()
    set(command_line "${command}${arg_string}")
    return_ref(command_line)
  endfunction()


  

# File: source/process/execute.cmake

## `(<process start info> [--process-handle] [--exit-code] [--async] [--silent-fail] [--success-callback <callable>]  [--error-callback <callable>] [--state-changed-callback <callable>])-><process handle>|<exit code>|<stdout>|<null>`
##
## *options*
## * `--process-handle` 
## * `--exit-code` 
## * `--async` 
## * `--silent-fail` 
## * `--success-callback <callable>[exit_code](<process handle>)` 
## * `--error-callback <callable>[exit_code](<process handle>)` 
## * `--state-changed-callback <callable>[old_state;new_state](<process handle>)` 
## * `--lean`
## *example*
## ```
##  execute(cmake -E echo_append hello) -> '@execute(""cmake", "-E", "echo_append", "hello"")'
## ```
function(execute)
  set(args ${ARGN})
  list_extract_flag(args --lean)
  ans(lean)


  arguments_encoded_list(0 ${ARGC})
  ans(args)

  list_extract_flag(args --process-handle)
  ans(return_handle)
  list_extract_flag(args --exit-code)
  ans(return_exit_code)
  list_extract_flag(args --async)
  ans(async)
  #list_extract_flag(args --async-wait)
  #ans(wait)
  #if(wait)
  #  set(async true)
  #endif()
  list_extract_flag(args --silent-fail)
  ans(silent_fail)

  list_extract_labelled_value(args --success-callback)
  ans(success_callback)
  list_extract_labelled_value(args --error-callback)
  ans(error_callback)
  list_extract_labelled_value(args --state-changed-callback)
  ans(process_callback)
  list_extract_labelled_value(args --on-terminated-callback)
  ans(terminated_callback)
  if(NOT args)
    messagE(FATAL_ERROR "no command specified")
  endif()

  process_start_info_new(${args})
  ans(start_info)

##debug here
  #print_vars(start_info.command start_info.command_arguments)

  process_handle_new(${start_info})
  ans(process_handle)

  if(success_callback)
    string_decode_list("${success_callback}")
    ans(success_callback)
    assign(success = process_handle.on_success.add("${success_callback}"))
  endif()
  if(error_callback)
    string_decode_list("${error_callback}")
    ans(error_callback)
    assign(success = process_handle.on_error.add("${error_callback}"))
  endif()
  if(process_callback)
    string_decode_list("${process_callback}")
    ans(process_callback)
    assign(success = process_handle.on_state_change.add("${process_callback}"))
  endif()
  if(terminated_callback)
    string_decode_list("${terminated_callback}")
    ans(terminated_callback)
    assign(success = process_handle.on_terminated.add("${terminated_callback}"))
  endif()

  if(async)
    process_start(${process_handle})
    creturn(${process_handle})
  else()
    process_execute(${process_handle})
    if(return_handle)
      creturn(${process_handle})
    endif()


    
    map_tryget(${process_handle} exit_code)
    ans(exit_code)

    if(return_exit_code)
      return_ref(exit_code)
    endif()

    map_tryget(${process_handle} pid)
    ans(pid)
    if(NOT pid)
      message(FATAL_ERROR FORMAT "could not find command '{start_info.command}'")
    endif()

    if(exit_code AND silent_fail)
      error("process {start_info.command} failed with {process_handle.exit_code}")
      creturn()
    endif()

    if(exit_code)
      message(FATAL_ERROR FORMAT "process {start_info.command} failed with {process_handle.exit_code}")
    endif()


    map_tryget(${process_handle} stdout)
    ans(stdout)
    return_ref(stdout)

  endif()


endfunction()

# File: source/process/execute_script.cmake

## `(<cmake code> [--pure] <args...>)-><execute result>`
##
## equivalent to `execute(...)->...` runs the specified code using `cmake -P`.  
## prepends the current `cmakepp.cmake` to the script  (this default behaviour can be stopped by adding `--pure`)
##
## all not specified `args` are forwarded to `execute`
##
function(execute_script script)
  set(args ${ARGN})

  list_extract_flag(args --no-cmakepp)
  ans(nocmakepp)

  if(NOT nocmakepp)
    cmakepp_config(cmakepp_path)
    ans(cmakepp_path)
    set(script "include(\"${cmakepp_path}\")\n${script}")
  endif()
  fwrite_temp("${script}" ".cmake")
  ans(script_file)
  ## execute add callback to delete temporary file
  execute("${CMAKE_COMMAND}" -P "${script_file}"  --on-terminated-callback "[]() rm(${script_file})" ${args}) 
  return_ans()
endfunction()



# File: source/process/linux/bash.cmake

# wraps the bash executable in cmake
function(bash)
  wrap_executable(bash bash)
  bash(${ARGN})
  return_ans()
endfunction()



# File: source/process/linux/bash_lean.cmake


function(bash_lean)
  wrap_executable_bare(bash_lean bash)
  bash_lean(${ARGN})
  return_ans()
endfunction()

# File: source/process/linux/linux_kill.cmake



  ## wraps the linux pkill command
  function(linux_kill)
    wrap_executable(linux_kill kill)
    linux_kill(${ARGN})
    return_ans()
  endfunction()


# File: source/process/linux/linux_ps.cmake

# wraps the linux ps command into an executable 
function(linux_ps)
  wrap_executable(linux_ps ps)
  linux_ps(${ARGN})
  return_ans()
endfunction()

# File: source/process/linux/linux_ps_info.cmake


function(linux_ps_info pid key)
  linux_ps_lean(-p "${pid}" -o "${key}=")
  ans_extract(error)
  ans(stdout)
  #print_vars(error stdout)

  if(error)
    creturn()
  endif()
  string(STRIP "${stdout}" val)
  return_ref(val)
endfunction()

# File: source/process/linux/linux_ps_info_capture.cmake



function(linux_ps_info_capture pid map)

  foreach(key ${ARGN})
    linux_ps_info("${pid}" "${key}")
    ans(val)
    map_set(${map} "${key}" "${val}")

  endforeach()
  creturn()
endfunction()


# File: source/process/linux/linux_ps_info_get.cmake


function(linux_ps_info_get pid)
  map_new()
  ans(map)
  linux_ps_info_capture("${pid}" "${map}" ${ARGN})
  creturn("${map}")

endfunction()


# File: source/process/linux/linux_ps_lean.cmake


function(linux_ps_lean)
  wrap_executable_bare(linux_ps_lean ps)
  linux_ps_lean(${ARGN})
  return_ans()
endfunction()

# File: source/process/linux/nohup.cmake

function(nohup)
    wrap_executable(nohup nohup)
    nohup(${ARGN})
    return_ans()
endfunction()

# File: source/process/linux/process_info_Linux.cmake

## process_info implementation for linux_ps
## currently only returns the process command name
function(process_info_Linux handle)
  process_handle("${handle}")
  ans(handle)

  map_tryget(${handle} pid)
  ans(pid)
  

  linux_ps_info_capture(${pid} ${handle} comm)


  return_ref(handle)    
endfunction()



# File: source/process/linux/process_isrunning_Linux.cmake


function(process_isrunning_Linux handle)
  process_handle("${handle}")
  ans(handle)
  map_tryget(${handle} pid)
  ans(pid)
  linux_ps_info(${pid} pid)
  ans(val)
  if(NOT "${val}_" STREQUAL "${pid}_")
    creturn(false)
  endif()
  creturn(true)
endfunction()

# File: source/process/linux/process_kill_Linux.cmake



  ## platform specific implementaiton for process_kill
  function(process_kill_Linux handle)
    process_handle("${handle}")
    ans(handle)

    map_tryget(${handle} pid)
    ans(pid)

    linux_kill(-SIGTERM ${pid} --exit-code)
    ans(error)

    return_truth("${error}" EQUAL 0)
  endfunction() 

# File: source/process/linux/process_list_Linux.cmake

# linux specific implementation of process_list 
# returns a list of <process handle> which only contains pid


  function(process_list_Linux)

    linux_ps_lean()
    ans_extract(error)
    ans(res)

   # print_vars(error res)

    string_lines("${res}")
    ans(lines)

    list_pop_front(lines)
    ans(headers)

    set(handles)
    set(ps_regex " *([1-9][0-9]*)[ ]*")
    #set(ps_regex " *([1-9][0-9]*)[ ]*([^ ]+)[ ]*([0-9][0-9]):([0-9][0-9]):([0-9][0-9]) *([^ ].*)")
    foreach(line ${lines})
      string(REGEX REPLACE "${ps_regex}" "\\1" pid "${line}")
      #string(REGEX REPLACE "${ps_regex}" "\\2" tty "${line}")
      #string(REGEX REPLACE "${ps_regex}" "\\3" hh "${line}")
      #string(REGEX REPLACE "${ps_regex}" "\\4" mm "${line}")
      #string(REGEX REPLACE "${ps_regex}" "\\5" ss "${line}")
      #string(REGEX REPLACE "${ps_regex}" "\\6" cmd "${line}")
      #string(STRIP "${cmd}" cmd)

      process_handle("${pid}")
      ans(handle)
      #map_capture(${handle} tty hh mm ss cmd) 
      
      list(APPEND handles ${handle})
    endforeach()
    return_ref(handles)
  endfunction()

# File: source/process/linux/process_start_Linux.cmake



# process_fork implementation specific to linux
# uses bash and nohup to start a process 
function(process_start_Linux process_handle)
  process_handle_register(${process_handle})
  map_tryget(${process_handle} start_info)

  ans(process_start_info)

  map_tryget(${process_start_info} command)
  ans(command)

  map_tryget(${process_start_info} command_arguments)
  ans(command_arguments)

  map_tryget(${process_start_info} working_directory)
  ans(working_directory)

  command_line_args_combine(${command_arguments})
  ans(command_arguments_string)

  set(command_string "${command} ${command_arguments_string}")

  # define output files        
  fwrite_temp("")
  ans(stdout)
  fwrite_temp("")
  ans(stderr)
  fwrite_temp("")
  ans(return_code)
  fwrite_temp("")
  ans(pid_out)

  process_handle_change_state(${process_handle} starting)
  # create a temporary shell script 
  # which starts bash with the specified command 
  # output of the command is stored in stdout file 
  # error of the command is stored in stderr file 
  # return_code is stored in return_code file 
  # and the created process id is stored in pid_out
  shell_tmp_script("( bash -c \"(cd ${working_directory}; ${command_string} > ${stdout} 2> ${stderr})\" ; echo $? > ${return_code}) & echo $! > ${pid_out}")
  ans(script)
  ## execute the script in bash with nohup 
  ## which causes the script to run detached from process
  bash_lean(-c "nohup ${script} > /dev/null 2> /dev/null")
  ans(error)

  if(error)
    message(FATAL_ERROR "could not start process '${command_string}'")
  endif()



  fread("${pid_out}")
  ans(pid)

  string(STRIP "${pid}" pid)

  map_set(${process_handle} pid "${pid}")

  process_handle_change_state(${process_handle} running)


  ## set output of process
  map_set(${process_handle} stdout_file ${stdout})
  map_set(${process_handle} stderr_file ${stderr})
  map_set(${process_handle} return_code_file ${return_code})
  

  process_refresh_handle("${process_handle}")

  return_ref(process_handle)
endfunction()


# File: source/process/process_execute.cmake

## `(<process handle>)-><process handle>`
##
## executes the specified command with the specified arguments in the 
## current working directory
## creates and registers a process handle which is then returned 
## this function accepts arguments as encoded lists. this allows you to include
## arguments which contain semicolon and other special string chars. 
## the process id of processes start with `process_execute` is always -1
## because `CMake`'s `execute_process` does not return it. This is not too much of a problem
## because the process will always be terminated as soon as the function returns
## 
## **parameters**
##   * `<command>` the executable (may contain spaces) 
##   * `<arg...>` the arguments - may be an encoded list 
## **scope**
##   * `pwd()` used as the working-directory
## **events** 
##   * `on_process_handle_created` global event is emitted when the process_handle is ready
##   * `process_handle.on_state_changed`
##
## **returns**
## ```
## <process handle> ::= {
##   pid: "-1"|"0"
##     
## }
## ``` 
function(process_execute process_handle)
  process_handle_register(${process_handle})

  map_tryget(${process_handle} start_info)
  ans(process_start_info)  

  ## the pid is -1 by default for non async processes
  map_set(${process_handle} pid -1)

  ## register process handle
  process_handle_change_state(${process_handle} starting)
  process_handle_change_state(${process_handle} running)

  map_tryget(${process_start_info} working_directory)
  ans(cwd)



  map_tryget(${process_start_info} command)
  ans(command)

  cmake_string_escape("${command}")
  ans(command)

  map_tryget(${process_start_info} command_arguments)
  ans(command_arguments)


  map_tryget(${process_start_info} passthru)
  ans(passthru)


  #command_line_args_combine(${command_arguments})
  #ans(command_arguments_string)

  set(command_arguments_string)
  foreach(argument ${command_arguments})
    string_decode_list("${argument}")
    ans(argument)
    cmake_string_escape("${argument}")
    ans(argument)
    set(command_arguments_string "${command_arguments_string} ${argument}")
  endforeach()
  

  map_tryget(${process_start_info} timeout)
  ans(timeout)


  if("${timeout}" GREATER -1)
    set(timeout TIMEOUT ${timeout})
  else()
    set(timeout)
  endif()

  #message("executing ${command} ${command_arguments_string}")


  set(output_handling "  OUTPUT_VARIABLE stdout\n  ERROR_VARIABLE stderr")

  if(passthru)
    set(output_handling)
  endif()


  set(eval_this "
    execute_process(
      COMMAND ${command} ${command_arguments_string}
      ${output_handling}
      RESULT_VARIABLE exit_code
      WORKING_DIRECTORY ${cwd}
      ${timeout}
    )
  ")
#  _message("${eval_this}")
  eval_ref(eval_this)

  ## set process handle variables
  if(NOT "${exit_code}" MATCHES "^-?[0-9]+$")
    map_set(${process_handle} pid)
  endif()
  map_set(${process_handle} exit_code "${exit_code}")
  map_set(${process_handle} stdout "${stdout}")
  map_set(${process_handle} stderr "${stderr}")

  ## change state
  process_handle_change_state(${process_handle} terminated)

  return_ref(process_handle)
endfunction()


# File: source/process/process_handle.cmake

## returns the runtime unique process handle
## information may differ depending on os but the following are the same for any os
## * pid
## * status
function(process_handle handlish)
  is_map("${handlish}")
  ans(ismap)

  if(ismap)
    set(handle ${handlish})
  elseif( "${handlish}" MATCHES "[0-9]+")
    string(REGEX MATCH "[0-9]+" handlish "${handlish}")

    map_tryget(__process_handles ${handlish})
    ans(handle)
    if(NOT handle)
      map_new()
      ans(handle)
      map_set(${handle} pid "${handlish}")          
      map_set(${handle} state "unknown")
      map_set(__process_handles ${handlish} ${handle})
    endif()
  else()
    message(FATAL_ERROR "'${handlish}' is not a valid <process handle>")
  endif()
  return_ref(handle)
endfunction()


# File: source/process/process_handle_change_state.cmake


function(process_handle_change_state process_handle new_state)
  map_tryget("${process_handle}" state)
  ans(old_state)
  if("${old_state}" STREQUAL "${new_state}")
    creturn(false)
  endif()

  map_tryget(${process_handle} on_state_change)
  ans(on_state_change_event)

  event_emit(${on_state_change_event} ${process_handle})



  map_set(${process_handle} state "${new_state}")

  if("${new_state}" STREQUAL "terminated")
    map_tryget(${process_handle} exit_code)
    ans(error)
    if(error)
      map_tryget("${process_handle}" on_error)
      ans(on_error_event)
      event_emit("${on_error_event}" ${process_handle})  
    else()
      map_tryget("${process_handle}" on_success)
      ans(on_success_event)
      event_emit("${on_success_event}" ${process_handle})  
    endif()
    map_tryget("${process_handle}" on_terminated)
    ans(on_terminated_event)
    event_emit("${on_terminated_event}" ${process_handle})
endif()

  creturn(true)
endfunction()

# File: source/process/process_handle_get.cmake


function(process_handle_get pid)
  map_tryget(__process_handles ${pid})
  return_ans()
endfunction()

# File: source/process/process_handle_new.cmake

## `(<process start info>)-><process handle>`
##
## returns a new process handle which has the following layout:
## ```
## <process handle> ::= {
##   pid: <pid>  
##   start_info: <process start info>
##   state: "unknown"|"running"|"terminated"
##   stdout: <text>
##   stderr: <text>
##   exit_code: <integer>|<error string>
##   command: <executable>
##   command_args: <encoded list>
##   on_state_change: <event>[old_state, new_state](${process_handle}) 
## }
## ``` 
function(process_handle_new start_info)
  map_new()
  ans(process_handle)
  map_set(${process_handle} pid "")
  map_set(${process_handle} start_info "${start_info}")
  map_set(${process_handle} state "unknown")
  map_set(${process_handle} stdout "")
  map_set(${process_handle} stderr "")
  map_set(${process_handle} exit_code)
  event_new()
  ans(event)
  map_set(${process_handle} on_state_change ${event})

  event_new()
  ans(event)
  map_set(${process_handle} on_success ${event})


  event_new()
  ans(event)
  map_set(${process_handle} on_error ${event})


  event_new()
  ans(event)
  map_set(${process_handle} on_terminated ${event})

  return_ref(process_handle)
endfunction()


# File: source/process/process_handle_register.cmake


function(process_handle_register process_handle)
  event_emit(on_process_handle_created ${process_handle})
endfunction()


# File: source/process/process_handles.cmake

## transforms a list of <process handle?!> into a list of <process handle>  
function(process_handles)
  set(handles)
  foreach(arg ${ARGN})
    process_handle("${arg}")
    ans(handle)
    list(APPEND handles ${handle})
  endforeach()
  return_ref(handles)
endfunction()

# File: source/process/process_info.cmake

## process_info(<process handle?!>): <process info>
## returns information on the specified process handle
function(process_info)
  wrap_platform_specific_function(process_info)
  process_info(${ARGN})
  ans(res)
  return_ref(res)
endfunction()


# File: source/process/process_isrunning.cmake

## returns true iff the process identified by <handlish> is running
function(process_isrunning)    
  wrap_platform_specific_function(process_isrunning)    
  process_isrunning(${ARGN})
  return_ans()
endfunction()



# File: source/process/process_kill.cmake

# process_kill(<process handle?!>)
# stops the process specified by <process handle?!>
# returns true if the process was killed successfully
function(process_kill)
  wrap_platform_specific_function(process_kill)
  process_kill(${ARGN})
  return_ans()
endfunction()


# File: source/process/process_list.cmake

## returns a list of <process info> containing all processes currently running on os
## process_list():<process info>...
function(process_list)
  wrap_platform_specific_function(process_list)
  process_list(${ARGN})
  return_ans()
endfunction()


# File: source/process/process_refresh_handle.cmake

## refreshes the fields of the process handle
## returns true if the process is still running false otherwise
## this is the only function which is allowed to change the state of a process handle
function(process_refresh_handle handle)
  process_handle("${handle}")
  ans(handle)


  process_isrunning("${handle}")
  ans(isrunning)

  if(isrunning)
    set(state running)
  else()
    set(state terminated)
  endif()

  if("${state}" STREQUAL "terminated")
    process_return_code("${handle}")
    ans(exit_code)
    process_stdout("${handle}")
    ans(stdout)
    process_stderr("${handle}")
    ans(stderr)
    map_capture("${handle}" exit_code stdout stderr)
  endif()


  process_handle_change_state("${handle}" "${state}")
  ans(state_changed)

  




  return_ref(isrunning)

endfunction()


# File: source/process/process_return_code.cmake

## returns the <return_code> for the specified process handle
## if process is not finished the result is empty
  function(process_return_code handle)
    process_handle("${handle}")
    ans(handle)
    map_tryget("${handle}" return_code_file)
    ans(return_code_file)
    fread("${return_code_file}")
    ans(return_code)
    string(STRIP "${return_code}" return_code)
    return_ref(return_code)
  endfunction()


# File: source/process/process_start.cmake

## starts a process and returns a handle which can be used to controll it.  
##
# {
#   <pid:<unique identifier>> // some sort of unique identifier which can be used to identify the processs
#   <process_start_info:<process start info>> /// the start info for the process
#   <output:<function():<string>>>
#   <status:"running"|"complete"> // indicates weather the process is complete - this is a cached result because query the process state is expensive
# }
function(process_start)
  wrap_platform_specific_function(process_start)
  process_start(${ARGN})
  return_ans()
endfunction()




# File: source/process/process_start_info.cmake



# File: source/process/process_start_info_new.cmake

## `(<command string>|<object> [TIMEOUT <n:int>] [WORKING_DIRECTORY ~<path>] [--passthru])-><process start info>` 
## `<command string> ::= "COMMAND"? <command> <arg...>` 
##
## creates a new process_start_info with the following fields
## ```
## <process start info> ::= {
##   command: <executable> 
##   command_arguments: <encoded list>
##   working_directory: <directory>
##   timeout: <n>
##   passthru: true|false
## }
## ```
## the syntax of the process_start_info_new is equivalent to cmake's built in `execute_process` command.
##
##
## the command needs to point to an executable,  preferrably a fully qualified path 
## the command_arguments contain an encoded list.  you can specify any argument in the execute function - they will be passed along as you write them  (this deserves extra appreciation because doing so in cmake is hard)
## If the flags you want to pass along to the process conflict with the flags of the process function you can always encode them yourself and pass them along as an encoded list
##
##
## *example*
##  * `process_start_info_new(COMMAND cmake -E echo "asd bsd" csd) -> <% process_start_info_new(COMMAND cmake -E echo "asd;bsd")
##  ans(info)
##  template_out_json(${info}) %>` 
function(process_start_info_new)
  arguments_encoded_list(0 ${ARGC})
  ans(arguments_list)

  list_extract_any_labelled_value(arguments_list WORKING_DIRECTORY)
  ans(working_directory)
  list_extract_any_labelled_value(arguments_list TIMEOUT)
  ans(timeout)

  list_extract_flag(arguments_list --passthru)
  ans(passthru)

  if(NOT timeout)
    set(timeout -1)
  endif()

  path_qualify(working_directory)

  list_pop_front(arguments_list)
  ans(command)

  if("${command}_" STREQUAL "COMMAND_")
    list_pop_front(arguments_list)
    ans(command)
  endif()

  string_decode_list("${command}")
  ans(command)

  map_new()
  ans(process_start_info)
  map_set(${process_start_info} command "${command}")  
  map_set(${process_start_info} command_arguments "${arguments_list}")
  map_set(${process_start_info} working_directory "${working_directory}")  
  map_set(${process_start_info} timeout "${timeout}")
  map_set(${process_start_info} passthru "${passthru}")
  return_ref(process_start_info)
endfunction()


# File: source/process/process_start_script.cmake

## shorthand to fork a cmake script
function(process_start_script scriptish)
  fwrite_temp("${scriptish}" ".cmake")
  ans(script_path)
  execute(
    COMMAND
    "${CMAKE_COMMAND}"
    -P
    "${script_path}"
    ${ARGN}
    --async
  )
  return_ans()
endfunction()

# File: source/process/process_stderr.cmake

## returns the current error output
## This can change until the process is finished
function(process_stderr handle)
    process_handle("${handle}")
    ans(handle)
    map_tryget("${handle}" stderr_file)
    ans(stderr_file)
    fread("${stderr_file}")
    ans(stderr)
    return_ref(stderr)
endfunction()



# File: source/process/process_stdout.cmake

## returns the current stdout of a <process handle>
## this changes until the process is ove
function(process_stdout handle)
    process_handle("${handle}")
    ans(handle)
    map_tryget("${handle}" stdout_file)
    ans(stdout_file)
    fread("${stdout_file}")
    ans(stdout)
return_ref(stdout)
endfunction()


# File: source/process/process_timeout.cmake

## returns a <process handle> to a process that runs for n seconds
#todo create shims
function(process_timeout n)
    execute(${CMAKE_COMMAND} -E sleep ${n} --async)
    return_ans()
endfunction()

# File: source/process/process_wait.cmake


  ## blocks until given process has terminated
  ## returns nothing if the process does not exist - is deleted etc
  ## updates and returns the process_handle
  ## if a timeout greater 0 the function will return nothing if the timeout is reached
  ## process_wait(<process handle> <?--timeout:<seconds>>)
  function(process_wait handle)
    process_handle("${handle}")
    ans(handle)

    set(args ${ARGN})
    list_extract_labelled_value(args --timeout)
    ans(timeout)

    if("${timeout}_" STREQUAL "_")
      set(timeout -1)
    endif()

    if("${timeout}" LESS 0)
      while(true)

        process_refresh_handle(${handle})
        ans(isrunning)
        if(NOT isrunning)
          creturn(${handle})
        endif()
      endwhile()
    elseif("${timeout}" EQUAL 0)
      process_refresh_handle(${handle})
      ans(isrunning)
      if(isrunning)
        creturn()
      else()
        creturn("${handle}")
      endif()
    else()
      process_timeout(${timeout})
      ans(timeout_handle)
      while(true)
        process_refresh_handle(${handle})
        ans(isrunning)
        if(NOT isrunning)
          process_kill(${timeout_handle})
          creturn(${handle})
        endif()
        process_refresh_handle(${timeout_handle})
        ans(isrunning)
        if(NOT isrunning)
          creturn()
        endif()
      endwhile()
    endif()
endfunction()

# File: source/process/process_wait_all.cmake

## `(<handles: <process handle...>>  [--timeout <seconds>] [--idle-callback <callable>] [--task-complete-callback <callable>] )`
##
## waits for all specified <process handles> to finish returns them in the order
## in which they completed
##
## `--timeout <n>`    if value is specified the function will return all 
##                    finished processes after n seconds
##
## `--idle-callback <callable>`   
##                    if value is specified it will be called at least once
##                    and between every query if a task is still running 
##
##
## `--task-complete-callback <callable>`
##                    if value is specified it will be called whenever a 
##                    task completes.
##
## *Example*
## `process_wait_all(${handle1} ${handle1}  --task-complete-callback "[](handle)message(FORMAT '{handle.pid}')")`
## prints the process id to the console whenver a process finishes
##
function(process_wait_all)
  set(args ${ARGN})

  list_extract_labelled_value(args --idle-callback)
  ans(idle_callback)

  list_extract_labelled_value(args --task-complete-callback)
  ans(task_complete_callback)

  list_extract_labelled_value(args --timeout)
  ans(timeout)
  set(timeout_task_handle)


  process_handles(${args})
  ans(process_list)
  ans(running_processes)


  list(LENGTH running_processes process_count)

  set(timeout_process_handle)
  if(timeout)
    process_timeout(${timeout})
    ans(timeout_process_handle)
    list(APPEND running_processes ${timeout_process_handle})
  endif()
  set(complete_count 0)
  while(running_processes)

    list_pop_front(running_processes)
    ans(current_process)
    process_refresh_handle(${current_process})
    ans(is_running)
    
    #message(FORMAT "{current_process.pid} is_running {is_running} {current_process.state} ")

    if(NOT is_running)
      if("${current_process}_" STREQUAL "_${timeout_process_handle}")
        set(running_processes)
      else()          

        list(APPEND complete_processes ${current_process})          
        if(NOT quietly)
          list(LENGTH complete_processes complete_count)           
          if(task_complete_callback)
            call2("${task_complete_callback}" "${current_process}") 
          endif()
        endif() 
      endif()        
    else()
      ## insert into back
      list(APPEND running_processes ${current_process})
    endif()

    if(idle_callback)
      call2("${idle_callback}")
    endif()

  endwhile()

  return_ref(complete_processes)
endfunction()


# File: source/process/process_wait_any.cmake

  ## waits until any of the specified handles stops running
  ## returns the handle of that process
  ## if --timeout <n> is specified function will return nothing after n seconds
  function(process_wait_any)
    set(args ${ARGN})

    list_extract_flag(args --quietly)
    ans(quietly)    

    process_handles(${args})
    ans(processes)


    if(NOT quietly)
      list(LENGTH processes len)
      echo_append("waiting for any of ${len} processes to finish.")  
    endif()

    set(timeout_process_handle)
    if(timeout)
      process_timeout(${timeout})
      ans(timeout_process_handle)
      list(APPEND processes ${timeout_process_handle})
    endif()

    while(processes)
      list_pop_front(processes)
      ans(process)
      process_refresh_handle(${process})
      ans(isrunning)


      if(NOT quietly)
        tick()
      endif()

      if(NOT isrunning)
        if("${process}_" STREQUAL "${timeout_process_handle}_")      
          echo(".. timeout")
          creturn()
        endif()
        if(NOT quietly)
          echo("")
        endif()
        creturn(${process})
      else()
        list(APPEND processes ${process})
      endif()

    endwhile()   
  endfunction()

# File: source/process/process_wait_n.cmake


## `(<n:<int>|"*"> <process handle>... [--idle-callback:<callable>])-><process handle>...`
##
## waits for at least <n> processes to complete 
##
## returns: 
##  * at least `n` terminated processes
## 
## arguments: 
## * `n` an integer the number of processes to return (lower bound) if `n` is clamped to the number of processes. if `n` is * it is replaced with the number of processes 
## * `--idle-callback` is called after every time a processes state was polled. It is guaranteed to be called once per process handle. it has access to the following scope variables
##    * `terminated_count` number of terminated processes
##    * `running_count` number of running processes
##    * `wait_time` time that was waited
##    * `wait_counter` number of times the waiting loop iterated
##    * `running_processes` list of running processes 
##    * `current_process` the current process being polled
##    * `is_running` the running state of the current process
##    * `terminated_processes` the list of terminated processes
##
function(process_wait_n n)
  arguments_extract_typed_values(0 ${ARGC}
    <n:<string>>
    [--idle-callback:<callable>] # 
    [--timeout:<int>?]
  )
  ans(process_handles)

  list(LENGTH process_handles process_count)

  set(running_processes ${process_handles})
  set(terminated_processes)

  timer_start(__process_wait_timer)
  set(wait_counter 0)
  
  if("${n}" STREQUAL "*")
    list(LENGTH running_processes n)
  endif()  

  set(terminated_count 0)

  set(wait_time)
  while(true)
    if(timeout)
      if(${timeout} GREATER ${wait_time})
        break()
      endif()
    endif()


    set(queue ${running_processes})

    while(queue)
      list_pop_front(queue)
      ans(current_process)
    

      process_refresh_handle(${current_process})
      ans(is_running)

      if(NOT is_running)
        list(REMOVE_ITEM running_processes ${current_process})
        list(APPEND terminated_processes ${current_process})
      endif()
      
      ## status vars
      timer_elapsed(__process_wait_timer)
      ans(wait_time)
      list(LENGTH terminated_processes terminated_count)
      list(LENGTH running_processes running_count)

      if(idle_callback)
        call2("${idle_callback}")
      endif()
      math(EXPR wait_counter "${wait_counter} + 1")

    endwhile()

    if(NOT ${terminated_count} LESS ${n})
      break()
    endif()
    if(NOT running_processes)
      creturn()
    endif()
  endwhile()


  return_ref(terminated_processes)
endfunction()

# File: source/process/string_take_commandline_arg.cmake


  function(string_take_commandline_arg str_ref)
    string_take_whitespace(${str_ref})
    set(regex "(\"([^\"\\\\]|\\\\.)*\")|[^ ]+")
    string_take_regex(${str_ref} "${regex}")
    ans(res)
    if(NOT "${res}_" STREQUAL _)
      set("${str_ref}" "${${str_ref}}" PARENT_SCOPE)
    endif()
    if("${res}" MATCHES "\".*\"")
      string_take_delimited(res "\"")
      ans(res)
    endif()

    return_ref(res)


  endfunction()

# File: source/process/windows/process_info_Windows.cmake


## windows specific implementation for process_info
function(process_info_Windows handlish)
  process_handle("${handlish}")
  ans(handle)
  map_tryget(${handle} pid)
  ans(pid)


  win32_tasklist(/V /FO CSV /FI "PID eq ${pid}" --process-handle )
  ans(exe_result)


  map_tryget(${exe_result} exit_code)
  ans(error)
  if(error)
    creturn()
  endif()


  map_tryget(${exe_result} stdout)
  ans(csv)


  csv_deserialize("${csv}" --headers)  
  ans(res)

  map_rename(${res} PID pid)
  return_ref(res)
endfunction()




# File: source/process/windows/process_isrunning_Windows.cmake


## platform specific implementation for process_isrunning under windows
function(process_isrunning_Windows handlish)    
  process_handle("${handlish}")    
  ans(handle)    
  map_tryget(${handle} state)
  ans(state)
  if("${state}_" STREQUAL "terminated_" )
    creturn(false)
  endif()

  map_tryget(${handle} pid)
  ans(pid)
  
  win32_tasklist_bare(-FI "PID eq ${pid}" -FI "STATUS eq Running")
  ans_extract(error)
  ans(res)
  if("${res}" MATCHES "${pid}")
    creturn(true)
  endif()
  creturn(false)
endfunction()



# File: source/process/windows/process_kill_Windows.cmake


# windows implementation for process kill
function(process_kill_Windows process_handle)
  process_handle("${process_handle}")
  map_tryget(${process_handle} pid)
  ans(pid)

  win32_taskkill(/PID ${pid} --exit-code)
  ans(exit_code)
  if(exit_code)
    creturn(false)
  endif()
  creturn(true)
endfunction()


# File: source/process/windows/process_list_Windows.cmake


## platform specific implementation for process_list under windows
function(process_list_Windows)
  win32_wmic(process where "processid > 0" get processid) #ignore idle process
  ans(ids)


  string(REGEX MATCHALL "[0-9]+" matches "${ids}")
  set(ids)



  foreach(id ${matches})
    process_handle("${id}")
    ans(handle)
    list(APPEND ids ${handle})
  endforeach()



  return_ref(ids)
endfunction()

# File: source/process/windows/process_start_Windows.cmake

## windows implementation for start process
## newer faster version
 function(process_start_Windows process_handle)
    ## create a process handle from pid
    process_handle_register(${process_handle})

    map_tryget(${process_handle} start_info)
    ans(start_info)


    map_tryget(${start_info} command)
    ans(command)

    map_tryget(${start_info} command_arguments)
    ans(command_arguments)

    command_line_args_combine(${command_arguments})
    ans(command_arguments_string)

    set(command_string "\"${command}\" ${command_arguments_string}")

    map_tryget(${start_info} working_directory)
    ans(working_directory)

    ## create temp dir where process specific files are stored
    mktemp()
    ans(dir)
    ## files where to store stdout and stderr
    set(outputfile "${dir}/stdout.txt")
    set(errorfile "${dir}/stderr.txt")
    set(returncodefile "${dir}/retcode.txt")
    set(pidfile "${dir}/pid.txt")

    fwrite("${outputfile}" "")
    fwrite("${errorfile}" "")
    fwrite("${returncodefile}" "")


    ## creates a temporary batch file
    ## which gets the process id (get the parent process id wmic....)
    ## output pid to file output command_string to 
    fwrite_temp("
      @echo off
      cd \"${working_directory}\"
      wmic process get parentprocessid,name|find \"WMIC\" > ${pidfile}
      ${command_string} > ${outputfile} 2> ${errorfile}
      echo %errorlevel% > ${returncodefile}
      exit
    " ".bat")
    ans(path)


    process_handle_change_state(${process_handle} starting)
    win32_powershell_lean("start-process -File ${path} -WindowStyle Hidden")


    ## wait until the pidfile exists and contains a valid pid
    ## this seems very hackisch but is necessary as i have not found
    ## a simpler way to do it
    while(true)
      if(EXISTS "${pidfile}")
        fread("${pidfile}")
        ans(pid)
        if("${pid}" MATCHES "[0-9]+" )
          set(pid "${CMAKE_MATCH_0}")
          break()
        endif()
      endif()
    endwhile()
    map_set(${process_handle} pid "${pid}")
    
    process_handle_change_state(${process_handle} running)

    
    ## set the output files for process_handle
    map_set(${process_handle} stdout_file ${outputfile})
    map_set(${process_handle} stderr_file ${errorfile})
    map_set(${process_handle} return_code_file  ${returncodefile})

    assign(!process_handle.windows.process_data_dir = dir) 

    return_ref(process_handle)
  endfunction()


# File: source/process/wrap_executable.cmake


# wrap_executable(<alias> <executable> <args...>)-><null>
#
# creates a function called ${alias} which wraps the executable specified in ${executable}
# <args...> will be set as command line arguments for every call
# the alias function's varargs will be passed on as command line arguments. 
#
# Warning: --async is a bit experimental
#
# defines function
# <alias>([--async]|[--process-handle]|[--exit-code])-> <stdout>|<process result>|<exit code>|<process handle>
#
# <no flag>       if no flag is specified then the function will fail if the return code is not 0
#                 if it succeeds the return value is the stdout
#
# --process-handle        flag the function will return a the execution 
#                 result object (see execute()) 
# --exit-code     flag the function will return the exit code
# --async         will execute the executable asynchroniously and
#                 return a <process handle>
# --async-wait    will execute the executable asynchroniously 
#                 but will not return until the task is finished
#                 printing a status indicator
# --lean          lean call to executable (little overhead - no events etc)
# 
# else only the application output will be returned 
# and if the application terminates with an exit code != 0 a fatal error will be raised
function(wrap_executable alias executable)
  arguments_encoded_list(0 ${ARGC})
  ans(arguments)
  # remove alias and executable
  list_pop_front(arguments)
  list_pop_front(arguments)

  eval("  
    function(${alias})
      arguments_encoded_list(0 \${ARGC})
      ans(arguments)
      execute(\"${executable}\" ${arguments} \${arguments})
      return_ans()
    endfunction()
    ")
  creturn()
endfunction()


# File: source/process/wrap_executable_bare.cmake

## a fast wrapper for the specified executable
## this should be used for executables that are called often
## and do not need to run async
function(wrap_executable_bare alias executable)

  eval("
    function(${alias})
      set(args \${ARGN})
      list_extract_flag(args --passthru)
      ans(passthru)
      pwd()
      ans(cwd)      
      set(output)
      set(stdout)
      if(NOT passthru)
        set(output 
          OUTPUT_VARIABLE stdout 
          ERROR_VARIABLE stdout 
          )
      endif()
      execute_process(COMMAND \"${executable}\" ${ARGN} \${args}
        WORKING_DIRECTORY  \"\${cwd}\"
        \${output}
        RESULT_VARIABLE error
      )
      list(INSERT stdout 0 \${error})
      return_ref(stdout)
    endfunction()
    ")
  creturn()
endfunction()

# File: source/propref/propref_get_key.cmake


  function(propref_get_key)
    string_split_at_last(ref prop "${propref}" ".")
    return_ref(prop)
  endfunction()
  
 

# File: source/propref/propref_get_ref.cmake


  function(propref_get_ref)
    string_split_at_last(ref prop "${propref}" ".")
    return_ref(ref)
  endfunction()

# File: source/propref/propref_isvalid.cmake

 function(propis_address propref)
    string_split_at_last(ref prop "${propref}" ".")
    is_address("${ref}")
    ans(isref)
    if(NOT isref)
      creturn(false)
    endif()
    obj_has("${ref}" "${prop}")
    ans(has_prop)
    if(NOT has_prop)
      creturn(false)

    endif()
    creturn(true)
  endfunction()

# File: source/quickmap/end.cmake

function(end)
  # remove last key from key stack and last map from map stack
  # return the popped map
  stack_pop(:quick_map_key_stack)
  stack_pop(:quick_map_map_stack)
  return_ans()
endfunction()



## end() -> <current value>
##
## ends the current key, ref or map and returns the value
## 
function(end)
  stack_pop(quickmap)
  ans(ref)

  if(NOT ref)
    message(FATAL_ERROR "end() not possible ")
  endif()
    
  string_take_address(ref)
  ans(current_ref)

  return_ref(current_ref)
endfunction()


# File: source/quickmap/key.cmake

function(key key)
  # check if there is a current map
  stack_peek(:quick_map_map_stack)
  ans(current_map)
  if(NOT current_map)
    message(FATAL_ERROR "cannot set key for non existing map be sure to call first map() before first key()")
  endif()
  # set current key
  stack_pop(:quick_map_key_stack)
  stack_push(:quick_map_key_stack "${key}")
endfunction()


## key() -> <void>
##
## starts a new property for a map - may only be called
## after key or map
## fails if current ref is not a map
function(key key)
  stack_pop(quickmap)
  ans(current_key)

  string_take_address(current_key)
  ans(current_ref)
 
  #is_map("${current_ref}")
  is_address("${current_ref}")
  ans(ismap)
  if(NOT ismap)
    message(FATAL_ERROR "expected a map before key() call")
  endif()


  map_set("${current_ref}" "${key}" "")
  stack_push(quickmap "${current_ref}.${key}")
  creturn()
endfunction()


# File: source/quickmap/kv.cmake

function(kv key)
  key("${key}")
  val(${ARGN})
endfunction()



# File: source/quickmap/map.cmake

function(map)
  set(key ${ARGN})

  # get current map
  stack_peek(:quick_map_map_stack)
  ans(current_map)

  # get current key
  stack_peek(:quick_map_key_stack)
  ans(current_key)

  if(ARGN)
    set(current_key ${ARGV0})
  endif()

  # create new current map
  map_new()
  ans(new_map)


  # add map to existing map
  if(current_map)
    key("${current_key}")
    val("${new_map}")
  endif()


  # push new map and new current key on stacks
  stack_push(:quick_map_map_stack ${new_map})
  stack_push(:quick_map_key_stack "")

  return_ref(new_map)
endfunction()



## map() -> <address>
## 
## begins a new map returning its address
## map needs to be ended via end()
function(map)
  if(NOT ARGN STREQUAL "")
    key("${ARGN}")
  endif()
  map_new()
  ans(ref)
  val(${ref})
  stack_push(quickmap ${ref})
  return_ref(ref)
endfunction()


# File: source/quickmap/ref.cmake


## ref() -> <address> 
## 
## begins a new reference value and returns its address
## ref needs to be ended via end() call
function(ref)
  if(NOT ARGN STREQUAL "")
    key("${ARGN}")
  endif()
  address_new()
  ans(ref)
  val(${ref})
  stack_push(quickmap ${ref})   
  return_ref(ref)
endfunction()


# File: source/quickmap/val.cmake

function(val)
  # appends the values to the current_map[current_key]
  stack_peek(:quick_map_map_stack)
  ans(current_map)
  stack_peek(:quick_map_key_stack)
  ans(current_key)
  if(NOT current_map)
    set(res ${ARGN})
    return_ref(res)
  endif()
  map_append("${current_map}" "${current_key}" "${ARGN}")
endfunction()



## val(<val ...>) -> <any...>
##
## adds a val to current property or ref
##
function(val)
  set(args ${ARGN})
  stack_peek(quickmap)
  ans(current_ref)
  
  if(NOT current_ref)
    creturn()
  endif()
  ## todo check if map 
  address_append("${current_ref}" ${args})
  return_ref(args)
endfunction()


# File: source/quickmap/var.cmake


## captures a list of variable as a key value pair
function(var)
  foreach(var ${ARGN})
    kv("${var}" "${${var}}")
  endforeach()
endfunction()

# File: source/ref/address_append.cmake

function(address_append ref)
	set_property( GLOBAL APPEND PROPERTY "${ref}" "${ARGN}")
endfunction()

# File: source/ref/address_append_string.cmake

function(address_append_string ref str)
  set_property(GLOBAL APPEND_STRING PROPERTY "${ref}" "${str}")
endfunction()

# File: source/ref/address_delete.cmake

function(address_delete ref)
	set_property(GLOBAL PROPERTY "${ref}")
endfunction()


# File: source/ref/address_get.cmake

function(address_get ref)
    get_property(ref_value GLOBAL PROPERTY "${ref}")
    return_ref(ref_value)
endfunction()

# optimized version
macro(address_get ref)
    get_property(__ans GLOBAL PROPERTY "${ref}")
endmacro()

# File: source/ref/address_new.cmake

function(address_new)
	address_set(":0" 0)	
	function(address_new)
		address_get(":0" )
		ans(index)
		math(EXPR index "${index} + 1")
		address_set(":0" "${index}")
		if(ARGN)
		#	set(type "${ARGV0}")
			address_set(":${index}.__type__" "${ARGV0}")
		endif()
		creturn(":${index}")
	endfunction()

	address_new(${ARGN})
	return_ans()
endfunction()

## optimized version
function(address_new)
	set_property(GLOBAL PROPERTY ":0" 0 )
	function(address_new)
		get_property(index GLOBAL PROPERTY ":0")
		math(EXPR index "${index} + 1")
		set_property(GLOBAL PROPERTY ":0" ${index} )
		if(ARGN)
			set_property(GLOBAL PROPERTY ":${index}.__type__" "${ARGV0}")
		endif()
		set(__ans ":${index}" PARENT_SCOPE)
	endfunction()

	address_new(${ARGN})
	return_ans()
endfunction()

## faster
macro(address_new)
	set_property(GLOBAL PROPERTY ":0" 0)
	macro(address_new)
		get_property(__ans GLOBAL PROPERTY ":0")
		math(EXPR __ans "${__ans} + 1")
		set_property(GLOBAL PROPERTY ":0" "${__ans}")
		set_property(GLOBAL PROPERTY ":${__ans}")
		set(__ans ":${__ans}")
	endmacro()
	address_new(${ARGN})
endmacro()

# File: source/ref/address_peek_back.cmake


function(address_peek_back ref)
  address_get(${ref})
  ans(value)
  list_peek_back(value ${ARGN})
  ans(res)
  return_ref(res)
endfunction()

# File: source/ref/address_peek_front.cmake


function(address_peek_front ref)
  address_get(${ref})
  ans(value)
  list_peek_front(value ${ARGN})
  ans(res)
  return_ref(res)
endfunction()

# File: source/ref/address_pop_back.cmake


function(address_pop_back ref)
  address_get(${ref})
  ans(value)
  list_pop_back(value)
  ans(res)
  address_set(${ref} ${value})
  return_ref(res)
endfunction()

# File: source/ref/address_pop_front.cmake


function(address_pop_front ref)
  address_get(${ref})
  ans(value)
  list_pop_front(value)
  ans(res)
  address_set(${ref} ${value})
  return_ref(res)
endfunction()

# File: source/ref/address_print.cmake

function(address_print ref)
  address_get("${ref}")
  _message("${ref}")
endfunction()

# File: source/ref/address_push_back.cmake


  function(address_push_back ref)
    address_get(${ref})
    ans(value)
    list_push_back(value "${ARGN}")
    ans(res)
    address_set(${ref} ${value})
    return_ref(res)
  endfunction()

# File: source/ref/address_push_front.cmake


function(address_push_front ref)
    get_property(value GLOBAL PROPERTY "${ref}")
  set_property( GLOBAL PROPERTY "${ref}" "${ARGN}" "${value}")
endfunction()

# File: source/ref/address_set.cmake

function(address_set ref)
	set_property(GLOBAL PROPERTY "${ref}" "${ARGN}")
endfunction()


# File: source/ref/address_set_new.cmake

function(address_set_new)
	address_new()
  ans(res)
	address_set(${res} "${ARGN}")
  creturn(${res})
endfunction()

# File: source/ref/address_type_get.cmake

function(address_type_get ref)
	is_address(${ref})
  ans(is_ref)
	if(NOT is_ref)
		creturn()
	endif()
	address_get("${ref}.__type__")
  ans(type)
	return_ref(type)
endfunction()

# File: source/ref/address_type_matches.cmake

function(address_type_matches ref expectedType)
	is_address(${ref})
	ans(isref)

	if(NOT isref)
		creturn(false)
	endif()
	
	address_type_get(${ref})
  ans(type)
	if(NOT "${type}" STREQUAL "${expectedType}" )
		creturn(false)
	endif()
	creturn(true)
endfunction()

# File: source/ref/is_address.cmake

function(is_address ref)
  list(LENGTH ref len)
  if(NOT ${len} EQUAL 1)
    creturn(false)
  endif()
	string(REGEX MATCH "^:" res "${ref}" )
	if(res)
		creturn(true)
	endif()
	creturn(false)
endfunction()

## faster - does not work in all cases
macro(is_address ref)
  if("_${ref}" MATCHES "^_:[^;]+$")
    set(__ans true)
  else()  
    set(__ans false)
  endif()
endmacro()


## correcter
## the version above cannot be used because 
## is_address gets arbirtray data - and since macros evaluate 
## arguments a invalid ref could be ssen as valid 
## or especially \\ fails because it beomes \ and causes an error
function(is_address ref)
  if("_${ref}" MATCHES "^_:[^;]+$")
    set(__ans true PARENT_SCOPE)
  else()  
    set(__ans false PARENT_SCOPE)
  endif()
endfunction()

# File: source/reg/reg.cmake



  ## access to the windows reg command
  function(reg)
    if(NOT CMAKE_HOST_WIN32)
      message(FATAL_ERROR "reg is not supported on non-windows platforms")
    endif()
    wrap_executable("reg" "REG")
    reg(${ARGN})
    return_ans()
  endfunction()

  function(reg_lean)

    if(NOT CMAKE_HOST_WIN32)
      message(FATAL_ERROR "reg is not supported on non-windows platforms")
    endif()
    wrap_executable_bare("reg_lean" "REG")
    reg_lean(${ARGN})
    return_ans()
  endfunction()

# File: source/reg/reg_append_if_not_exists.cmake


  ## appends all specified values to registry value if they are not contained already
  function(reg_append_if_not_exists key value_name)
    reg_read_value("${key}" "${value_name}")
    ans(values)
    set(added_values)
    foreach(arg ${ARGN})
      list_contains(values "${arg}")
      ans(res)
      if(NOT res) 
        list(APPEND values "${arg}")
        list(APPEND added_values "${arg}")
      endif()
    endforeach()

    string_decode_semicolon("${values}")
    ans(values)
    reg_write_value("${key}" "${value_name}" "${values}")
    return_ref(added_values)
  endfunction()



# File: source/reg/reg_append_value.cmake



  ## appends a value to the specified windows registry value
  function(reg_append_value key value_name)
    reg_read_value("${key}" "${value_name}")
    ans(data)
    set(data "${data};${ARGN}")
    reg_write_value("${key}" "${value_name}" "${data}")
    return_ref(data)
  endfunction()


# File: source/reg/reg_contains_value.cmake


  ### returns true if the registry value contains the specified value
  function(reg_contains_value key value_name value)
    reg_read_value("${key}" "${value_name}")
    ans(values)
    list_contains(values "${value}")
    return_ans()
  endfunction()



# File: source/reg/reg_delete_value.cmake



  ## removes the specified value from the windows registry
  function(reg_delete_value key valueName)
    string(REPLACE / \\ key "${key}")
    reg(delete "${key}" /v "${valueName}" /f --exit-code)
    ans(error)
    if(error)
      creturn(false)
    else()
      creturn(true)
    endif()
  endfunction()


# File: source/reg/reg_entry_parse.cmake



## parses the result of reg(query )call
## returns an reg entry object:
## {
##   "value_name":registry value name
##   "key":registry key
##   "value":value of the entry if it exists
##   "type": registry value type (ie REG_SZ) or KEY if its a key
## }
function(reg_entry_parse query line)
    if("${line}" MATCHES "^    ([^ ]+)")
      set(regex "^    ([^ ]+)    ([^ ]+)    (.*)")
      string(REGEX REPLACE "${regex}" "\\1" value_name "${line}")
      string(REGEX REPLACE "${regex}" "\\2" type "${line}")
      string(REGEX REPLACE "${regex}" "\\3" value "${line}")
      string_decode_semicolon("${value}")
      ans(value)
      
    else()
 # _message("line ${line}")
      set(key "${line}")
      set(type "KEY")
      set(value "")
      set(value_name "")
    endif()
    map_capture_new(key value_name type value)
    return_ans()
endfunction()


# File: source/reg/reg_prepend_value.cmake


  ## prepends a value to the specified windows registry value
  function(reg_prepend_value key value_name)
    reg_read_value("${key}" "${value_name}")
    ans(data)
    set(data "${ARGN};${data}")
    reg_write_value("${key}" "${value_name}" "${data}")
    return_ref(data)
  endfunction()


# File: source/reg/reg_query.cmake



  ## queryies the registry for the specified key
  ## returns a list of entries containing all direct child elements
  function(reg_query key)
    string(REPLACE / \\ key "${key}")
    reg(query "${key}" --process-handle)
    ans(res)

    map_tryget(${res} stdout)
    ans(output)


    map_tryget(${res} exit_code)
    ans(error)

    if(error)
      creturn()
    endif()
    
    string_encode_semicolon("${output}")
    ans(output)
    string(REPLACE "\n" ";" lines ${output})

    set(entries)
    foreach(line ${lines})
      reg_entry_parse("${key}" "${line}")
      ans(res)
      if(res)
        list(APPEND entries ${res})
      endif()
    endforeach()

    return_ref(entries)
  endfunction()

# File: source/reg/reg_query_values.cmake



  ## returns a map contains all the values in the specified registry key
  function(reg_query_values key)
    reg_query("${key}")
    ans(entries)
    map_new()
    ans(res)
    foreach(entry ${entries})
      scope_import_map(${entry})
      if(NOT "${value}_" STREQUAL "_")        
        map_set("${res}" "${value_name}" "${value}")
      endif()
    endforeach()
    return_ref(res)
  endfunction()


# File: source/reg/reg_read_value.cmake


  ## reads the specified value from the windows registry  
  function(reg_read_value key value_name)
    reg_query_values("${key}")
    ans(res)
    map_tryget(${res} "${value_name}")
    ans(res)
    
    return_ref(res)
  endfunction()


# File: source/reg/reg_remove_duplicate_values.cmake



  ## removes all duplicat values form the specified registry value
  function(reg_remove_duplicate_values key value_name)
    reg_read_value("${key}" "${value_name}")
    ans(values)
    list(REMOVE_DUPLICATES values)
    reg_write_value("${key}" "${value_name}" "${values}")
    creturn()
  endfunction()


# File: source/reg/reg_remove_value.cmake


  ## removes the specified value from the registry value
function(reg_remove_value key value_name)
  reg_read_value("${key}" "${value_name}")
  ans(values)

  list_remove(values ${ARGN})
  reg_write_value("${key}" "${value_name}" "${values}")

  creturn()

endfunction()

# File: source/reg/reg_write_value.cmake


  ## sets the specified windows registry value 
  ## value may contain semicolons
  function(reg_write_value key value_name value)
    string_encode_semicolon("${value}")
    ans(value)
    string(REPLACE / \\ key "${key}")
    set(type REG_SZ)
    reg(add "${key}" /v "${value_name}" /t "${type}" /f /d "${value}" --exit-code)
    ans(error)
    if(error)
      creturn(false)
    endif()
    creturn(true)
  endfunction()





# File: source/regex/regex_all.cmake


  function(regex_all regex)
    string(REGEX MATCHALL "${regex}" ans ${ARGN})
    return_ref(ans)
  endfunction()

# File: source/regex/regex_cmake.cmake

macro(regex_cmake)
  if(NOT __regex_cmake_included)
    set(__regex_cmake_included true)
  string_codes()

#http://www.cmake.org/cmake/help/v3.0/manual/cmake-language.7.html#grammar-token-regex_cmake_escape_sequence
  
  ## characters
  set(regex_cmake_newline "\n")
  set(regex_cmake_space_chars " \t")
  set(regex_cmake_space "[${regex_cmake_space_chars}]+")
  set(regex_cmake_backslash "\\\\")





  ## tokens

  # line comment
  set(regex_cmake_line_comment "#([^${regex_cmake_newline}]*)")
  set(regex_cmake_line_comment.comment CMAKE_MATCH_1)
  set(regex_cmake_line_comment_no_group "#([^${regex_cmake_newline}]*)")
  
  # bracket_comment
  set(regex_cmake_bracket_comment "#\\[\\[(.*)\\]\\]")
  set(regex_cmake_bracket_comment_no_group "#${bracket_open_code}${bracket_open_code}.*${bracket_close_code}${bracket_close_code}")
 
  # identifier
  set(regex_cmake_identifier "[A-Za-z_][A-Za-z0-9_]*")
  
  # nesting
  set(regex_cmake_nesting_start_char "\\(")
  set(regex_cmake_nesting_end_char "\\)")

  # quoted_argment
  set(regex_quoted_argument "\"([^\"\\]|([\\][\"])|([\\][\\])|([\\]))*\"")
  set(regex_quoted_argument_group "\"(([^\"\\]|([\\][\"])|([\\][\\])|([\\]))*)\"")
  
  # unquoted_argument
  set(regex_unquoted_argument "[^#\\\\\" \t\n\\(\\)]+")



  ## combinations

  # matches every cmake token in a string
  set(regex_cmake_token "(${regex_cmake_bracket_comment_no_group})|(${regex_cmake_line_comment_no_group})|(${regex_quoted_argument})|${regex_unquoted_argument}|${regex_cmake_space}|${regex_cmake_newline}|${regex_cmake_nesting_start_char}|${regex_cmake_nesting_end_char}")


  set(regex_cmake_line_ending "(${regex_cmake_line_comment})?(${regex_cmake_newline})")   
  set(regex_cmake_separation "(${regex_cmake_space})|(${regex_cmake_line_ending})")

  
  ## misc

  # if a value matches this it needs to be put in quotes
  set(regex_cmake_value_needs_quotes "[ \";\\(\\)]")

  set(regex_cmake_value_quote_escape_chars "[\\\\\"]")


  set(regex_cmake_flag "-?-?[A-Za-z_][A-Za-z0-9_\\-]*")
  set(regex_cmake_double_dash_flag "\\-\\-[a-zA-Z0-9][a-zA-Z0-9\\-]*")
  set(regex_cmake_single_dash_flag "\\-[a-zA-Z0-9][a-zA-Z0-9\\-]*")
  
## todo: quoted, unquoated, etc
  set(regex_cmake_argument_string ".*")
  set(regex_cmake_command_invocation "(${regex_cmake_space})*(${regex_cmake_identifier})(${regex_cmake_space})*\\((${regex_cmake_argument_string})\\)")
  set(regex_cmake_command_invocation.regex_cmake_identifier CMAKE_MATCH_2)
  set(regex_cmake_command_invocation.arguments CMAKE_MATCH_4)

  


  set(regex_cmake_function_begin "(^|${cmake_regex_newline})(${regex_cmake_space})?function(${regex_cmake_space})?\\([^\\)\\(]*\\)")
  set(regex_cmake_function_end   "(^|${cmake_regex_newline})(${regex_cmake_space})?endfunction(${regex_cmake_space})?\\(([^\\)\\(]*)\\)")
  set(regex_cmake_function_signature "(^|${cmake_regex_newline})((${regex_cmake_space})?)(${regex_cmake_identifier})((${regex_cmake_space})?)\\([${regex_cmake_space_chars}${regex_cmake_newline}]*(${regex_cmake_identifier})(.*)\\)")
  set(regex_cmake_function_signature.name CMAKE_MATCH_7)
  set(regex_cmake_function_signature.args CMAKE_MATCH_8)
  
 

  endif()
  
endmacro()



# File: source/regex/regex_common.cmake

## defines common regular expressions used in many places
macro(regex_common)

  set(regex_hex "[a-fA-F0-9]")
  set(regex_hex_2 "${regex_hex}${regex_hex}")
  set(regex_hex_4 "${regex_hex_2}${regex_hex_2}")
  set(regex_hex_8 "${regex_hex_4}${regex_hex_4}")
  set(regex_hex_12 "${regex_hex_8}${regex_hex_4}")

  set(regex_guid_ms "{(${regex_hex_8})\\-(${regex_hex_4})\\-(${regex_hex_4})\\-(${regex_hex_4})\\-(${regex_hex_12})}")



endmacro()

# File: source/regex/regex_delimited_string.cmake


## returns the regex for a delimited string 
## allows escaping delimiter with '\' backslash
function(regex_delimited_string)
  set(delimiters ${ARGN})


  if("${delimiters}_" STREQUAL "_")
    set(delimiters \")
  endif()



  list_pop_front(delimiters)
  ans(delimiter_begin)


  if("${delimiter_begin}" MATCHES ..)
    string(REGEX REPLACE "(.)(.)" "\\2" delimiter_end "${delimiter_begin}")
    string(REGEX REPLACE "(.)(.)" "\\1" delimiter_begin "${delimiter_begin}")
  else()
    list_pop_front(delimiters)
    ans(delimiter_end)
  endif()

  
  if("${delimiter_end}_" STREQUAL "_")
    set(delimiter_end "${delimiter_begin}")
  endif()
  #set(regex "${delimiter_begin}(([^${delimiter_end}])*)${delimiter_end}")
  set(delimiter_end "${delimiter_end}" PARENT_SCOPE)
  #set(regex "${delimiter_begin}(([^${delimiter_end}\\]|(\\[${delimiter_end}])|\\\\)*)${delimiter_end}")
  regex_escaped_string("${delimiter_begin}" "${delimiter_end}")
  ans(regex)
  return_ref(regex)
endfunction()


# File: source/regex/regex_escaped_string.cmake



function(regex_escaped_string delimiter_begin delimiter_end)

  set(regex "${delimiter_begin}(([^${delimiter_end}\\]|([\\][${delimiter_end}])|([\\][\\])|([\\]))*)${delimiter_end}")
  return_ref(regex)
endfunction()

# File: source/regex/regex_http.cmake


macro(http_regexes)
  #https://www.ietf.org/rfc/rfc2616
  set(http_version_regex "HTTP/[0-9]\\.[0-9]")
  set(http_header_regex "([a-zA-Z0-9_-]+): ([^\r]+)\r\n")
  set(http_headers_regex "(${http_header_regex})*")

  set(http_method_regex "GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT")
  set(http_request_uri_regex "[^ ]+")
  set(http_request_line_regex "(${http_method_regex}) (${http_request_uri_regex}) (${http_version_regex})\r\n")
  set(http_request_header_regex "(${http_request_line_regex})(${http_headers_regex})")

  set(http_status_code "[0-9][0-9][0-9]")
  set(http_reason_phrase "[^\r]+")
  set(http_response_line_regex "(${http_version_regex}) (${http_status_code}) (${http_reason_phrase})\r\n")
  set(http_response_header_regex "(${http_response_line_regex})(${http_headers_regex})")
endmacro()

# File: source/regex/regex_json.cmake

macro(regex_json)
  
  if(NOT __regex_json_defined)
    set(__regex_json_defined)
    set(regex_json_string_literal "\"([^\"\\]|([\\][\"])|([\\][\\])|([\\]))*\"")
    set(regex_json_number_literal "[0-9]+")
    set(regex_json_bool_literal "(true)|(false)")
    set(regex_json_null_literal "null")
    set(regex_json_literal "(${regex_json_string_literal})|(${regex_json_number_literal})|${regex_json_bool_literal}|(${regex_json_null_literal})")
  
    set(regex_json_string_token "\"(([\\][\\]\")|(\\\\.)|[^\"\\])*\"")

    set(regex_json_number_token "[0-9\\.eE\\+\\-]+")
    set(regex_json_bool_token "(true)|(false)")
    set(regex_json_null_token "null")
    set(regex_json_object_begin_token "{")
    set(regex_json_object_end_token "}")
    string_codes()
    set(regex_json_array_begin_token "${bracket_open_code}")
    set(regex_json_array_end_token "${bracket_close_code}")
    set(regex_json_separator_token ",")
    set(regex_json_keyvalue_token ":")
    set(regex_json_whitespace_token "[ \t\n\r]+")
    set(regex_json_token "(${regex_json_string_token})|(${regex_json_number_token})|${regex_json_bool_token}|(${regex_json_null_token})|${regex_json_object_begin_token}|${regex_json_object_end_token}|${regex_json_array_begin_token}|${regex_json_array_end_token}|${regex_json_separator_token}|${regex_json_keyvalue_token}|${regex_json_whitespace_token}")


  endif()
endmacro()

# File: source/regex/regex_match.cmake


  function(regex_match regex)
    string(REGEX MATCH "${regex}" ans ${ARGN})
    return_ref(ans)
  endfunction()

# File: source/regex/regex_match_replace.cmake


  ## match replace with easier syntax 
  ## $0-$9 is replaces with the corresponding regex match group
  function(regex_match_replace match replace)
    set(CMAKE_MATCH_0)
    set(CMAKE_MATCH_1)
    set(CMAKE_MATCH_2)
    set(CMAKE_MATCH_3)
    set(CMAKE_MATCH_4)
    set(CMAKE_MATCH_5)
    set(CMAKE_MATCH_6)
    set(CMAKE_MATCH_7)
    set(CMAKE_MATCH_8)
    set(CMAKE_MATCH_9)
    if("${ARGN}" MATCHES "${match}")
      if(replace)
        set(result "${replace}")
        foreach(i RANGE 0 9)
          string(REPLACE "$${i}" "${CMAKE_MATCH_${i}}" result "${result}")
        endforeach()
        return_ref(result)
      endif()
    endif() 
    creturn()
  endfunction()

# File: source/regex/regex_replace.cmake


  function(regex_replace regex replace)
    string(REGEX REPLACE "${regex}" "${replace}" ans ${ARGN})
    return_ref(ans)
  endfunction()

# File: source/regex/regex_uri.cmake


# contains common regular expression 
macro(regex_uri)
  if(NOT __regex_uri_included)
    set(__regex_uri_included true)
    set(lowalpha_range "a-z")
    set(lowalpha "[${lowalpha_range}]")
    set(upalpha_range "A-Z")
    set(upalpha "[${upalpha_range}]")
    set(digit_range "0-9")
    set(digit "[${digit_range}]")
    set(alpha_range "${lowalpha_range}${upalpha_range}")
    set(alpha "[${alpha_range}]")
    set(alphanum_range "${alpha_range}${digit_range}")
    set(alphanum "[${alphanum_range}]")

    set(reserved_no_slash_range "\;\\?:@&=\\+\\$,")
    set(reserved_no_slash "[${reserved_no_slash_range}]")
    set(reserved_range "\\/${reserved_no_slash_range}")
    set(reserved "[${reserved_range}]")
    set(mark_range "\\-_\\.!~\\*'\\(\\)")
    set(mark "[${mark_range}]")
    set(unreserved_range "${alpha_range}${mark_range}")
    set(unreserved "[${unreserved_range}]")
    set(hex_range "${0-9A-Fa-f}") 
    set(hex "[${hex_range}]")
    set(escaped "%${hex}${hex}")


    #set(uric "(${reserved}|${unreserved}|${escaped})")
    set(uric "[^ ]")
    set(uric_so_slash "${unreserved}|${reserved_no_slash}|${escaped}")


    set(scheme_mark_range "\\+\\-\\.")
    set(scheme_mark "[${scheme_mark_range}]")
    set(scheme_delimiter ":")

    set(scheme_regex "${alpha}[${alphanum_range}${scheme_mark_range}]*")
    
    set(net_root_regex "//")
    set(abs_root_regex "/")

    set(abs_path "\\/${path_segments}")
    set(net_path "\\/\\/${authority}(${abs_path})?")

    set(authority_char "[^/\\?#]" )
    set(authority_regex "${authority_char}+")

    set(segment_char "[^\\?#/ ]")
    set(segment_separator_char "/")


    set(path_char_regex "[^\\?#]")
    set(query_char_regex "[^#]")
    set(query_delimiter "\\?")
    set(query_regex "${query_delimiter}${query_char_regex}*")
    set(fragment_char_regex "[^ ]")
    set(fragment_delimiter_regex "#")
    set(fragment_regex "${fragment_delimiter_regex}${fragment_char_regex}*")

  #  ";" | ":" | "&" | "=" | "+" | "$" | "," 
    set(dns_user_info_char "(${unreserved}|${escaped}|[;:&=+$,])")
    set(dns_user_info_separator "@")
    set(dns_user_info_regex "(${dns_user_info_char}+)${dns_user_info_separator}")

    set(dns_port_seperator :)
    set(dns_port_regex "[0-9]+")
    set(dns_host_regex_char "[^:]")
    set(dns_host_regex "(${dns_host_regex_char}+)${dns_port_seperator}?")
      set(dns_domain_toplabel_regex "${alpha}(${alphanum}|\\-)*")
      set(dns_domain_label_separator "[.]")
    set(dns_domain_label_regex "[^.]+")
    set(ipv4_group_regex "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])")
    set(ipv4_regex "${ipv4_group_regex}[\\.]${ipv4_group_regex}[\\.]${ipv4_group_regex}[\\.]${ipv4_group_regex}")
  endif()
endmacro()

# File: source/sample/sample_copy.cmake

## sample_copy(<sample code:/[0-9][0-9]/> <?target_dir>)
##
## copies the specified sample into the specified directroy
## samples are in the <cmakepp>/samples
  function(sample_copy sample)
      set(args ${ARGN})
      list_pop_back(args)
      ans(target_dir)
      ## copy sample to test dir 
      ## and compile cmakepp to test dir
      cmakepp_config(base_dir)  
      ans(base_dir)
      
      glob("${base_dir}/samples/${sample}*")
      ans(sample_dir )
      cp_dir("${sample_dir}" "${target_dir}")
  endfunction()

# File: source/sat/bcp/bcp.cmake

## `(<f:<cnf>> <clauses:{<<index>:<literal index...>...>}> <assignments:{<<literal index>:<bool>...>} <decisions:<literal index>...>)`
## 
## propagates the unit clauses in the cnf consisting of clauses
## 
## propagates assignment values for the specified `<decisions>`
## sets literal assignments in <assignments>
## returns the indices of the deduced literals
## returns "conflict" if an assignment conflicts with an existing one in <assignments>
## returns "unsatisfied" if cnf is unsatisfiable 
## 
function(bcp f clauses assignments)
  #map_import_properties(${f} literal_inverse_map) ## simplification inverse = i+-1

  # bcp_deduce_assignments("${f}" "${clauses}" "${assignments}")
  # ans(deduced_assignments)

  # if("${deduced_assignments}" MATCHES "(conflict)|(unsatisfied)")
  #   return_ref(deduced_assignments)
  # endif()
  
  # set(all_deductions ${deduced_assignments})
 #set(propagation_queue ${deduced_assignments} ${ARGN})
 set(propagation_queue ${ARGN})
  while(true)
    ## dedpuce assignments
    bcp_deduce_assignments("${f}" "${clauses}" "${assignments}")
    ans(deduced_assignments)

    if("${deduced_assignments}" MATCHES "(conflict)|(unsatisfied)")
      return_ref(deduced_assignments)
    endif()

    list(APPEND propagation_queue ${deduced_assignments})
    list(APPEND all_deductions ${deduced_assignments})
    list_remove_duplicates(propagation_queue)

    list(LENGTH propagation_queue continue)
    if(NOT continue)
      break()
    endif()


    
    list_pop_front(propagation_queue)
    ans(li)

    map_tryget(${assignments} ${li})
    ans(vi)

    bcp_simplify_clauses("${f}" "${clauses}" "${li}" "${vi}")
  endwhile()
  return_ref(all_deductions)
endfunction()


# File: source/sat/bcp/bcp_assignment_add.cmake

## `()->`
##
## tries to add a assignment for literal li
## if the assignment does not exist it is set and true is returned
## if an assignment exists and it conflicts with the new assignemnt return false
## if the assignment exists and is equal to the new assignment nochange is returned
## if(result) => ok
## if(NOT result) => conflict
function(bcp_assignment_add f assignments li value)
#  print_vars(assignments li value)
  map_tryget("${assignments}" ${li})
  ans(existing_value)
  if("${existing_value}_" STREQUAL "_")
    map_set(${assignments} ${li} ${value})
    creturn(true)
  elseif(NOT "${existing_value}" STREQUAL "${value}")
    creturn(false)
  endif()
  creturn(nochange)
endfunction()

# File: source/sat/bcp/bcp_deduce_assignments.cmake

## `()->`
##
## takes a list of clauses and deduces all assignments from unit clauses
## storing them in assignments and returning their literal indices
## returns conflict if a deduced assignment conflicts with an existing assignment
## return unsatisfied if clauses contains at least one unsatisfiable clause
function(bcp_deduce_assignments f clauses assignments)
    map_import_properties(${f} literal_inverse_map)
    bcp_extract_unit_clauses("${f}" "${clauses}")
    ans(unit_clauses)


    if("${unit_clauses}" MATCHES "unsatisfied")
      creturn(unsatisfied)
    endif()

    set(deduced_assignments)
    foreach(unit_clause ${unit_clauses})
      bcp_assignment_add("${f}" "${assignments}" "${unit_clause}" true)
      ans(ok)
      if(NOT ok)
        creturn(conflict)
      endif()

      map_tryget(${literal_inverse_map} ${unit_clause})
      ans(unit_clause_inverse)

     # print_vars(unit_clause unit_clause_inverse)

      bcp_assignment_add("${f}" "${assignments}" "${unit_clause_inverse}" false)
      ans(ok)
    #  print_vars(ok)
      if(NOT ok)
        creturn(conflict)
      endif()
      #  messaGE(FORMAT "  deduced {f.literal_map.${unit_clause}} to be true ")
      #  messaGE(FORMAT "  deduced {f.literal_map.${unit_clause_inverse}} to be false ")

      list(APPEND deduced_assignments ${unit_clause}  ${unit_clause_inverse} )
    endforeach()
    list_remove_duplicates(deduced_assignments)
    return_ref(deduced_assignments)
endfunction()

# File: source/sat/bcp/bcp_extract_unit_clauses.cmake

## `()->`
##
## returns unsatisfied if a clause is unsatisfieable
## returns indices of unit_clauses' literal
## else returns nothing 
## sideffect updates clauses map removes unit clauses
function(bcp_extract_unit_clauses f clauses)
 # map_import_properties(${f})
  map_keys(${clauses})
  ans(clause_indices)

  set(unit_literals)

  foreach(ci ${clause_indices})
    # ## get clause's literal indices
    map_tryget(${clauses} ${ci})
    ans(clause)

    if("${clause}_" STREQUAL "_")
      creturn(unsatisfied)
    endif()

    ## check if clause has become unit
    list(LENGTH clause literal_count)
    if("${literal_count}" EQUAL 1)
      ## if so remove it and collect the unit literal
      map_remove(${clauses} ${ci})
      list(APPEND unit_literals ${clause})
    else()
      ## update clause 
      map_set(${clauses} ${ci} ${clause})
    endif()

  endforeach()
  return_ref(unit_literals)
endfunction()


# File: source/sat/bcp/bcp_pure_literals_assign.cmake

## `(...)->...` 
##
## 
## assigns all pure literals (and there inverse) 
## removes all clauses an containing one from clauses
## returns all indices of pure literals
## returns conflict if a pure literal assignment conflicts with an existing one
function(bcp_pure_literals_assign f clauses assignments)
  bcp_pure_literals_find(${f} ${clauses})
  ans(pure_literals)

  if("${pure_literals}_" STREQUAL "_")
    creturn()
  endif()

  map_import_properties(${f} literal_inverse_map)

 # print_vars(assignments pure_literals)

  ## set assignments
  foreach(pure_literal ${pure_literals})
    bcp_assignment_add(${f} ${assignments} ${pure_literal} true)
    ans(ok)
    if(NOT ok)
      creturn(conflict)
    endif()

    map_tryget(${literal_inverse_map} ${pure_literal})
    ans(inverse)

    bcp_assignment_add(${f} ${assignments} ${inverse} false)
    ans(ok)
    if(NOT ok)
      creturn(conflict)
    endif()
  endforeach()

  ## remove clauses containing pure literal
  map_keys(${clauses})
  ans(clause_indices)

  foreach(ci ${clause_indices})
    map_tryget(${clauses} ${ci})
    ans(clause)

    list_contains_any(clause ${pure_literals})
    ans(contains_any)
  
    if(contains_any)
      map_remove(${clauses} ${ci})
    endif()      
  endforeach()
  return_ref(pure_literals)
endfunction()

# File: source/sat/bcp/bcp_pure_literals_find.cmake

## `(<f:<cnf>> <clauses:{<<clause index>:<literal index...>...>}>)-><literal index...>`
##
## returns a list of literal indices of pure literals in clauses
function(bcp_pure_literals_find f clauses)
  map_import_properties(${f} literal_inverse_map)
  map_values(${clauses})
  ans(clause_literals)

  ## if all clauses are empty return nothing
  if("${clause_literals}_" STREQUAL "_")
    creturn()
  endif()

  ## loop through all literals of all clauses and check if its inverse was 
  ## not found append it to pure_literals (which are returned)
  list(REMOVE_DUPLICATES clause_literals)
  set(pure_literals)
  while(NOT "${clause_literals}_" STREQUAL "_")
    list_pop_front(clause_literals)
    ans(current_literal)

    map_tryget(${literal_inverse_map} ${current_literal})
    ans(inverse_literal)

    list(FIND clause_literals ${inverse_literal} inverse_found)

    if(${inverse_found} LESS 0)
      ## current literal is pure
      list(APPEND pure_literals ${current_literal})
    else()
      list(REMOVE_AT clause_literals ${inverse_found})
    endif()
  endwhile()

  return_ref(pure_literals)
endfunction()


# File: source/sat/bcp/bcp_simplify_clause.cmake

## `(<f:<cnf>> <clause:<literal index...>> <li:literal index> <value:<bool>>)-><literal index..>|"satisfied"`
##
## returns `"satisfied"` if clause is satisfied by literal assignment
## returns `<null>` if clause is unsatisfiable
## returns clause with `<li>` removed if `<value>` is false
function(bcp_simplify_clause f clause li value)
  list(FIND clause ${li} found)

  if("${found}" LESS 0)
    ## literal not found in clause -> no change 
    ## if clause was unsatisfied it stays unsatisfied
    return_ref(clause)
  endif()

  if(value)
    ## literal is in clause and is true => clause is satisfied
    creturn(satisfied)
  endif()

  ## if clause is not unsatisfied
  ## remove false value from clause as it does not change the result of clause
  if(clause)
    list(REMOVE_ITEM clause ${li})
  endif()

  ## return rest of clause
  ## if clause was unsatisfied it stays unsatisfied
  return_ref(clause)
endfunction()

# File: source/sat/bcp/bcp_simplify_clauses.cmake

## `()->`
##
## takes a set of clauses and simplifies them by 
## setting li to value
## removes all li that are false from clauses
## removes clauses which are satisfied
function(bcp_simplify_clauses f clauses li value)
 # map_import_properties(${f})

  map_keys(${clauses})
  ans(clause_indices)

  set(unit_literals)

  foreach(ci ${clause_indices})
    ## get clause's literal indices
    map_tryget(${clauses} ${ci})
    ans(clause)

    ## propagate new literal value to clause
    bcp_simplify_clause("${f}" "${clause}" "${li}" "${value}")
    ans(clause)

    if("${clause}_" STREQUAL "satisfied_")
      ## remove clause because it is always true
      map_remove("${clauses}" "${ci}")
    else()
      map_set(${clauses} ${ci} ${clause})
    endif()
  endforeach()
endfunction()

# File: source/sat/cnf.cmake

## `(<clause map: <sequence>>)-> <cnf>`
##
##  
## 
## creates a conjunctive normal form from the specified input
## ```
## <cnf> ::= {
##   c_n : <uint>  # the number of clauses
##   c_last : <int>  # c_n - 1
##   clause_map : { <<clause index>:<clause>>... }
##   clause_atom_map : { <<clause index> : <atom index>... >...}
##   clause_literal_map : { <<clause index> : <literal index>...>...}
##   
##   a_n : <uint> # the number of atoms
##   a_last : <int>  # a_n - 1 
##   atom_map : { <<atom index>:<atom>>... }
##   atom_clause_map  : { <<atom index>:<clause index>...>...}
##   atom_literal_map :  {}
##   atom_literal_negated_map : {}
##   atom_literal_identity_map : {}
##   atom_index_map : {}
##   
##   l_n : <uint>
##   l_last : <int>
##   literal_map : {}
##   literal_atom_map : {}
##   literal_inverse_map : {}
##   literal_negated_map : {}
##   literal_index_map : {}
##   literal_clause_map : {}
## }
## ```
function(cnf clause_map)

  map_keys("${clause_map}")
  ans(clause_indices)

  sequence_new()
  ans(literal_map)
  sequence_new()
  ans(atom_map)
  sequence_new()
  ans(atom_literal_map)
  sequence_new()
  ans(literal_atom_map)
  map_new()
  ans(literal_index_map)
  map_new()
  ans(atom_index_map)
  sequence_new()
  ans(literal_negated_map)
  sequence_new()
  ans(literal_inverse_map)
  sequence_new()
  ans(atom_literal_negated_map)
  sequence_new()
  ans(atom_literal_identity_map)

  map_values(${clause_map})
  ans(tmp)
  set(literals)
  foreach(literal ${tmp})
    if("${literal}" MATCHES "^!?(.+)")
      list(APPEND literals ${CMAKE_MATCH_1})
    endif()
  endforeach()
  list_remove_duplicates(literals)

  foreach(literal ${literals})
      sequence_add(${atom_map} "${literal}")
      ans(ai)
      sequence_add(${literal_map} "${literal}")
      ans(li)
      sequence_add(${literal_map} "!${literal}")
      ans(li_neg)

      sequence_add(${literal_negated_map} false)
      sequence_add(${literal_negated_map} true)
      sequence_add(${atom_literal_map} ${li} ${li_neg})

      sequence_add(${literal_atom_map} ${ai})
      sequence_add(${literal_atom_map} ${ai})
      
      sequence_add(${atom_literal_negated_map} ${li_neg})
      sequence_add(${atom_literal_identity_map} ${li})

      sequence_add(${literal_inverse_map} ${li_neg})
      sequence_add(${literal_inverse_map} ${li})

      map_set(${literal_index_map} "${literal}" ${li})
      map_set(${literal_index_map} "!${literal}" ${li_neg})
      map_set(${atom_index_map} "${literal}" "${ai}")

  endforeach()

  map_new()
  ans(clause_atom_map)

  map_new()
  ans(clause_literal_map)

  map_new()
  ans(literal_clause_map)

  map_new()
  ans(atom_clause_map)

  foreach(ci ${clause_indices})
    map_tryget("${clause_map}" ${ci})
    ans(clause)
    map_set(${clause_atom_map} ${ci})
    map_set(${clause_literal_map} ${ci})
    foreach(literal ${clause})
      
      map_tryget(${literal_index_map} "${literal}")
      ans(li)

      map_tryget(${literal_atom_map} ${li})
      ans(ai)

      map_append_unique(${clause_atom_map} ${ci} ${ai})
      map_append_unique(${clause_literal_map} ${ci} ${li})
      map_append_unique(${literal_clause_map} ${li} ${ci})
      map_append_unique(${atom_clause_map} ${ai} ${ci})
    endforeach()
  endforeach()

  sequence_count(${clause_map})
  ans(c_n)
  math(EXPR c_last "${c_n} - 1")

  sequence_count(${literal_map})
  ans(l_n)
  math(EXPR l_last "${l_n} - 1")

  sequence_count(${atom_map})
  ans(a_n)
  math(EXPR a_last "${a_n} - 1")
  #json_print(${clause_map})

  map_capture_new(
    c_n
    c_last
    clause_map
    clause_atom_map
    clause_literal_map

    a_n
    a_last
    atom_map
    atom_clause_map
    atom_literal_map
    atom_literal_negated_map
    atom_literal_identity_map
    atom_index_map

    l_n 
    l_last
    literal_map
    literal_atom_map
    literal_inverse_map
    literal_negated_map
    literal_index_map
    literal_clause_map
  )
  ans(cnf)

  return_ref(cnf)

endfunction()

# File: source/sat/cnf_from_encoded_list.cmake


  function(cnf_from_encoded_list)
    arguments_sequence(0 ${ARGC})
    ans(clauses)
    cnf("${clauses}")
    return_ans()
  endfunction()

# File: source/sat/create_watch_list.cmake

##
##
##
function(create_watch_list f assignments)   
  map_new()
  ans(watch_list)
  
  map_tryget(${f} c_last)
  ans(c_last)
    
  foreach(ci RANGE 0 ${c_last})
    update_watch_list_clause("${f}" "${watch_list}" "${assignments}" "${ci}")
  endforeach()

  return_ref(watch_list)
endfunction()


# File: source/sat/dp/dp_naive.cmake

##
##
## naive implementation of Basic Davis-Putnam Backtrack Search
## http://www.princeton.edu/~chaff/publication/DAC2001v56.pdf
##
function(dp_naive f)
  dp_naive_init(${f})
  ans(context)
  set(initial_context ${context})
  while(true)
    ## decide which literal to try next to satisfy clauses
    ## returns true if decision was possible
    ## if no decision is made all clauses are satisfied
    ## and the algorithm terminates with success
    dp_naive_decide()
    ans(decision)
    if(NOT decision)
      dp_naive_finish(satsifiable)
      return_ans()
    endif()

    ## propagate decision 
    ## if a conflict occurs backtrack 
    ## when backtracking is impossible the algorithm terminates with failure
    while(true)

      dp_naive_bcp()
      ans(bcp)
      if(bcp)
        break()
      endif()

      ## backtrack 
      dp_naive_resolve_conflict()
      ans(resolved)

      if(NOT resolved)
        dp_naive_finish(not_satisfiable)
        return_ans()
      endif()
    endwhile()
  endwhile()

  message(FATAL_ERROR "unreachable code")
endfunction()


function(dp_naive_finish outcome)
  
  if("${outcome}" STREQUAL "satsifiable")
    map_peek_back(${context} decision_stack)
    ans(dl)
    map_tryget(${dl} assignments)
    ans(assignments)

    map_new()
    ans(result)
    map_set(${result} success true)
    map_set(${result} outcome ${outcome})
    map_set(${result} context ${context})
    map_set(${result} initial_context ${initial_context})
    map_set(${result} assignments ${assignments})
    creturn(${result})
  else()

    map_new()
    ans(result)
    map_set(${result} success false)
    map_set(${result} outcome ${outcome})
    map_set(${result} context ${context})
    map_set(${result} initial_context ${initial_context})
    #map_set(${result} assignments)
    creturn(${result})
  endif()
  creturn()
endfunction()


function(dp_naive_init f)
  map_import_properties(${f} clause_literal_map)
  ## add decision layer NULL to decision stack
  
  map_new()
  ans(assignments)
  map_duplicate(${clause_literal_map})
  ans(clauses)

  map_new()
  ans(decision_layer)
  map_set(${decision_layer} depth 0)
  map_set(${decision_layer} decision ${decision})
  map_set(${decision_layer} value false)
  map_set(${decision_layer} tried_both_ways false)
  map_set(${decision_layer} clauses ${clauses})
  map_set(${decision_layer} assignments "${assignments}")
  map_set(${decision_layer} parent)


  map_new()
  ans(context)

  map_set(${context} f ${f})
  map_set(${context} decision_stack ${decision_layer})

  creturn(${context})
endfunction()

function(dp_naive_push_decision parent decision value tried_both_ways)

  map_import_properties(${parent} clauses assignments)

  map_tryget(${context} decision_stack)
  ans(decision_stack)
  list(LENGTH decision_stack decision_depth)

  map_duplicate(${clauses})
  ans(clauses)

  map_duplicate(${assignments})
  ans(assignments)

  map_new()
  ans(dl)

  map_set(${dl} depth ${decision_depth})
  map_set(${dl} decision ${decision})
  map_set(${dl} value ${value})
  map_set(${dl} tried_both_ways ${tried_both_ways})
  map_set(${dl} clauses ${clauses})
  map_set(${dl} assignments ${assignments})
  map_set(${dl} parent ${parent})
  #message(PUSH FORMAT "decided {decision} (DL{dl.depth} {context.f.literal_map.${decision}}={value})")

  map_push_back(${context} decision_stack ${dl})
endfunction()

## return false if no unassigned variables remain
## true otherwise
## adds new decision layer to decision stack
function(dp_naive_decide)
  map_peek_back(${context} decision_stack)
  ans(dl)

  map_import_properties(${dl} clauses)
  map_values(${clauses})
  ans(unassigned_literals)


  list(LENGTH unassigned_literals unassigned_literals_count)
  if(NOT unassigned_literals_count)
    creturn(false)
  endif()

  list(GET unassigned_literals 0 decision)

  dp_naive_push_decision(${dl} ${decision} true false)
  creturn(true)
endfunction()

function(dp_naive_bcp)
  map_import_properties(${context} f)

  map_peek_back(${context} decision_stack)
  ans(dl)

  map_import_properties(${dl} decision value clauses assignments)
  map_set(${assignments} ${decision} ${value})
  
  #print_vars(clauses assignments)
  bcp("${f}" "${clauses}" "${assignments}" ${decision})
  ans(result)
  #print_vars(clauses assignments)

  #message(FORMAT "propagating {context.f.literal_map.${decision}} = ${value} => deduced: ${result}")
  #foreach(li ${result})
   # message(FORMAT "  {context.f.literal_map.${li}}=>{assignments.${li}}")
 # endforeach()
  if("${result}" MATCHES "(conflict)|(unsatisfied)")
    creturn(false)
  endif()

  creturn(true)
endfunction()



function(dp_naive_resolve_conflict)
  map_import_properties(${context} f)

  ## undo decisions until a decision is found which was not 
  ## tried the `other way` ie inversing the literals value
  set(conflicting_decision)
  while(true)
    map_pop_back(${context} decision_stack)
    ans(dl)
    ## store conflicting_decision
    map_set(${dl} conflicting_decision ${conflicting_decision})
    set(conflicting_decision ${dl})
    map_tryget(${dl} tried_both_ways)
    ans(tried_both_ways)
    if(NOT tried_both_ways)
      break()
    endif()
  endwhile()


  # d = most recent decision not tried `both ways`
  map_tryget(${dl} decision)
  ans(d)
  if("${d}_" STREQUAL "_")
    ## decision layer 0 reached -> cannot resolve
    creturn(false)
  endif()


  ## flip value
  map_tryget(${dl} value)
  ans(value)
  eval_truth(NOT value)
  ans(value)

  map_tryget(${dl} parent)
  ans(parent)

  ## pushback decision layer with value inverted
  dp_naive_push_decision(${parent} ${d} ${value} true)

  creturn(true)
endfunction()

# File: source/sat/update_watch_list.cmake

##
##
## updates the watch list 
## removes newly assigned literal
## add watches to next unassigned literal 
function(update_watch_list f watch_list assignments new_assignment)

  map_tryget("${watch_list}" ${new_assignment})
  ans(watched_clauses)

  map_remove("${watchlist}" ${new_assignment})

  map_tryget(${f} clause_literals)
  ans(clause_literals)

  foreach(watched_clause ${watched_clauses})
    update_watch_list_clause("${f}" "${watch_list}" "${assignments}" "${watched_clause}")
  endforeach()

endfunction()

# File: source/sat/update_watch_list_clause.cmake

##
##
## updates a single clause int the watch list
function(update_watch_list_clause f watch_list assignments watched_clause)
  map_tryget("${f}" clause_literals)
  ans(clause_literals)

  map_tryget(${clause_literals} ${watched_clause})
  ans(watched_clause_literals)
  
  ## loop through all literals for watched clause
  ## get the currently watched literals from watch clause
  set(current_watch_count 0)

  while(${current_watch_count} LESS 2 AND NOT "${watched_clause_literals}_" STREQUAL "_" )
    list_pop_front(watched_clause_literals)
    ans(current_literal)
    if(NOT "${current_literal}" EQUAL "${new_assignment}")
      map_tryget("${assignments}" "${new_assignment}")
      ans(is_assigned)
      if(NOT is_assigned)
        map_append_unique("${watch_list}" "${current_literal}" "${watched_clause}")
        math(EXPR current_watch_count "${current_watch_count} + 1")
      endif()
    endif()
  endwhile()
endfunction()


# File: source/sat/utilities/atom_to_literal_assignments.cmake

##
##
function(atom_to_literal_assignments f atom_assignments)
  map_import_properties(${f} atom_index_map atom_literal_identity_map atom_literal_negated_map)

  map_keys(${atom_assignments})
  ans(atoms)
  map_new()
  ans(result)
  foreach(atom ${atoms})
    map_tryget(${atom_index_map} ${atom})
    ans(ai)
    map_tryget(${atom_literal_identity_map} ${ai})
    ans(li)
    map_tryget(${atom_literal_negated_map} ${ai})
    ans(li_negated)
    map_tryget(${atom_assignments} ${atom})
    ans(value)
    eval_truth(NOT value)
    ans(value_negated)
    map_set(${result} ${li} ${value})
    map_set(${result} ${li_negated} ${value_negated})
  endforeach()
  return_ref(result)
endfunction()


# File: source/sat/utilities/literal_to_atom_assignments.cmake



## takes a literal assignment model 
## returns the atom assignments
function(literal_to_atom_assignments f literal_assignments)
  map_tryget(${f} l_last)
  ans(l_last)
  map_tryget(${f} literal_negated_map)
  ans(literal_negated_map)
  map_tryget(${f} literal_atom_map)
  ans(literal_atom_map)
  map_tryget(${f} atom_map)
  ans(atom_map)
  map_new()
  ans(atom_assignments)
  foreach(i RANGE 0 ${l_last})
    map_tryget(${literal_assignments} ${i})
    ans(value)
  #  print_vars(i value)
    if(NOT "${value}_" STREQUAL "_")
      map_tryget(${literal_atom_map} ${i})
      ans(ai)

      map_tryget(${atom_map} ${ai})
      ans(atom_name)

      #print_vars(atom_map atom_name ai)

      map_tryget(${literal_negated_map} ${i})
      ans(negated)
      #message("value ${atom_name} ${i} ${value}")
      if(negated)
        eval_truth(NOT value)
        ans(value)
      endif()

      map_set(${atom_assignments} ${atom_name} ${value})
    endif()
  endforeach()  
  return_ref(atom_assignments)
endfunction()



# File: source/sat/utilities/print_cnf.cmake


  function(print_cnf f)
    scope_import_map(${f})
    print_multi(${c_last} clauses clause_literals clause_atoms)
    print_multi(${a_last} atoms atom_literals atom_clauses)
    print_multi(${l_last} literals literal_inverse literal_negated literal_clauses literal_atom)

  endfunction()

  ## new
  function(cnf_print f)
    scope_import_map(${f})
    print_multi(${c_last} clause_map clause_literal_map clause_atom_map)
    print_multi(${a_last} atom_map atom_literal_map atom_clause_map)
    print_multi(${l_last} literal_map literal_inverse_map literal_negated_map literal_clause_map literal_atom_map)

  endfunction()

# File: source/sat/watch_list/create_watch_list.cmake



function(create_watch_list f assignments)   
  map_new()
  ans(watch_list)
  
  map_tryget(${f} c_last)
  ans(c_last)
    
  foreach(ci RANGE 0 ${c_last})
    update_watch_list_clause("${f}" "${watch_list}" "${assignments}" "${ci}")
  endforeach()

  return_ref(watch_list)
endfunction()


# File: source/sat/watch_list/update_watch_list.cmake


  ## updates the watch list 
  ## removes newly assigned literal
  ## add watches to next unassigned literal 
  function(update_watch_list f watch_list assignments new_assignment)

    map_tryget("${watch_list}" ${new_assignment})
    ans(watched_clauses)

    map_remove("${watchlist}" ${new_assignment})

    map_tryget(${f} clause_literals)
    ans(clause_literals)

    foreach(watched_clause ${watched_clauses})
      update_watch_list_clause("${f}" "${watch_list}" "${assignments}" "${watched_clause}")
    endforeach()

  endfunction()

# File: source/sat/watch_list/update_watch_list_clause.cmake



## updates a single clause int the watch list
function(update_watch_list_clause f watch_list assignments watched_clause)
  map_tryget("${f}" clause_literals)
  ans(clause_literals)

  map_tryget(${clause_literals} ${watched_clause})
  ans(watched_clause_literals)
  
  ## loop through all literals for watched clause
  ## get the currently watched literals from watch clause
  set(current_watch_count 0)

  while(${current_watch_count} LESS 2 AND NOT "${watched_clause_literals}_" STREQUAL "_" )
    list_pop_front(watched_clause_literals)
    ans(current_literal)
    if(NOT "${current_literal}" EQUAL "${new_assignment}")
      map_tryget("${assignments}" "${new_assignment}")
      ans(is_assigned)
      if(NOT is_assigned)
        map_append_unique("${watch_list}" "${current_literal}" "${watched_clause}")
        math(EXPR current_watch_count "${current_watch_count} + 1")
      endif()
    endif()
  endwhile()
endfunction()


# File: source/scope/scope_clear.cmake

# clears the current local scope of any variables
function(scope_clear)
  scope_keys()
  ans(vars)
  foreach (var ${vars})
    set(${var} PARENT_SCOPE)
  endforeach()
endfunction()

# File: source/scope/scope_export_map.cmake

# Exports the curretn scope of local variables into a map
function(scope_export_map)
  get_cmake_property(_variableNames VARIABLES)
  map_new()
  ans(_exportmapname)
  foreach (_variableName ${_variableNames})
    map_set("${_exportmapname}" "${_variableName}" "${${_variableName}}")
  endforeach()
  return_ref(_exportmapname)
endfunction()

# File: source/scope/scope_import_map.cmake

# creates a local variable for every key value pair in map
# if the optional prefix is given this will be prepended to the variable name
function(scope_import_map map)
	set(prefix ${ARGN})

	map_keys(${map})
	ans(keys)

	foreach(key ${keys})
		map_tryget(${map}  ${key})
		ans(value)
		set("${prefix}${key}" ${value} PARENT_SCOPE)
	endforeach()
endfunction()

# File: source/scope/scope_keys.cmake



# returns all currently defined variables of the local scope
function(scope_keys)
  get_cmake_property(_variableNames VARIABLES)
  return_ref(_variableNames)
endfunction()

# File: source/scope/scope_print.cmake

# print the local scope as json
function(scope_print)
  scope_export_map()
  ans(scope)
  json_print(${scope})
  creturn()
endfunction()

# File: source/semver/semver.cmake

function(semver string_or_version)
  if(NOT string_or_version)
    creturn()
  endif()
  is_map(${string_or_version} )
  ans(ismap)
  if(ismap)
    creturn(${string_or_version})
  endif()
  semver_parse_lazy(${string_or_version})
  ans(version)
  creturn(${version})
endfunction()

# File: source/semver/semver_compare.cmake

# compares the semver on the left and right
# returns -1 if left is more up to date
# returns 1 if right is more up to date
# returns 0 if they are the same
function(semver_compare  left right)
 semver_parse(${left} )
 ans(left)
 semver_parse(${right})
 ans(right)


  scope_import_map(${left} left_)
  scope_import_map(${right} right_)

 semver_component_compare( ${left_major} ${right_major})
 ans(cmp)
 if(NOT ${cmp} STREQUAL 0)
  creturn(${cmp})
endif()
 semver_component_compare( ${left_minor} ${right_minor})
 ans(cmp)
 if(NOT ${cmp} STREQUAL 0)
  creturn(${cmp})
endif()
 
 semver_component_compare( ${left_patch} ${right_patch})
 ans(cmp)
 if(NOT ${cmp} STREQUAL 0)
  creturn(${cmp})
endif()


 if(right_prerelease AND NOT left_prerelease)
  creturn(-1)
 endif()

 if(left_prerelease AND NOT right_prerelease)
  creturn(1)
 endif()
 # iterate through all identifiers of prerelease
 while(true)
    list_pop_front(left_tags)
    ans(left_current)

    list_pop_front(right_tags)
    ans(right_current)

    # check for larger set
    if(right_current AND NOT left_current)
      creturn(1)
    elseif(left_current AND NOT right_current)
      creturn(-1)
    elseif(NOT left_current AND NOT right_current)
      # equal
      creturn(0)
    endif()

      # compare component
   semver_component_compare( ${left_current} ${right_current})
ans(cmp)

   #   message("asd '${left_current}'  '${right_current}' -> ${cmp}")
   if(NOT ${cmp} STREQUAL 0)
    creturn(${cmp})
   endif()



    
 endwhile()
 
 creturn(0)

endfunction()

# File: source/semver/semver_component_compare.cmake


 function(semver_component_compare left right)
 # message("comapring '${left}' to '${right}'")
    string_isempty( "${left}")
    ans(left_empty)
    string_isempty( "${right}")
    ans(right_empty)

    # filled has precedence before nonempty
    if(left_empty AND right_empty)
      creturn(0)
    elseif(left_empty AND NOT right_empty)
      creturn(1)
    elseif(right_empty AND NOT left_empty)
      creturn(-1)
    endif() 


    string_isnumeric( "${left}")
    ans(left_numeric)
    string_isnumeric( "${right}")
    ans(right_numeric)

    # if numeric has precedence before alphanumeric
    if(right_numeric AND NOT left_numeric)
      creturn(-1)
    elseif(left_numeric AND NOT right_numeric)
      creturn(1)
    endif()


   
    if(left_numeric AND right_numeric)
      if(${left} LESS ${right})
        creturn(1)
      elseif(${left} GREATER ${right})
        creturn(-1)
      endif()
      creturn(0)
    endif()

    if("${left}" STRLESS "${right}")
      creturn(1)
    elseif("${left}" STRGREATER "${right}")
      creturn(-1)
    endif()

    creturn(0)
 endfunction()

# File: source/semver/semver_constraint.cmake



function(semver_constraint constraint_ish)
  map_get_special(${constraint_ish} "semver_constraint")
  ans(is_semver_constraint)
  if(is_semver_constraint)
    return_ref(constraint_ish)
  endif()

  is_map(${constraint_ish})
  ans(ismap)
  if(ismap)
    creturn()
  endif()

  # return cached value if it exists
 # cache_return_hit("${constraint_ish}")

  # compute and cache value
  semver_constraint_compile("${constraint_ish}")
  ans(constraint)
  # cache_update("${constraint_ish}" "${constraint}" const)

  return_ref(constraint)

endfunction()

# File: source/semver/semver_constraint_compile.cmake

function(semver_constraint_compile constraint)
  set(ops "\\(\\)\\|,!=~><")
    
  if("${constraint}" STREQUAL "*")
    set(constraint ">=0.0.0")
  endif()
  string(REGEX REPLACE ">=([^${ops}]+)" "(>\\1|=\\1)" constraint "${constraint}")
  string(REGEX REPLACE "<=([^${ops}]+)" "(<\\1|=\\1)" constraint "${constraint}")


  string(REPLACE "!" ";NOT;" constraint "${constraint}")
  string(REPLACE "," ";AND;" constraint "${constraint}")
  string(REPLACE "|" ";OR;" constraint "${constraint}")
  string(REPLACE ")" ";);" constraint "${constraint}")
  string(REPLACE "(" ";(;" constraint "${constraint}")
  set(elements ${constraint})
  if(elements)
    list(REMOVE_DUPLICATES elements)
    list(REMOVE_ITEM elements "AND" "OR" "NOT" "(" ")" )
  endif()
  foreach(element ${elements})
    semver_constraint_element_isvalid(${element})
    ans(isvalid)
    if(NOT isvalid)
      creturn()
    endif()
  endforeach()
 # message("constraint ${constraint}")
 # message("elements ${elements}")
  nav(compiled_constraint.template "${constraint}")
  nav(compiled_constraint.elements "${elements}")
  map_set_special(${compiled_constraint} "semver_constraint" true)
  creturn(${compiled_constraint})

endfunction()


# File: source/semver/semver_constraint_compiled_evaluate.cmake


function(semver_constraint_compiled_evaluate compiled_constraint version )
  map_import_properties(${compiled_constraint} elements template)

  foreach(element ${elements})
    semver_constraint_evaluate_element("${element}" "${version}")
    ans(res)
    string(REPLACE "${element}" "${res}" template "${template}")
  endforeach()

  if(${template})
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/semver/semver_constraint_element_isvalid.cmake


  function(semver_constraint_element_isvalid element)
    string(REGEX MATCH "^[~\\>\\<=!]?([0-9]+)(\\.[0-9]+)?(\\.[0-9]+)?(-[a-zA-Z0-9\\.-]*)?(\\+[a-zA-Z0-9\\.-]*)?$" match "${element}")
    if(match)
      creturn(true)
    else()
      creturn(false)
    endif()
  endfunction()

# File: source/semver/semver_constraint_evaluate.cmake

# checks if the constraint holds for the specified version
function(semver_constraint_evaluate  constraint version)
  semver_constraint_compile("${constraint}")
  ans(compiled_constraint)
  #message("cc ${compiled_constraint}")
  if(NOT compiled_constraint)
    creturn(false)
  endif()
  semver_constraint_compiled_evaluate("${compiled_constraint}" "${version}")
  ans(res)
  #message("eval ${res}")
  creturn(${res})
endfunction()

# File: source/semver/semver_constraint_evaluate_element.cmake


function(semver_constraint_evaluate_element constraint version)
  string(STRIP "${constraint}" constraint)
  set(constraint_operator_regexp "^(\\<|\\>|\\~|=|!)")
  set(constraint_regexp "${constraint_operator_regexp}?(.+)$")
  string(REGEX MATCH "${constraint_regexp}" match "${constraint}")
  if(NOT match )
    return_value(false)
  endif()
  set(operator)
  set(argument)

  string(REGEX MATCH "${constraint_operator_regexp}" has_operator "${constraint}")
  if(has_operator)
    string(REGEX REPLACE "${constraint_regexp}" "\\1" operator "${constraint}")
    string(REGEX REPLACE "${constraint_regexp}" "\\2" argument "${constraint}")      
  else()
    set(operator "=")
    set(argument "${constraint}")
  endif()

  # check for equality
  if(${operator} STREQUAL "=")
    semver_normalize("${argument}")    
    semver_format("${argument}")
    ans(argument)
    semver_compare( "${version}" "${argument}")
    ans(cmp)
    if("${cmp}" EQUAL "0")
      creturn(true)
    endif()
    creturn(false)
  endif()

  # check if version is greater than constraint
  if(${operator} STREQUAL ">")
    semver_normalize("${argument}")    
    semver_format("${argument}")
    ans(argument)
    semver_compare( "${version}" "${argument}")
    ans(cmp)
    if("${cmp}" LESS 0)
      creturn(true)
    endif()
    creturn(false)
  endif()

  # cheick  if version is less than constraint
  if(${operator} STREQUAL "<")
    semver_normalize("${argument}")    
    semver_format("${argument}")
    ans(argument)
    semver_compare( "${version}" "${argument}")
    ans(cmp)
    if("${cmp}" GREATER 0)
      creturn(true)
    endif()
    creturn(false)
  endif()

  if(${operator} STREQUAL "!")
    semver_normalize("${argument}")    
    semver_format("${argument}")
    ans(argument)
    semver_compare( "${version}" "${argument}")
    ans(cmp)
    if("${cmp}" EQUAL "0")
      creturn(false)
    endif()
    creturn(true)

  endif()

  #check if version about equal to constraint
  if(${operator} STREQUAL "~")
    string(REGEX REPLACE "(.*)([0-9]+)" "\\2" upper "${argument}")
    math(EXPR upper "${upper} + 1" )
    string(REGEX REPLACE "(.*)([0-9]+)" "\\1${upper}" upper "${argument}")
    string(REGEX REPLACE "(.*)([0-9]+)" "\\1\\2" lower "${argument}")
    
    semver_constraint_evaluate_element( ">${lower}" "${version}")
    ans(lower_ok_gt)
    semver_constraint_evaluate_element( "=${lower}" "${version}")
    ans(lower_ok_eq)
    semver_constraint_evaluate_element( "<${upper}" "${version}")
    ans(upper_ok)

    if((lower_ok_gt OR lower_ok_eq) AND upper_ok)
      creturn(true)
    endif()
    creturn(false)
  endif()
  creturn(false)
endfunction()

# File: source/semver/semver_format.cmake

 function(semver_format version)
  semver_normalize("${version}")
  ans(version)

  #format("{version.major}.{version.minor}.{version.patch}")
  #ans(res)
  map_tryget(${version} major)
  ans(major)
  map_tryget(${version} minor)
  ans(minor)
  map_tryget(${version} patch)
  ans(patch)
  set(res "${major}.${minor}.${patch}")

  map_tryget("${version}" prerelease)
  ans(prerelease)
  if(NOT "${prerelease}_" STREQUAL "_")
    set(res "${res}-${prerelease}")
  endif()

  map_tryget("${version}" metadata)
  ans(metadata)
  if(NOT "${metadata}_" STREQUAL "_")
    set(res "${res}+${metadata}")
  endif()

  return_ref(res)

 endfunction()

# File: source/semver/semver_gt.cmake

# returns true if semver a is more up to date than semver b
  function(semver_gt  a b)
    semver_compare( "${a}" "${b}") 
    ans(res)
    ans(res)
    if(${res} LESS 0)
      creturn(true)
    endif()
    creturn(false)
  endfunction()

# File: source/semver/semver_higher.cmake

# returns the semver which is higher of semver a  and b
   function(semver_higher a b)
    semver_gt("${a}" "${b}")
    ans(res)
    if(res)
      creturn(${a})
    else()
      creturn(${b})
    endif()
   endfunction()

# File: source/semver/semver_isvalid.cmake

#returns the version object iff the version  is valid
# else returns false
# validity:
# it has a major, minor and patch version field with valid numeric values [0-9]+
# accepts both a version string or a object
# 
function(semver_isvalid version)
  # get version object
  semver("${version}")
  ans(version)

  if(NOT version)
    creturn(false)
  endif()

#  nav(version.major)
  map_tryget(${version} major)
  ans(current)
  string_isnumeric( "${current}")
  ans(numeric)
  #message("curent ${current} : numeric ${numeric}")
  if(NOT numeric)
    creturn(false)
  endif()

  #nav(version.minor)
  map_tryget(${version} minor)
  ans(current)
  string_isnumeric("${current}")
  ans(numeric)
 # message("curent ${current} : numeric ${numeric}")
  if(NOT numeric)
    creturn(false)
  endif()

  #nav(version.patch)
  map_tryget(${version} patch)
  ans(current)
  string_isnumeric( "${current}")
  ans(numeric)
#  message("curent ${current} : numeric ${numeric}")
  if(NOT numeric)
    creturn(false)
  endif()

  creturn(true)
endfunction()

# File: source/semver/semver_normalize.cmake

# returns a normalized version for a string or a object
# sets all missing version numbers to 0
# even an empty string is transformed to a version: it will be version 0.0.0 
function(semver_normalize version)
  semver("${version}")
  ans(version)

  if(NOT version)
    semver("0.0.0")
    ans(version)
  endif()

  nav(version.major)
  ans(current)
  if(NOT current)
    nav(version.major 0)
  endif() 


  nav(version.minor)
  ans(current)
  if(NOT current)
    nav(version.minor 0)
  endif() 


  nav(version.patch)
  ans(current)
  if(NOT current)
    nav(version.patch 0)
  endif() 

  creturn(${version})
endfunction()

# File: source/semver/semver_parse.cmake


function(semver_parse version_string)
  semver_parse_lazy("${version_string}")
  ans(version)
  if(NOT version)
    creturn()
  endif()


  semver_isvalid("${version}")
  ans(isvalid)
  if(isvalid)
    creturn(${version})
  endif()
  creturn()

  creturn()
  is_map("${version_string}" )
  ans(ismap)
  if(ismap)
    semver_format(version_string ${version_string})
  endif()

 set(semver_identifier_regex "[0-9A-Za-z-]+")
 set(semver_major_regex "[0-9]+")
 set(semver_minor_regex "[0-9]+")
 set(semver_patch_regex "[0-9]+")
 set(semver_identifiers_regex "${semver_identifier_regex}(\\.${semver_identifier_regex})*") 
 set(semver_prerelease_regex "${semver_identifiers_regex}")
 set(semver_metadata_regex "${semver_identifiers_regex}")
 set(semver_version_regex "(${semver_major_regex})\\.(${semver_minor_regex})\\.(${semver_patch_regex})")
 set(semver_regex "(${semver_version_regex})(-${semver_prerelease_regex})?(\\+${semver_metadata_regex})?")

  cmake_parse_arguments("" "LAZY" "MAJOR;MINOR;PATCH;VERSION;VERSION_NUMBERS;PRERELEASE;METADATA;RESULT;IS_VALID" "" ${ARGN})

  map_new()
  ans(version)

  # set result to version (this will contain partial or all of the version information)
  if(_RESULT)
    set(${_RESULT} ${version} PARENT_SCOPE)
  endif()

  string(REGEX MATCH "^${semver_regex}$" match "${version_string}")
  # check if valid
  if(NOT match)
    set(${_IS_VALID} false PARENT_SCOPE)
    creturn()
  endif()
  set(${_IS_VALID} true PARENT_SCOPE)

  # get version metadata and comparable part
  string_split( "${version_string}" "\\+")
  ans(parts)
  list_pop_front(parts)
  ans(version_version)

  # get version number part and prerelease part
  string_split( "${version_version}" "-")
  ans(parts)
  list_pop_front(parts)
  ans(version_prerelease)
  
  # get version numbers
  string(REGEX REPLACE "^${semver_version_regex}$" "\\1" version_major "${version_number}")
  string(REGEX REPLACE "^${semver_version_regex}$" "\\2" version_minor "${version_number}")
  string(REGEX REPLACE "^${semver_version_regex}$" "\\3" version_patch "${version_number}")

  string(REGEX REPLACE "\\." "\;" version_metadata "${version_metadata}")
  string(REGEX REPLACE "\\." "\;" version_prerelease "${version_prerelease}")

  if(_MAJOR)
    set(${_MAJOR} ${version_major} PARENT_SCOPE)
  endif()
  if(_MINOR)
    set(${_MINOR} ${version_minor} PARENT_SCOPE)
  endif()
  if(_PATCH)
    set(${_PATCH} ${version_patch} PARENT_SCOPE)
  endif()

  if(_VERSION)
    set(${_VERSION} ${version_version} PARENT_SCOPE)
  endif()

  if(_VERSION_NUMBERS)
    set(${_VERSION_NUMBERS} ${version_number} PARENT_SCOPE)
  endif()

  if(_PRERELEASE)
    set(${_PRERELEASE} ${version_prerelease} PARENT_SCOPE)
  endif()

  if(_METADATA)
    set(${_METADATA} ${version_metadata} PARENT_SCOPE)
  endif()

  if(_RESULT)
    map()
      kv(major "${version_major}")
      kv(minor "${version_minor}")
      kv(patch "${version_patch}")
      kv(prerelease "${version_prerelease}")
      kv(metadata "${version_metadata}")
    end()
    ans(_RESULT)
  endif()

endfunction()

# File: source/semver/semver_parse_lazy.cmake



function(semver_parse_lazy version_string)
  if(NOT version_string)
    creturn()
  endif()
  string_take_regex(version_string "v")


  map_new()
  ans(version)
  map_set(${version} string "${version_string}")


  set(version_number_regex "[0-9]+")
  set(identifier_regex "[0-9a-zA-Z]+")
  set(version_numbers_regex "(${version_number_regex}(\\.${version_number_regex}(\\.${version_number_regex})?)?)")

  # checks if version is of ()-()+() structure and only contains valid characters
  set(version_elements_regex "([0-9\\.]*(-[a-zA-Z0-9\\.-]*)?(\\+[a-zA-Z0-9\\.-]*)?)")
  set(valid)
  string(REGEX MATCH "^${version_elements_regex}$" valid "${version_string}")
  if(NOT valid)
    creturn()
  endif()
  # split into version string and prelrelease metadata
  string_split_at_first(version_numbers prerelease_and_metadata "${version_string}" "-")
  string_split_at_first(prerelease metadata "${prerelease_and_metadata}" "+")
  # parse version numbers
  if(version_numbers)
    string(REGEX MATCH "^${version_numbers_regex}$" valid "${version_numbers}")
    if(NOT valid)
      creturn()
    endif()
    string(REPLACE "." ";" version_numbers "${version_numbers}")
    string(REPLACE "." ";" metadatas "${metadata}")
    string(REPLACE "." ";" tags "${prerelease}")
    list_extract(version_numbers major minor patch)
    map_set(${version} numbers "${version_numbers}")
    map_set(${version} major "${major}")
    map_set(${version} minor "${minor}")
    map_set(${version} patch "${patch}")
    #nav("version.numbers" "${version_numbers}")
    #nav("version.major" "${major}")
    #nav("version.minor" "${minor}")
    #nav("version.patch" "${patch}")
  endif()

  #nav("version.prerelease" "${prerelease}")
  #nav("version.metadata" "${metadata}")
  #nav("version.metadatas" "${metadatas}")
  #nav("version.tags" "${tags}")
  map_set(${version} prerelease "${prerelease}")
  map_set(${version} metadata "${metadata}")
  map_set(${version} metadatas "${metadatas}")
  map_set(${version} tags "${tags}")

  creturn(${version})
endfunction()


# File: source/semver/semvers_extract.cmake

## extracts semvers from the input
function(semvers_extract)
  set(semver_regex "([0-9\\.]+(-[a-zA-Z0-9\\.-]*)?(\\+[a-zA-Z0-9\\.-]*)?)")
  string(REGEX MATCHALL "${semver_regex}" version_strings "${ARGN}")  
  set(result)
  foreach(version_string ${version_strings})
    semver_parse_lazy("${version_string}")
    ans(semver)
    list(APPEND result "${semver}")
  endforeach()
  return_ref(result)
endfunction()

# File: source/sequence/sequence_add.cmake



    function(sequence_add map)
      sequence_count("${map}")
      ans(count)
      math(EXPR new_count "${count} + 1")
      map_set_special("${map}" count ${new_count})
      map_set("${map}" "${count}" ${ARGN})
      return_ref(count)
    endfunction()


# File: source/sequence/sequence_append.cmake



    function(sequence_append map idx)
      sequence_count("${map}")
      ans(count)
      if(NOT "${idx}" LESS "${count}" OR ${idx} LESS 0)
        message(FATAL_ERROR "sequence_set: index out of range: ${idx}")
      endif()

      map_append( "${map}" "${idx}" ${ARGN} )
      
    endfunction()

# File: source/sequence/sequence_append_string.cmake



    function(sequence_append_string map idx)
      sequence_count("${map}")
      ans(count)
      if(NOT "${idx}" LESS "${count}" OR ${idx} LESS 0)
        message(FATAL_ERROR "sequence_set: index out of range: ${idx}")
      endif()

      map_append_string( "${map}" "${idx}" ${ARGN} )
      
    endfunction()

# File: source/sequence/sequence_count.cmake



    macro(sequence_count map)
      map_get_special("${map}" count)
    endmacro()


# File: source/sequence/sequence_get.cmake



    macro(sequence_get map idx)
      map_tryget("${map}" "${idx}")
    endmacro()


# File: source/sequence/sequence_index_isvalid.cmake

    macro(sequence_index_isvalid map idx)
      map_has("${map}" "${idx}")
    endmacro()


# File: source/sequence/sequence_isvalid.cmake


    function(sequence_isvalid map)
      sequence_count("${map}")
      ans(is_lookup)

      if("${is_lookup}_" STREQUAL "_" )
        creturn(false)
      endif()
      creturn(true)
    endfunction()

# File: source/sequence/sequence_new.cmake



    function(sequence_new)
      is_address("${ARGN}")
      ans(isref)
      if(NOT isref)
        map_new()
        ans(map)
      else()
        set(map ${ARGN})
      endif()

      map_set_special(${map} count 0)
      return_ref(map)
    endfunction()

# File: source/sequence/sequence_set.cmake


    function(sequence_set map idx)
      sequence_count(${map})
      ans(count)
      sequence_isvalid("${map}" "${idx}")
      ans(isvalid)
      if(NOT isvalid)
        creturn(false)
      endif()
      map_set("${map}" "${idx}" ${ARGN})
      creturn(true)
    endfunction()

# File: source/sequence/sequence_to_list.cmake

function(sequence_to_list map sublist_separator list_separator)

  map_keys(${map})
  ans(keys)
  set(result)
  set(first true)
  foreach(key ${keys})
    map_tryget(${map} "${key}")
    ans(current)
    string(REPLACE ";" "${sublist_separator}" current "${current}")
    if(first)
      set(result "${current}")
      set(first false)
    else()

      set(result "${result}${list_separator}${current}")
    endif()
  endforeach()
  return_ref(result)
endfunction()

# File: source/session/session.cmake

function(session)

  
  ## maybe later some kind of session which restores values between cmakepp runs

endfunction()

# File: source/shell/alias_create.cmake

# creates a systemwide alias callend ${name} which executes the specified command_string
#  you have to restart you shell/re-login under windows for changes to take effect 
function(alias_create name command_string)

    if (CMAKE_HOST_WIN32)
        cmakepp_config(bin_dir)
        ans(bin_dir)
        set(path "${bin_dir}/${name}.bat")
        fwrite("${path}" "@echo off\r\n${command_string} %*")
        reg_append_if_not_exists(HKCU/Environment Path "${bin_dir}")
        ans(res)
        if (res)
            #message(INFO "alias ${name} was created - it will be available as soon as you restart your shell")
        else ()
            #message(INFO "alias ${name} as created - it is directly available for use")
        endif ()
        creturn(true)
    endif ()

    shell_get()
    ans(shell)

    if ("${shell}" STREQUAL "bash")
        path("~/.bashrc")
        ans(bc)
        fappend("${bc}" "\nalias ${name}='${command_string}'")
        #message(INFO "alias ${name} was created - it will be available as soon as you restart your shell")

    else ()
        message(FATAL_ERROR "creating alias is not supported by cmakepp on your system your current shell (${shell})")
    endif ()
endfunction()



# File: source/shell/alias_exists.cmake


function(alias_exists name)
  alias_list()
  ans(aliases)
  list_contains(aliases "${name}")
  ans(res)
  return_ref(res)
endfunction()

# File: source/shell/alias_list.cmake


function(alias_list)
  message(FATAL_ERROR "not implemented")

  path("${CMAKE_CURRENT_LIST_DIR}/../bin")
  ans(path)
  


  if(CMAKE_HOST_WIN32)
    #file_extended_glob("${path}" "*.bat" "!cps.*" "!cutil.*")
    ans(cmds)
  set(theRegex "([^\\/])+\\.bat")
  
  list_select(cmds "[](it)regex_search({{it}} {{theRegex}})")
  ans(cmds)
  
  string(REPLACE ".bat" "" cmds "${cmds}")

  return_ref(cmds)
else()
  message(FATAL_ERROR "only implemented for windows")
endif()

endfunction()




# File: source/shell/alias_remove.cmake


function(alias_remove name)
  path("${CMAKE_CURRENT_LIST_DIR}/../bin")
  ans(path)
  if(CMAKE_HOST_WIN32)
    file(REMOVE "${path}/${name}.bat")
  else()
    message(FATAL_ERROR "only implemnted for windows")
  endif()

endfunction()


# File: source/shell/bash_functions.cmake





#C:\ProgramData\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\ATI Technologies\ATI.ACE\Core-Static;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;C:\Program Files (x86)\Git\cmd;C:\Program Files\Mercurial\;C:\Program Files\nodejs\;C:\Program Files (x86)\Microsoft SDKs\TypeScript\1.0\;C:\Program Files\Microsoft SQL Server\120\Tools\Binn\
#C:\ProgramData\chocolatey\bin;C:\Program Files\Mercurial;C:\Users\Tobi\AppData\Roaming\npm


# creates the bash string using the map env which contains key value pairs
function(bash_profile_compile env)
  set(res)
  map_keys(${env})
  ans(keys)
  foreach(key ${keys})
    map_tryget(${env} ${key})
    ans(val)
    set(res "${res}export ${key}=\"${val}\"\n")
  endforeach()
  return_ref(res)
endfunction()

# creates and writes the bash profile env to path (see bash_profile_compile)
function(bash_profile_write path env)
  bash_profile_compile(${env})
  ans(str)
  bash_script_create("${path}" "${str}")
  return_ans()
endfunction()

function(bash_autostart_read)
  set(session_profile_path "$ENV{HOME}/.profile")
  if(NOT EXISTS "${session_profile_path}")
    creturn()
  endif()
  fread("${session_profile_path}")
  ans(res)
  return_ref(res)
endfunction()

# registers
function(bash_autostart_register)
  set(session_profile_path "$ENV{HOME}/.profile")
  if(NOT EXISTS "${session_profile_path}")
    touch("${session_profile_path}")
  endif()
  fread("${session_profile_path}")
  ans(profile)

  set(profile_path "$ENV{HOME}/cmakepp.profile.sh")

  if(NOT EXISTS "${profile_path}")
    shell_script_create("${profile_path}" "")
  endif()

  if("${profile}" MATCHES "${profile_path}\n")
    creturn()
  endif()

  unix_path("${profile_path}")
  ans(profile_path)
  set(profile "${profile}\n${profile_path}\n")
  fwrite("${session_profile_path}" "${profile}")

  creturn()
endfunction()

# removes the cmake profile from $ENV{HOME}/.profile
function(bash_autostart_unregister)
  set(session_profile_path "$ENV{HOME}/.profile")
  if(NOT EXISTS "${session_profile_path}")
    creturn()
  endif()
  fread("${session_profile_path}")
  ans(content)
  string_regex_escape("${session_profile_path}")
  ans(escaped)
  string(REGEX REPLACE "${escaped}" "" content "${content}")
  fwrite("${session_profile_path}" "${content}")
  creturn()
endfunction()


# returs true if the cmakepp session profile (environment variables)are registered
function(bash_autostart_isregistered)
  set(session_profile_path "$ENV{HOME}/.profile")
  if(NOT EXISTS "${session_profile_path}")
    creturn(false)
  endif()
  fread("${session_profile_path}")
  ans(content)
  string_regex_escape("${session_profile_path}")
  ans(escaped)
  if("${content}" MATCHES "${escaped}")
    creturn(true)
  endif()
  creturn(false)
endfunction()


# File: source/shell/echo.cmake

# writes the args to the console
function(echo)
  execute_process(COMMAND ${CMAKE_COMMAND} -E echo "${ARGN}")
endfunction()

# File: source/shell/echo_append.cmake

# writes the args to console. does not append newline
function(echo_append)
  execute_process(COMMAND ${CMAKE_COMMAND} -E echo_append "${ARGN}")
endfunction()

# File: source/shell/home_path.cmake



# File: source/shell/read_line.cmake

# reads a line from the console.  
#  uses .bat file on windows else uses shell script file .sh
function(read_line)
  fwrite_temp("" ".txt")
  ans(value_file)

  if(CMAKE_HOST_WIN32)
    # thanks to Fraser999 for fixing whis to dissallow variable expansion and whitespace stripping
    # etc. See merge comments
    fwrite_temp("@echo off\nsetlocal EnableDelayedExpansion\nset val=\nset /p val=\necho !val!> \"${value_file}\"" ".bat")
    ans(shell_script)
  else()
    fwrite_temp( "#!/bin/bash\nread text\necho -n $text>${value_file}" ".sh")
    ans(shell_script)
    # make script executable
    execute_process(COMMAND "chmod" "+x" "${shell_script}")
  endif()

  # execute shell script which write the keyboard input to the ${value_file}
  execute_process(COMMAND "${shell_script}")

  # read value file
  file(READ "${value_file}" line)

  # strip trailing '\n' which might get added by the shell script. as there is no way to input \n at the end 
  # manually this does not change for any system
  if("${line}" MATCHES "(\n|\r\n)$")
    string(REGEX REPLACE "(\n|\r\n)$" "" line "${line}")
  endif()

  ## quick fix
  if("${line}" STREQUAL "ECHO is off.")
    set(line)
  endif()
  # remove temp files
  file(REMOVE "${shell_script}")
  file(REMOVE "${value_file}")
  return_ref(line)
endfunction()


# File: source/shell/shell.cmake

# runs a shell script on the current platform
# not that
function(shell cmd)

    shell_get()
    ans(shell)
    if ("${shell}" STREQUAL "cmd")
        fwrite_temp("@echo off\n${cmd}" ".bat")
        ans(shell_script)
    elseif ("${shell}" STREQUAL "bash")
        fwrite_temp("#!/bin/bash\n${cmd}" ".sh")
        ans(shell_script)
        # make script executable
        execute_process(COMMAND "chmod" "+x" "${shell_script}")
    else ()
        message(FATAL_ERROR "Shell not suported: ${shell}")
    endif ()

    # execute shell script which write the keyboard input to the ${value_file}
    set(args ${ARGN})

    list_extract_flag(args --process-handle)
    ans(return_process_handle)

    execute("${shell_script}" ${args} --process-handle)
    ans(res)

    # remove temp file
    file(REMOVE "${shell_script}")
    if (return_process_handle)
        return_ref(res)
    endif ()

    map_tryget(${res} exit_code)
    ans(exit_code)

    if (NOT "_${exit_code}" STREQUAL "_0")
        message(ERROR "Shell failed with exit code ${exit_code}")
        creturn()
    endif ()

    map_tryget(${res} stdout)
    ans(stdout)
    return_ref(stdout)
endfunction()

# File: source/shell/shell_env_append.cmake



function(shell_env_append key value)
  if(CMAKE_HOST_WIN32)
    shell("SETX ${key} %${key}%;${value}")

  else()
    message(WARNING "shell_set_env not implemented for anything else than windows")

  endif()
endfunction()

# File: source/shell/shell_env_get.cmake


# returns the value of the shell's environment variable ${key}
function(shell_env_get key)
  shell_get()
  ans(shell)

  if(CMAKE_HOST_WIN32)
    
  endif()

  if("${shell}" STREQUAL "cmd")
    #setlocal EnableDelayedExpansion\nset val=\nset /p val=\necho %val%> \"${value_file}\"
    shell_redirect("echo %${key}%")
    ans(res)
  elseif("${shell}" STREQUAL "bash")
    shell_redirect("echo $${key}")
    ans(res)
  else()
    message(FATAL_ERROR "${shell} not supported")
  endif()


    # strip trailing '\n' which might get added by the shell script. as there is no way to input \n at the end 
    # manually this does not change for any system
    if("${res}" MATCHES "(\n|\r\n)+$")
      string(REGEX REPLACE "(\n|\r\n)+$" "" res "${res}")
    endif()
    
  return_ref(res)
endfunction()

# File: source/shell/shell_env_prepend.cmake



function(shell_env_prepend key value)

endfunction()

# File: source/shell/shell_env_set.cmake



# sets a system wide environment variable 
# the variable will not be available until a new console is started
function(shell_env_set key value)
  if(CMAKE_HOST_WIN32)
    reg_write_value("HKCU/Environment" "${key}" "${value}")
    #message("environment variable '${key}' was written, it will be available as soon as you restart your shell")
    creturn()
  endif()
  

  shell_get()
  ans(shell)
    
  if("${shell}" STREQUAL "bash")
    path("~/.bashrc")
    ans(path)
    fappend("${path}" "\nexport ${key}=${value}")
    #message("environment variable '${key}' was exported in .bashrc it will be available as soon as your restart your shell")
  else()
    message(WARNING "shell_set_env not implemented")
  endif()
endfunction()

# File: source/shell/shell_env_unset.cmake




# removes a system wide environment variable
function(shell_env_unset key)
  # set to nothing
  shell_env_set("${key}" "")
  shell_get()
  ans(shell)
  if("${shell}_" STREQUAL "cmd_")
    shell("REG delete HKCU\\Environment /V ${key}")
  else()
    message(WARNING "shell_env_unset not implemented for anything else than windows")
  endif()
endfunction()

# File: source/shell/shell_get.cmake

# returns which shell is used (bash,cmd) returns false if shell is unknown
function(shell_get)
  if(CMAKE_HOST_WIN32)
    creturn(cmd)
  else()
    creturn(bash)
  endif()
endfunction()


# File: source/shell/shell_get_script_extension.cmake



# returns the extension for a shell script file on the current console
# e.g. on windows this returns bat on unix/bash this returns bash
# uses shell_get() to determine which shell is used
function(shell_get_script_extension)
  shell_get()
  ans(shell)
  if("${shell}" STREQUAL "cmd")
    creturn(bat)
  elseif("${shell}" STREQUAL "bash")
    creturn(sh)
  else()
    message(FATAL_ERROR "no shell could be recognized")
  endif()

endfunction()

# File: source/shell/shell_path_add.cmake


# 
function(shell_path_add path)
  set(args ${ARGN})
  list_extract_flag(args "--prepend")
  ans(prepend)

  shell_path_get()
  ans(paths)
  path("${path}")
  ans(path)
  list_contains(paths "${path}")
  ans(res)
  if(res)
    creturn(false)
  endif()


  if(prepend)
    set(paths "${path};${paths}")
  else()
    set(paths "${paths};${path}")
  endif()

  shell_path_set(${paths})

  creturn(true)
endfunction()

# File: source/shell/shell_path_get.cmake

function(shell_path_get)
    shell_env_get(Path)
    ans(paths)
    set(paths2)
    foreach(path ${paths})
      file(TO_CMAKE_PATH path "${path}")
      list(APPEND paths2 "${path}")
    endforeach()
    return_ans(paths2)

endfunction()


# File: source/shell/shell_path_remove.cmake



function(shell_path_remove path)
  shell_path_get()
  ans(paths)

  path("${path}")
  ans(path)

  list_contains(paths "${path}")
  ans(res)
  if(res)
    list_remove(paths "${path}")
    shell_path_set(${paths})
    creturn(true)
  else()
    creturn(false)
  endif()

endfunction()

# File: source/shell/shell_path_set.cmake



function(shell_path_set)
  set(args ${ARGN})
  if(CMAKE_HOST_WIN32)
    string(REPLACE "\\\\" "\\" args "${args}")
  endif()
  message("setting path ${args}")
  shell_env_set(Path "${args}")
  creturn()
endfunction()

# File: source/shell/shell_redirect.cmake


# redirects the output of the specified shell to the result value of this function
function(shell_redirect code)
  fwrite_temp("" ".txt")
  ans(tmp_file)
  shell("${code}> \"${tmp_file}\"")
  fread("${tmp_file}")
  ans(res)
  file(REMOVE "${tmp_file}")
  return_ref(res)
endfunction()

# File: source/shell/shell_script_create.cmake


# creates a shell script file containing the specified code and the correct extesion to execute
# with execute_process
function(shell_script_create path code)
  if(NOT ARGN)
    shell_get()
    ans(shell)
  else()
    set(shell "${ARGN}")
  endif()
  if("${shell}_" STREQUAL "cmd_")
    if(NOT "${path}" MATCHES "\\.bat$")
      set(path "${path}.bat")
    endif()
    set(code "@echo off\n${code}")
  elseif("${shell}_" STREQUAL "bash_")
    if(NOT "${path}" MATCHES "\\.sh$")
      set(path "${path}.sh")
    endif()
    set(code "#!/bin/bash\n${code}")
    touch("${path}")
    execute_process(COMMAND chmod +x "${path}")
  else()
    message(WARNING "shell not supported: '${shell}' ")
    creturn()
  endif()
    fwrite("${path}" "${code}")
    return_ref(path)
endfunction()

# File: source/shell/shell_tmp_script.cmake



# creates a temporary script file which contains the specified code
# and has the correct exension to be run with execute_process
# the path to the file will be returned
function(shell_tmp_script code)
  shell_get_script_extension()
  ans(ext)
  fwrite_temp("${code}" ".${ext}")
  ans(tmp)
  shell_script_create("${tmp}" "${code}")
  ans(res)
  return_ref(res)
endfunction()

# File: source/shell/unix_path.cmake


# fully qualifies the path into a unix path (even windows paths)
# transforms C:/... to /C/...
function(unix_path path)
  path("${path}")
  ans(path)
  string(REGEX REPLACE "^_([a-zA-Z]):\\/" "/\\1/" path "_${path}")
  return_ref(path)
endfunction()

# File: source/stack/queue_isempty.cmake

function(queue_isempty stack)
  map_tryget("${stack}" front)
  ans(front)
  map_tryget("${stack}" back)
  ans(back)
  math(EXPR res "${back} - ${front}")
  if(res)
    creturn(false)
  endif()  
  creturn(true)
endfunction()

# File: source/stack/queue_new.cmake


  function(queue_new)
    address_new(queue)
    ans(queue)
    map_set_hidden(${queue} front 0)
    map_set_hidden(${queue} back 0)
    creturn(${queue})
  endfunction()

# File: source/stack/queue_peek.cmake


  function(queue_peek queue)
    map_tryget("${queue}" front)
    ans(front)
    map_tryget("${queue}" back)
    ans(back)
    if(${front} LESS ${back} )
      map_tryget("${queue}" "${front}")
      return_ans()
    endif()
    creturn()
  endfunction()

# File: source/stack/queue_pop.cmake


function(queue_pop queue)
  map_tryget("${queue}" front)
  ans(front)
  map_tryget("${queue}" back)
  ans(back)

  if(${front} LESS ${back})
    map_tryget("${queue}" "${front}")
    ans(res)
    math(EXPR front "${front} + 1")
    map_set_hidden("${queue}" "front" "${front}")
    return_ref(res)
  endif()
  creturn()
 endfunction()


# File: source/stack/queue_push.cmake


  function(queue_push queue)
    map_tryget("${queue}" back)
    ans(back)
    map_set_hidden("${queue}" "${back}" "${ARGN}")
    math(EXPR back "${back} + 1")
    map_set_hidden("${queue}" back "${back}")
    
  endfunction()

# File: source/stack/rlist_new.cmake

function(rlist_new)
    address_new(rlist)
    ans(rlist)
    map_set_hidden(${queue} front 0)
    map_set_hidden(${queue} back 0)
    creturn(${queue})
endfunction()



# File: source/stack/stack_at.cmake


# returns the specified element of the stack
function(stack_at stack idx)
  map_tryget("${stack}" back)
  ans(current_index)
  math(EXPR idx "${idx} + 1")
  if("${current_index}" LESS "${idx}")
    creturn()
  endif()
  map_tryget("${stack}" "${idx}")
  return_ans()
endfunction()

# File: source/stack/stack_enumerate.cmake



# returns all elements of the stack possibly fucking up
# element count because single elements may be lists-
# -> lists are flattened
function(stack_enumerate stack)
  map_tryget("${stack}" back)
  ans(current_index)
  if(NOT current_index)
    creturn()
  endif()
  
 # math(EXPR current_index "${current_index} - 1")
  set(res)
  foreach(i RANGE 1 ${current_index})
    map_tryget("${stack}" "${i}")
    ans(current)
    list(APPEND res "${current}")
  endforeach()
  return_ref(res)
endfunction()

# File: source/stack/stack_isempty.cmake



  function(stack_isempty stack)
    map_tryget("${stack}" back)
    ans(count)
    if(count)
      creturn(false)
    endif()
    creturn(true)
  endfunction()

# File: source/stack/stack_new.cmake


  function(stack_new)
    address_new(stack)
    ans(stack)   
    map_set_hidden("${stack}" front 0)
    map_set_hidden("${stack}" back 0)
    creturn(${stack})
  endfunction()

# File: source/stack/stack_peek.cmake


  function(stack_peek stack)
    map_tryget("${stack}" back)
    ans(back)
    map_tryget("${stack}" "${back}")
    return_ans()
  endfunction()

# File: source/stack/stack_pop.cmake


function(stack_pop stack)
  map_tryget("${stack}" back)
  ans(current_index)
  if(NOT current_index)
    creturn()
  endif()
  map_tryget("${stack}" "${current_index}")
  ans(res)
  math(EXPR current_index "${current_index} - 1")
  map_set_hidden("${stack}" back "${current_index}")
  return_ref(res)
endfunction()


# File: source/stack/stack_push.cmake

function(stack_push stack)
  map_tryget("${stack}" back)
  ans(current_index)
  
  # increase stack pointer
  if(NOT current_index)
    set(current_index 0)
  endif()
  math(EXPR current_index "${current_index} + 1")
  map_set_hidden("${stack}" back "${current_index}")

  map_set_hidden("${stack}" "${current_index}" "${ARGN}")
endfunction()


# File: source/string/ascii_char.cmake


  function(ascii_char code)
    ascii_generate_table()
    map_tryget(ascii_table "${code}")
    return_ans()
  endfunction()

 ## faster version
  function(ascii_char code)
    string(ASCII "${code}" res)
    return_ref(res)
  endfunction()

# File: source/string/ascii_code.cmake


  function(ascii_code char)
    generate_ascii_table()
    map_tryget(ascii_table "'${char}'")
    return_ans()
  endfunction()

# File: source/string/ascii_generate_table.cmake

## generates the ascii table and stores it in the global ascii_table variable  
  function(ascii_generate_table)
    foreach(i RANGE 1 255)
      string(ASCII ${i} c)
      map_set(ascii_table "'${char}'" "${i}")
      map_set(ascii_table "${i}" "${char}")
    endforeach()
    function(ascii_generate_table)
    endfunction()
  endfunction()



# File: source/string/cmake_string_to_json.cmake



function(cmake_string_to_json str)
  string_decode_semicolon("${str}")
  ans(str)
  string(REPLACE "\\" "\\\\" str "${str}")
  string(REPLACE "\"" "\\\"" str "${str}")
  string(REPLACE "\n" "\\n" str "${str}")
  string(REPLACE "\t" "\\t" str "${str}")
  string(REPLACE "\t" "\\t" str "${str}")
  string(REPLACE "\r" "\\r" str "${str}")
  string(ASCII 8 bs)
  string(REPLACE "${bs}" "\\b" str "${str}")
  string(ASCII 12 ff)
  string(REPLACE "${ff}" "\\f" str "${str}")
  string(REPLACE ";" "\\\\;" str "${str}")
  set(str "\"${str}\"")
  return_ref(str)
endfunction()


# File: source/string/delimiters.cmake

## **`delimiters()->[delimiter_begin, delimiter_end]`**
##
## parses delimiters and retruns a list of length 2 containing the specified delimiters. 
## The usefullness of this function becomes apparent when you use [string_take_delimited](#string_take_delimited)
## 
##
function(delimiters)
  set(delimiters ${ARGN})


  if("${delimiters}_" STREQUAL "_")
    set(delimiters \")
  endif()



  list_pop_front(delimiters)
  ans(delimiter_begin)


  if("${delimiter_begin}" MATCHES ..)
    string(REGEX REPLACE "(.)(.)" "\\2" delimiter_end "${delimiter_begin}")
    string(REGEX REPLACE "(.)(.)" "\\1" delimiter_begin "${delimiter_begin}")
  else()
    list_pop_front(delimiters)
    ans(delimiter_end)
  endif()

  
  if("${delimiter_end}_" STREQUAL "_")
    set(delimiter_end "${delimiter_begin}")
  endif()

  creturn(${delimiter_begin} ${delimiter_end})
endfunction()

# File: source/string/encoding/cmake_string_escape.cmake

function(cmake_string_escape str)
  string(REPLACE "\\" "\\\\" str "${str}")
  string(REPLACE "\"" "\\\"" str "${str}")
  string(REPLACE "(" "\\(" str "${str}")
  string(REPLACE ")" "\\)" str "${str}")
  string(REPLACE "$" "\\$" str "${str}") 
  string(REPLACE "#" "\\#" str "${str}") 
  string(REPLACE "^" "\\^" str "${str}") 
  string(REPLACE "\t" "\\t" str "${str}")
  string(REPLACE ";" "\\;" str "${str}")
  string(REPLACE "\n" "\\n" str "${str}")
  string(REPLACE "\r" "\\r" str "${str}")
  
  #string(REPLACE "\0" "\\0" str "${str}") unnecessary because cmake does not support nullcahr in string
  string(REPLACE " " "\\ " str "${str}")
  return_ref(str)
endfunction()


function(cmake_string_escape2 str)
  if("${str}" MATCHES "[ \"\\(\\)#\\^\t\r\n\\\;]")
    ## encoded list encode cmake string...
    string(REPLACE "\\" "\\\\" str "${str}")
    string(REGEX REPLACE "([; \"\\(\\)#\\^])" "\\\\\\1" str "${str}")
    string(REPLACE "\t" "\\t" str "${str}")
    string(REPLACE "\n" "\\n" str "${str}")
    string(REPLACE "\r" "\\r" str "${str}")  
  endif()
  return_ref(str)
endfunction()


function(cmake_string_escape3 str)
  if("${str}" MATCHES "[ \"\\(\\)#\\^\t\r\n\\]")
    ## encoded list encode cmake string...
    string(REPLACE "\\" "\\\\" str "${str}")
    string(REGEX REPLACE "([ \"\\(\\)#\\^])" "\\\\\\1" str "${str}")
    string(REPLACE "\t" "\\t" str "${str}")
    string(REPLACE "\n" "\\n" str "${str}")
    string(REPLACE "\r" "\\r" str "${str}")  
  endif()
  return_ref(str)
endfunction()

# File: source/string/encoding/cmake_string_unescape.cmake


  function(cmake_string_unescape str)
    string(REPLACE "\\\"" "\"" str "${str}")
    string(REPLACE "\\\\" "\\" str "${str}")
    string(REPLACE "\\(" "(" str "${str}")
    string(REPLACE "\\)" ")" str "${str}")
    string(REPLACE "\\$" "$" str "${str}")
    string(REPLACE "\\#" "#" str "${str}")
    string(REPLACE "\\^" "^" str "${str}")
string(REPLACE "\\t" "\t" str "${str}")
    string(REPLACE "\\;" ";"  str "${str}")
    string(REPLACE "\\n" "\n" str "${str}")
    string(REPLACE "\\r" "\r" str "${str}")
    string(REPLACE "\\0" "" str "${str}") ## not supported  in cmake strings
    string(REPLACE "\\ " " " str "${str}")
    return_ref(str)
  endfunction()

# File: source/string/encoding/is_encoded_list.cmake

## `(<any>)-><bool>`
##
## returns true if the specified value is an encoded list
## meaning that it needs to be decoded before it will be correct
function(is_encoded_list)
  string_codes()
  eval("
    function(is_encoded_list)
      if(\"\${ARGN}\" MATCHES \"[${bracket_open_code}${bracket_close_code}${semicolon_code}]\")
        set(__ans true PARENT_SCOPE)
      else()
        set(__ans false PARENT_SCOPE)
      endif()

    endfunction()
  ")
  is_encoded_list(${ARGN})
  return_ans()
endfunction()




# File: source/string/encoding/string_decode_bracket.cmake

# decodes encoded brakcets in a string
function(string_decode_bracket str)
    string_codes()
    string(REPLACE "${bracket_open_code}" "["  str "${str}") 
    string(REPLACE "${bracket_close_code}" "]"  str "${str}")
    return_ref(str)
endfunction()



## faster
function(string_decode_bracket str)
  string_codes()
  eval("
  function(string_decode_bracket str)
    string(REPLACE \"${bracket_open_code}\" \"[\"  str \"\${str}\")
    string(REPLACE \"${bracket_close_code}\" \"]\"  str \"\${str}\")
    set(__ans \"\${str}\" PARENT_SCOPE)
  endfunction()
  ")
  string_decode_bracket("${str}")
  return_ans()
endfunction()

# File: source/string/encoding/string_decode_empty.cmake

# decodes an encoded empty string
function(string_decode_empty str) 
    string_codes()
  if("${str}" STREQUAL "${empty_code}")
    creturn("")
  endif()
  return_ref(str)
endfunction()



# File: source/string/encoding/string_decode_list.cmake

# decodes an encoded list
  function(string_decode_list str)
    string_decode_semicolon("${str}")
    ans(str)
    string_decode_bracket("${str}")
    ans(str)
    string_decode_empty("${str}")
    ans(str)
   # message("decoded3: ${str}")
    return_ref(str)
  endfunction()


## faster
function(string_decode_list str)
  string_codes()
  eval("
  function(string_decode_list str)
    string(REPLACE \"${bracket_open_code}\" \"[\"  str \"\${str}\")
    string(REPLACE \"${bracket_close_code}\" \"]\"  str \"\${str}\")
    string(REPLACE \"${semicolon_code}\" \";\"  str \"\${str}\")
    set(__ans \"\${str}\" PARENT_SCOPE)
  endfunction()
  ")
  string_decode_list("${str}")
  return_ans()
endfunction()

# File: source/string/encoding/string_decode_parentheses.cmake

#decodes parentheses in a string
function(string_decode_parentheses str)
    string_codes()
  string(REPLACE "${paren_open_code}" "\(" str "${str}")
  string(REPLACE "${paren_close_code}" "\)" str "${str}")
  return_ref(str)
endfunction()



# File: source/string/encoding/string_decode_semicolon.cmake

# decodes semicolons in a string
  function(string_decode_semicolon str)
    string(ASCII  31 semicolon_code)
    string(REPLACE "${semicolon_code}" ";" str "${str}")
    return_ref(str)
  endfunction()



## faster
  function(string_decode_semicolon str)
    string_codes()
    eval("
      function(string_decode_semicolon str)
        string(REPLACE  \"${semicolon_code}\" \";\" str \"\${str}\" )
        set(__ans \"\${str}\" PARENT_SCOPE)
      endfunction()
    ")
    string_decode_semicolon("${str}")
    return_ans()
  endfunction()


# File: source/string/encoding/string_encode_bracket.cmake

# encodes brackets
function(string_encode_bracket str)
  string_codes()
  string(REPLACE "[" "${bracket_open_code}" str "${str}") 
  string(REPLACE "]" "${bracket_close_code}" str "${str}")
  return_ref(str)
endfunction()


## faster
function(string_encode_bracket str)
  string_codes()
  eval("
    function(string_encode_bracket str)
    string(REPLACE \"[\" \"${bracket_open_code}\" str \"\${str}\")
    string(REPLACE \"]\" \"${bracket_close_code}\" str \"\${str}\")
    set(__ans \"\${str}\" PARENT_SCOPE)
  endfunction()
  ")
  string_encode_bracket("${str}")
  return_ans()
endfunction()




# File: source/string/encoding/string_encode_delimited.cmake

## escapes a string to be delimited
## by the the specified delimiters
function(string_encode_delimited str)
    delimiters(${ARGN})
    ans(ds)
    list_pop_front(ds)
    ans(delimiter_begin)
    list_pop_front(ds)
    ans(delimiter_end)

    string(REPLACE \\ \\\\ str "${str}" )
    string(REPLACE "${delimiter_end}" "\\${delimiter_end}" str "${str}" )
    set(str "${delimiter_begin}${str}${delimiter_end}")
    return_ref(str)
endfunction()


# File: source/string/encoding/string_encode_empty.cmake

# encodes an empty element
function(string_encode_empty str)
  message("huh")
  string_codes()

  if("_${str}" STREQUAL "_")
    creturn("${empty_code}")
  endif()
  return_ref(str)
endfunction()






# File: source/string/encoding/string_encode_list.cmake

# encodes a string list so that it can be correctly stored and retrieved
function(string_encode_list str)
  string_codes()
  string(REPLACE "[" "${bracket_open_code}" str "${str}")
  string(REPLACE "]" "${bracket_close_code}" str "${str}")
  string(REPLACE ";" "${semicolon_code}" str "${str}")
  set(__ans "${str}" PARENT_SCOPE)
endfunction()

## faster
function(string_encode_list str)
  string_codes()
  eval("
    function(string_encode_list str)
    string(REPLACE \"[\" \"${bracket_open_code}\" str \"\${str}\")
    string(REPLACE \"]\" \"${bracket_close_code}\" str \"\${str}\")
    string(REPLACE \";\" \"${semicolon_code}\" str \"\${str}\")
    set(__ans \"\${str}\" PARENT_SCOPE)
  endfunction()
  ")
  string_encode_list("${str}")
  return_ans()
endfunction()




# File: source/string/encoding/string_encode_parentheses.cmake


# encodes parentheses in a string
  function(string_encode_parentheses str)
    string_codes()
    string(REPLACE "\(" "${paren_open_code}" str "${str}")
    string(REPLACE "\)" "${paren_close_code}" str "${str}")
    return_ref(str)
  endfunction()




# File: source/string/encoding/string_encode_semicolon.cmake

# encodes semicolons with seldomly used utf8 chars.
# causes error for string(SUBSTRING) command
  function(string_encode_semicolon str)
    # make faster by checking if semicolon exists?
    string(ASCII  31 semicolon_code)
    # string(FIND "${semicolon_code}" has_semicolon)
    #if(has_semicolon GREATER -1) replace ...

    string(REPLACE ";" "${semicolon_code}" str "${str}" )
    return_ref(str)
  endfunction()


## faster
  function(string_encode_semicolon str)
    string_codes()
    eval("
      function(string_encode_semicolon str)
        string(REPLACE \";\" \"${semicolon_code}\" str \"\${str}\" )
        set(__ans \"\${str}\" PARENT_SCOPE)
      endfunction()
    ")
    string_encode_semicolon("${str}")
    return_ans()
  endfunction()



# File: source/string/escape_argument.cmake


  function(argument_escape arg)
    cmake_string_escape("${arg}")
    ans(arg)
    return_ref(arg)
    if("${arg}_" MATCHES "(^_$)|(;)|(\")")
      set(arg "\"${arg}\"") 
    endif()
    return_ref(arg)
  endfunction()

# File: source/string/format.cmake

## [**`format(<template string>)-><string>`**](<%="${template_path}"%>)
##
## this function utilizes [`assign(...)`](#assign) to evaluate expressions which are enclosed in handlebars: `{` `}`
## 
##
## *Examples*
## ```cmake
## # create a object
## obj("{a:1,b:[2,3,4,5,6],c:{d:3}}")
## ans(data)
## ## use format to print navigated expressiosn:
## format("{data.a} + {data.c.d} = {data.b[2]}") => "1 + 3 = 4"
## format("some numbers: {data.b[2:$]}") =>  "some numbers: 4;5;6"
## ...
## ```
## *Note:* You may not use ASCII-29 since it is used interally in this function. If you don't know what this means - don't worry
## 
##
function(format)
  string(ASCII 29 delimiter)
  set(template "${ARGN}")
  string(REGEX MATCHALL "{[^}]*}" matches "${template}")
  list_remove_duplicates(matches)
  foreach(match ${matches})
    string(REGEX REPLACE "^{(.*)}$" "\\1" match "${match}")
    assign(value = ${match})
    string(REPLACE "{${match}}" "${value}" template "${template}")
  endforeach()
  return_ref(template)
endfunction()


# File: source/string/regex_search.cmake


# matches the first occurens of regex and returns it
function(regex_search str regex)
  string(REGEX MATCH "${regex}" res "${str}")  
  return_ref(res)
endfunction()

# File: source/string/string_append_line_indented.cmake


  function(string_append_line_indented str_ref what)
    indent("${what}" ${ARGN})
    ans(indented)
    set("${str_ref}" "${${str_ref}}${indented}\n" PARENT_SCOPE)
  endfunction()


# File: source/string/string_char_at.cmake

## `(<input:<string>> <index:<int>>)-><string>`
##
## Returns the character at the specified position (index). 
## Indexing of strings starts at 0. Indices less than -1 are translated into "length - |index|"
##
## *Examples*
## set(input "example")
## string_char_at("${input}" 3) # => "m"
## string_char_at("${input}"-3) # => "l"
##
##
function(string_char_at input index)
  string(LENGTH "${input}" len)
  string_normalize_index("${input}" ${index})
  ans(index)
  
  if(${index} LESS 0 OR ${index} EQUAL ${len} OR ${index} GREATER ${len}) 
    creturn()
  endif()
  
  string(SUBSTRING "${input}" ${index} 1 res)
  
  return_ref(res)
endfunction()

# File: source/string/string_char_at_set.cmake

## `(<input:<string>> <index:<int>> <char:<string>>)-><string>`
##
## Sets the character at the specified position (index) to the input 'char'. 
## Indexing of strings starts at 0. Indices less than -1 are translated into "length - |index|"
## 
## **Examples**
##  set(input "example")
##  string_char_at_set("${input}" 0 "E")  # => "Example"
##  string_char_at_set("${input}" 2 "A")  # => "exAmple"
##  string_char_at_set("${input}" -2 "E") # => "examplE"
## 
##
function(string_char_at_set input index char)
  string(LENGTH "${input}" len)
  string_normalize_index("${input}" ${index})
  ans(index)

  if(${index} LESS 0 OR ${index} EQUAL ${len} OR ${index} GREATER ${len}) 
    creturn()
  endif()

  string(SUBSTRING "${input}" 0 ${index} pre_str)
  MATH(EXPR index "${index} + 1")
  string(SUBSTRING "${input}" ${index} -1 post_str)
  
  set(res "${pre_str}${char}${post_str}")

  return_ref(res)
endfunction()


# File: source/string/string_codes.cmake

# special chars |||||||||
macro(string_codes)
  string(ASCII 14 "${ARGN}free_token1")
  string(ASCII 15 "${ARGN}free_token2")
  string(ASCII 1 "${ARGN}free_token3")
  string(ASCII 2 "${ARGN}free_token4")

  string(ASCII 29 "${ARGN}bracket_open_code")
  string(ASCII 28 "${ARGN}bracket_close_code")
  string(ASCII 30 "${ARGN}ref_token")
  string(ASCII 21 "${ARGN}free_token")
  string(ASCII 31 "${ARGN}semicolon_code")
  string(ASCII 24 "${ARGN}empty_code")
  string(ASCII 2  "${ARGN}paren_open_code")
  string(ASCII 3  "${ARGN}paren_close_code")
  set("${ARGN}identifier_token" "__")
endmacro()

function(string_codes_print)
  string_codes()
  print_vars(--plain "bracket_open_code")
  print_vars(--plain "bracket_close_code")
  print_vars(--plain "ref_token")
  print_vars(--plain "semicolon_code")
  print_vars(--plain "empty_code")
  print_vars(--plain "paren_open_code")
  print_vars(--plain "paren_close_code")
  print_vars(--plain "free_token")
  print_vars(--plain "free_token1")
  print_vars(--plain "free_token2")
  print_vars(--plain "free_token3")
  print_vars(--plain "free_token4")
endfunction()


# File: source/string/string_combine.cmake

## combines the varargs into a string joining them with separator
## e.g. string_combine(, a b c) => "a,b,c"
function(string_combine separator )
  set(first true)
  set(res)
  foreach(arg ${ARGN})
    if(first )
      set(first false)
    else()
      set(res "${res}${separator}")
    endif()
    set(res "${res}${arg}")
  endforeach()
  return_ref(res)
endfunction()

# File: source/string/string_concat.cmake

function(string_concat)
  #string(CONCAT ans ${ARGN})
  string(REPLACE ";" "" ans "${ARGN}")
  return_ref(ans)
endfunction()

# File: source/string/string_contains.cmake

## `(<str:<string>> <search:<string>>)-><bool>`
##  
## Returns true if the input string "str" contains "search"
##
## **Examples**
##  set(input "endswith")
##  string_contains("${input}" "with") # => true
##  string_contains("${input}" "swi") # => true
##
##
function(string_contains str search)
  string(FIND "${str}" "${search}" index)
  if("${index}" LESS 0)
    creturn(false)
  endif()
  creturn(true)
endfunction()

# File: source/string/string_decode_delimited.cmake

## tries to parse a delimited string
## returns either the original or the parsed delimited string
## delimiters can be specified via varargs
## see also string_take_delimited
function(string_decode_delimited str)
  string_take_delimited(str ${ARGN})
  ans(res)
  if("${res}_" STREQUAL "_")
    return_ref(str)
  endif()
  return_ref(res)
endfunction()

# File: source/string/string_ends_with.cmake

## `(<str:<string>> <search:<string>>)-><bool>`
##  
## Returns true if the input string "str" ends with "search"
##
## **Examples**
##  set(input "endswith")
##  string_ends_with("${input}" "with") # => true
##  string_ends_with("${input}" "width") # => false
##
##
function(string_ends_with str search)
  string(FIND "${str}" "${search}" out REVERSE)
  if(${out} EQUAL -1)
    creturn(false)
  endif()
  string(LENGTH "${str}" len)
  string(LENGTH "${search}" len2)
  math(EXPR out "${out}+${len2}")
  if("${out}" EQUAL "${len}")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/string/string_eval.cmake

## evaluates the string <str> in the current scope
## this is done by macro variable expansion
## evaluates both ${} and @@ style variables
## TODO bug: @@ Does no longer evaluate

macro(string_eval str)
    set_ans("${str}")
endmacro()

# File: source/string/string_find.cmake

## `(<str:<string>> <substr:<string>>)-><int>`
##  
## Returns the position where the "substr" was found 
## in the input "str", otherwise -1. 
## NOTE: The flag REVERSE causes the last position of "substr"
##       to be returned
##
## **Examples**
##  set(input "endswith")
##  string_find("${input}" "with") # => 4
##  string_find("${input}" "swi") # => 3
##
##
function(string_find str substr)
  set(args ${ARGN})
  list_extract_labelled_keyvalue(args --reverse REVERSE)
  ans(reverse)
  string(FIND "${str}" "${substr}" idx ${reverse})
  return_ref(idx)
endfunction()

# File: source/string/string_indent.cmake


  function(string_indent str indentation)
    string_codes()

    set(maxWidth ${ARGN})
    if("${maxWidth}_" STREQUAL "_")
      set(maxWidth 0)
    endif()
    
    # normalize line endings
    string(REPLACE "\r\n" "\n"  str "${str}")

    if("${maxWidth}" LESS 1)
      string(REPLACE "\n" "\n${indentation}" str "${str}")
      set(str "${indentation}${str}")
      return_ref(str)      
    endif()

    # desemicolonize
    string(REPLACE ";" "${semicolon_code}" str "${str}")

    #string(REPLACE "\n" ";" str "${str}")

    string(REPLACE " " ";" str "${str}")
    string(REPLACE "\n" ";${free_token1}" str "${str}")
    set(result)

    set(currentLine)
    set(currentLength 0)
    ## 
    while(true)
     list(LENGTH str size)
      if(NOT size)
        if(NOT "${currentLine}_" STREQUAL "_")
          list(APPEND result "${currentLine}")
        endif()
        break()
      endif()

      list_pop_front(str)
      ans(word)

      if("${word}" STREQUAL "${free_token1}")
        list(APPEND result "${currentLine}")
        set(currentLine)
        continue()
      endif()

     
      set(currentLine "${currentLine} ${word}")
      string(LENGTH "${currentLine}" len)
      if(NOT "${len}" LESS "${maxWidth}")
        list(APPEND result "${currentLine}")
        set(currentLine)
      endif()
    endwhile()

    string(REPLACE "${free_token1}" "\n" result "${result}")

    string(REPLACE ";" "\n" result "${result}")
    string(REPLACE "\n" "\n${indentation}" result "${result}")
    string(REPLACE "${semicolon_code}" ";" result "${result}")
    set(result "${indentation}${result}")

    return_ref(result)
  endfunction()

# File: source/string/string_isempty.cmake

## `(<str:<string>>)-><bool>`
##  
## Returns true if the input string "str" is empty 
## Note: cmake evals "false", "no" which 
##       destroys tests for real emtpiness
##
## **Examples**
##  set(input "")
##  string_isempty("${input}") # => true
##  set(input "false")
##  string_isempty("${input}") # => false
##
##
 function(string_isempty  str)    
    if("_" STREQUAL "_${str}")
      creturn(true)
    endif()
    creturn(false)
 endfunction()

# File: source/string/string_isnumeric.cmake

## `(<str:<string>>)-><bool>`
##  
## Returns true if the input string "str" is a positive integer 
## including "0"
##
## **Examples**
##  set(input "1")
##  string_isnumeric("${input}") # => true
##  set(input "-1")
##  string_isnumeric("${input}") # => false
##
##
function(string_isnumeric str)
  if("_${str}" MATCHES "^_[0-9]+$")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/string/string_length.cmake

## `(<str:<string>>)-><int>`
##  
## Returns the length of the input string "str"
##
## **Examples**
##  set(input "a")
##  string_length("${input}") # => 1
##  set(input "ab c")
##  string_length("${input}") # => 4
##
##
function(string_length str)
  string(LENGTH "${str}" len)
  return_ref(len)
endfunction()

# File: source/string/string_lines.cmake

## `(<input:<string>>)-><string...>`
##  
## Splits the specified string "input" into lines
## Caveat: The string would have to be semicolon encoded
##         to correctly display lines with semicolons 
##
## **Examples**
##  set(input "a\nb")
##  string_lines("${input}") # => "a;b"
##  set(input "a b\nc")
##  string_lines("${input}") # => "a b;c"
##
##
function(string_lines input)      
  string_split("${input}" "\n")

  return_ans(lines)
endfunction()


# File: source/string/string_match.cmake

## `(<input:<string>>)-><bool>`
##  
## Evaluates string "str" against regex "regex".
## Returns true if it matches.
##
## **Examples**
##  set(input "a?")
##  string_match("${input}" "[a-z]+\\?") # => true
##  set(input "a bc .")
##  string_match("${input}" "^b") # => false
##
##
function(string_match  str regex)
  if("${str}" MATCHES "${regex}")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/string/string_normalize.cmake

## `(<input:<string>>)-><string>`
##  
## Replaces all non-alphanumerical characters in the string "input" with an underscore 
##
## **Examples**
##  set(input "a?")
##  string_normalize("${input}") # => "a_"
##  set(input "a bc .")
##  string_normalize("${input}") # => "a bc _"
##
##
function(string_normalize input)
	string(REGEX REPLACE "[^a-zA-Z0-9_]" "_" res "${input}")
	return_ref(res)
endfunction()

# File: source/string/string_normalize_index.cmake

## `(<str:<string>> <index:<int>>)-><int>`
##  
## Normalizes the index "index" of a corresponding input string "str".
## Negative indices are transformed into positive values: length - |index|
## Returns -1 if index is out of bounds (index > length of string or length - |index| + 1 < 0)
##
## **Examples**
##  set(input "abcd")
##  string_normalize_index("${input}" 3) # => 3
##  string_normalize_index("${input}" -2) # => 3
##
##
function(string_normalize_index str index)

  set(idx ${index})
  string(LENGTH "${str}" length)
  if(${idx} LESS 0)
    math(EXPR idx "${length} ${idx} + 1")
  endif()
  if(${idx} LESS 0)
    #message(WARNING "index out of range: ${index} (${idx}) length of string '${str}': ${length}")
    creturn(-1)
  endif()

  if(${idx} GREATER ${length})
    #message(WARNING "index out of range: ${index} (${idx}) length of string '${str}': ${length}")
    creturn(-1)
  endif()
  creturn(${idx})
endfunction()

# File: source/string/string_overlap.cmake

## `(<lhs:<string>> <rhs:<string>>)-><string>`
##  
## Returns the overlapping part of input strings "lhs" and "rhs".
## Starts at first char and continues until chars don't match.
##
## **Examples**
##  set(input1 "abcd")
##  set(input2 "abyx")
##  string_overlap("${input1}" "${input2}") # => "ab"
##  set(input2 "wxyz")
##  string_overlap("${input1}" "${input2}") # => ""
##
##
function(string_overlap lhs rhs)
  string(LENGTH "${lhs}" lhs_length)
  string(LENGTH "${rhs}" rhs_length)

  math_min("${lhs_length}" "${rhs_length}")
  ans(len)

  math(EXPR last "${len}-1")

  set(result)

  foreach(i RANGE 0 ${last})
    string_char_at("${lhs}" ${i})
    ans(l)
    string_char_at("${rhs}" ${i})
    ans(r)
    if("${l}" STREQUAL "${r}")
      set(result "${result}${l}")
    else()
      break()
    endif()
  endforeach()

  return_ref(result)
endfunction()


# File: source/string/string_pad.cmake

## `(<str:<string>> <len:<int>> <argn:<string>>)-><string>`
##  
## Pads the specified string to be as long as specified length "len".
##  - If the string is longer then nothing is padded
##  - If no delimiter is specified than " " (space) is used
##  - If "--prepend" is specified for "argn" the padding is inserted at the beginning of "str"
##
## **Examples**
##  set(input "word")
##  string_pad("${input}" 6) # => "word  "
##  string_pad("${input}" 4) # => "word"
##
##
function(string_pad str len)  
  set(delimiter ${ARGN})
  list_extract_flag(delimiter --prepend)
  ans(prepend)
  if("${delimiter}_" STREQUAL "_")
    set(delimiter " ")
  endif()  
  string(LENGTH "${str}" actual)  
  if(${actual} LESS ${len})
    math(EXPR n "${len} - ${actual}") 

    string_repeat("${delimiter}" ${n})
    ans(padding)
    
    if(prepend)
      set(str "${padding}${str}")
    else()
      set(str "${str}${padding}")    
    endif()    
  endif()
  return_ref(str)
endfunction()

# File: source/string/string_random.cmake

## `()-><string>`
##  
## Returns a randomly generated string.
## TODO: implement
##
## **Examples**
##  string_random() # =>
##
##
function(string_random)
  set(args ${ARGN})
  message(FATAL_ERROR "not implemented")    
endfunction()


# File: source/string/string_regex_escape.cmake

## `(<str:<string>>)-><string>`
##  
## Escapes chars used by regex strings in the input string "str".
## Escaped characters: "\ / ] [ * . - ^ $ ? ) ( |"
##
## **Examples**
##  set(input "()")
##  string_regex_escape("${input}") # => "\(\)"
##  set(input "no_escape")
##  string_regex_escape("${input}") # => "no_escape"
##
##
function(string_regex_escape str)
  #string(REGEX REPLACE "(\\/|\\]|\\.|\\[|\\*)" "\\\\\\1" str "${str}")
  string(REGEX REPLACE "(\\/|\\]|\\.|\\[|\\*|\\$|\\^|\\-|\\+|\\?|\\)|\\(|\\|)" "\\\\\\1" str "${str}")
  return_ref(str)
endfunction()


# File: source/string/string_remove_beginning.cmake

## `(<original:<string>> <beginning:<string>>)-><string>`
##
## Removes the beginning "n"-chars of the string "original".
## Number of chars "n" is calculated based on string "beginning".
##
## **Examples**
##  set(input "abc")
##  string_remove_ending("${input}" "a") # => "ab"
##  string_remove_ending("${input}" "ab") # => "a"
##
##
function(string_remove_beginning original beginning)
  string(LENGTH "${beginning}" len)
  string(LENGTH "${original}" orig_len)
  if(len GREATER orig_len)
    set(len 0)
  endif()
  string(SUBSTRING "${original}" ${len} -1 original)

  return_ref(original)
endfunction()

# File: source/string/string_remove_ending.cmake

## `(<original:<string>> <ending:<string>>)-><string>`
##
## Removes the back "n"-chars of the string "original".
## Number of chars "n" is calculated based on string "ending".
##
## **Examples**
##  set(input "abc")
##  string_remove_ending("${input}" "a") # => "ab"
##  string_remove_ending("${input}" "ab") # => "a"
##
##
function(string_remove_ending original ending)
  string(LENGTH "${ending}" len)
  string(LENGTH "${original}" orig_len)
  math(EXPR len "${orig_len} - ${len}")
  if(len LESS -1)
    set(len -1)
  endif()
  string(SUBSTRING "${original}" 0 ${len} original)

  return_ref(original)
endfunction()


# File: source/string/string_repeat.cmake

## `(<what:<string>> <n:<int>>)-><string>`
##
## Repeats string "what" "n" times and separates them with an optional separator
##
## **Examples**
##  set(input "a")
##  string_repeat("${input}" 2) # => "aa"
##  string_repeat("${input}" 2 "@@") # => "a@@a"
##
##  
function(string_repeat what n)
  set(separator "${ARGN}")
  
  if(${n} LESS 1)
    creturn()
  endif()

  set(res "${what}")

  if(${n} GREATER 1)
    foreach(i RANGE 2 ${n})
      set(res "${res}${separator}${what}")
    endforeach()
  endif()

  return_ref(res)
endfunction()

# File: source/string/string_replace.cmake

## `(<str:<string>> <pattern:<string>> <replace:<string>>)-><string>`
##
## Replaces all occurences of "pattern" with "replace" in the input string "str".
##
## **Examples**
##  set(input "abca")
##  string_replace("a" "z" "${input}") # => "zbcz"
##  set(input "aaa")
##  string_replace("a" "z" "${input}") # => "zzz"
##
##
function(string_replace str pattern replace)
  string(REPLACE "${pattern}" "${replace}" res "${str}")
  return_ref(res)
endfunction()

# File: source/string/string_replace_first.cmake

## `(<string_input:<string>> <string_search:<string>> <string_replace:<string>>)-><string>`
##
## Replaces the first occurence of "string_search" with "string_replace" in the input string "string_input".
##
## **Examples**
##  set(input "abc")
##  string_replace_first("${input}" "a" "z") # => "zbc"
##  set(input "aac")
##  string_replace_first("${input}" "aa" "z") # => "zc"
##
##
function(string_replace_first string_input string_search string_replace)
	string(FIND "${string_input}" "${string_search}" index)
	
	if(${index} LESS 0 OR "${string_search}_" STREQUAL "_")
		return_ref(string_input)
	endif()

	string(LENGTH "${string_search}" search_length)
	string(SUBSTRING "${string_input}" 0 "${index}" part1)
	math(EXPR index "${index} + ${search_length}")
	string(SUBSTRING "${string_input}" "${index}" -1 part2)
	set(res "${part1}${string_replace}${part2}")

	return_ref(res)
endfunction()

# File: source/string/string_shorten.cmake

## `(<str:<string>> <max_length:<int>>)-><string>`
##
## Shortens the string "str" to be at most "max_length" characters long.
## Note on "max_length": max_length includes the shortener string (default 3 chars "...").
## Returns the result in "res".
##
## **Examples**
##  set(input "abcde")
##  string_shorten("${input}" 4) # => "a..."
##  string_shorten("${input}" 3) # => "..."
##  string_shorten("${input}" 2) # => ""
##  string_shorten("${input}" 2 ".") # => "a."
##
##
function(string_shorten str max_length)
  set(shortener "${ARGN}")
  if(shortener STREQUAL "")
    set(shortener "...")
  endif()

  string(LENGTH "${str}" str_len)
  if(NOT str_len GREATER "${max_length}")
    return_ref(str)
  endif()
  
  string(LENGTH "${shortener}" shortener_len)
  math(EXPR max_length "${max_length} - ${shortener_len}")
  
  if(${max_length} LESS 0)
    set(res "")
    return_ref(res)
  endif()

  string(SUBSTRING "${str}" 0 ${max_length} res)
  set(res "${res}${shortener}")
  
  return_ref(res)
endfunction()



# File: source/string/string_slice.cmake

## `(<str:<string>> <start_index:<int>> <end_index:<int>>)-><string>`
##
## Extracts a portion from string "str" at the specified index: [start_index, end_index)
## Indexing of slices starts at 0. Indices less than -1 are translated into "length - |index|"
## Returns the result in "result".
##
## **Examples**
##  set(input "abc")
##  string_slice("${input}" 0 1) # => "a"
##  set(input "abc")
##  string_slice("${input}" 0 2) # => "ab"
##
##
function(string_slice str start_index end_index)
  # indices equal => select nothing

  string_normalize_index("${str}" ${start_index})
  ans(start_index)
  string_normalize_index("${str}" ${end_index})
  ans(end_index)
  
  if(${start_index} LESS 0)
    message(FATAL_ERROR "string_slice: invalid start_index ")
  endif()
  if(${end_index} LESS 0)
    message(FATAL_ERROR "string_slice: invalid end_index")
  endif()
  # copy array
  set(result)
  math(EXPR len "${end_index} - ${start_index}")
  string(SUBSTRING "${str}" ${start_index} ${len} result)

  return_ref(result)
endfunction()
  

# File: source/string/string_split.cmake

## `(<string_subject:<string>> <split_regex:<string>>)-><string...>`
##
## Splits the string "input" at the occurence of the regex "split_regex".
## Returns the result in "res".
## TODO: does not handle strings containing list separators properly
##
## **Examples**
##  set(input "a@@b@@c")
##  string_split("${input}" "@@") # => "a;b;c"
##
##
function(string_split  string_subject split_regex)
	string(REGEX REPLACE ${split_regex} ";" res "${string_subject}")
  return_ref(res)
endfunction()


# File: source/string/string_split_at_first.cmake

## `(<parta:<string&>> <partb:<string&>> <input:<string>> <separator:<string>>)-><parta:<string&>> <partb:<string&>>`
##
## Splits the string "input" at the first occurence of "separator" and returns 
## both parts in the string references "parta" and "partb".
## See **Examples** for passing references.
##
## **Examples**
## 
##  set(input "a@@b@@c")
##  string_split_at_first(partA partB "${input}" "@@") # => partA equals "a", partB equals "b@@c"
##
##
function(string_split_at_first parta partb input separator)
  string(FIND "${input}" "${separator}" idx )
  
  if(${idx} LESS 0 OR "${separator}_" STREQUAL "_")
    set(${parta} "${input}" PARENT_SCOPE)
    set(${partb} "" PARENT_SCOPE)
    creturn()
  endif()

  string(SUBSTRING "${input}" 0 ${idx} pa)
  math(EXPR idx "${idx} + 1")

  string(SUBSTRING "${input}" ${idx} -1 pb)
  set(${parta} ${pa} PARENT_SCOPE)
  set(${partb} ${pb} PARENT_SCOPE)
endfunction()

# File: source/string/string_split_at_last.cmake

## `(<parta:<string&>> <partb:<string&>> <input:<string>> <separator:<string>>)-><parta:<string&>> <partb:<string&>>`
##
## Splits the string "input" at the last occurence of "separator" and returns 
## both parts in the string references "parta" and "partb".
## See **Examples** for passing references.
##
## **Examples**
##  set(input "a@@b@@c")
##  string_split_at_last(partA partB "${input}" "@@") # => partA equals "a@@b", partB equals "c"
##
##
function(string_split_at_last parta partb input separator)
  string(FIND "${input}" "${separator}" idx  REVERSE)

  if(${idx} LESS 0 OR "${separator}_" STREQUAL "_")
    set(${parta} "${input}" PARENT_SCOPE)
    set(${partb} "" PARENT_SCOPE)
    creturn()
  endif()

  string(SUBSTRING "${input}" 0 ${idx} pa)
  math(EXPR idx "${idx} + 1")

  string(SUBSTRING "${input}" ${idx} -1 pb)
  set(${parta} ${pa} PARENT_SCOPE)
  set(${partb} ${pb} PARENT_SCOPE)
endfunction()

# File: source/string/string_split_parts.cmake

## `(<str:<string>> <length:<int>>)-><first_node:<linked list>>`
##
## Splits the string "str" into multiple parts of length "length". 
## Returns a linked list of the parts
##
## **Examples**
##  set(input "abc")
##  string_split_parts("${input}" 1) # => linked_list("a", "b", "c")
##  string_split_parts("${input}" 2) # => linked_list("ab", "c")
##  string_split_parts("${input}" 3) # => linked_list("abc")
##
##
function(string_split_parts str length)
  address_new()
  ans(first_node)
  if(${length} LESS 1)
    return_ref(first_node)
  endif()
  
  set(current_node ${first_node})
  while(true)      
    string(LENGTH "${str}" len)  

    if(${len} LESS ${length})
      address_set(${current_node} "${str}")
      set(str)
    else()
      string(SUBSTRING "${str}" 0 "${length}" part)
      string(SUBSTRING "${str}" "${length}" -1 str)
      address_set(${current_node} "${part}")
    endif()

    if(str)
      address_new()
      ans(new_node)
      map_set_hidden(${current_node} next ${new_node})
      set(current_node ${new_node})
    else()
      return_ref(first_node)
    endif()     
  endwhile()
endfunction()

# File: source/string/string_starts_with.cmake

## `(<str:<string>> <search:<string>>)-><bool>`
##
## Returns true if "str" starts with the string "search"
## 
## **Examples**
##  string_starts_with("substring" "sub") # => true
##  string_starts_with("substring" "ub") # => false
##
##
function(string_starts_with str search)
  string(FIND "${str}" "${search}" out)
  if("${out}" EQUAL 0)
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/string/string_substring.cmake

## `(<str:<string>> <start:<int>> <end:<int>>)-><string>`
##
## Wrapper function for substring.
## Returns a substring of input "str" with the index parameter "start" and optionally "len".
## Note on indexing: len is the amount of chars to be extracted starting from index "start"
## 
## **Examples**
##  string_substring("substring" 1)     # => "ubstring"
##  string_substring("substring" 1 2)   # => "ub"
##  string_substring("substring" -3 2)  # => "ng"
##
##
function(string_substring str start)
  set(len ${ARGN})
  if(NOT len)
    set(len -1)
  endif() 
  string_normalize_index("${str}" "${start}")
  ans(start)

  string(SUBSTRING "${str}" "${start}" "${len}" res)
  return_ref(res)
endfunction()

# File: source/string/string_take.cmake

## `(<str_name:<string&>> <match:<string>>)-><str_name:<string&>> string>`
##
## Removes "match" from a string reference "str_name" and returns the "match" string.
## Only matches from the beginning of the string reference.
## 
## **Examples**
##  set(input "word")
##  string_take(input "w") # => input equals "ord", match equals "w"
##  set(input "word")
##  string_take(input "ord") # => input is unchanged, no match is returned
##
##
function(string_take str_name match)
  string(FIND "${${str_name}}" "${match}" index)
  #message("trying to take ${match}")
  if(NOT ${index} EQUAL 0)
    creturn()
  endif()
  #message("took ${match}")
  string(LENGTH "${match}" len)
  string(SUBSTRING "${${str_name}}" ${len} -1 rest )
  set("${str_name}" "${rest}" PARENT_SCOPE)

  return_ref(match)
endfunction()

# File: source/string/string_take_address.cmake

## `(<str_ref:<string&>>)-><str_ref:<string&>> <string>`
##
## Removes an address (regex format: ":[1-9][0-9]*") from a string reference and returns the address in "res".
## The address is also removed from the input string reference (str_ref).
##
## **Examples**
##
##
function(string_take_address str_ref)
  string_take_regex("${str_ref}" ":[1-9][0-9]*")
  ans(res)
  set(${str_ref} ${${str_ref}} PARENT_SCOPE)   
  return_ref(res)
endfunction()


# File: source/string/string_take_any_delimited.cmake

## `(<str_ref:<string&>> <delimiters:<delimiter:<string>>...>>)-><str_ref:<string&>> <string>`
##
## Removes delimiters of a string and the undelimited string is returned.
## The undelimited string is also removed from the input string reference (__str_ref).
## Notes on the delimiter:
##  - Can be a list of delimiters
##  - Beginning and end delimiter can be specified
##  - May only be a single char
##  - Escaped delimiters are unescaped
##
## **Examples**
##  set(in_ref_str "'a string'")
##  string_take_any_delimited(in_ref_str ') # => in_ref_str equals "" and match equals "a string"
##  set(in_ref_str "\"a string\", <another one>")
##  string_take_any_delimited(in_ref_str "'', <>") # => in_ref_str equals "\"a string\"" and match equals "another one"
##
##
function(string_take_any_delimited str_ref)
  foreach(delimiter ${ARGN})
    string(LENGTH "${${str_ref}}" l1)
    string_take_delimited(${str_ref} "${delimiter}")
    ans(match)
    string(LENGTH "${${str_ref}}" l2)

    if(NOT "${l1}" EQUAL "${l2}")
      set("${str_ref}" "${${str_ref}}" PARENT_SCOPE)
      return_ref(match)
    endif()
  endforeach()

  creturn()
endfunction()


# File: source/string/string_take_delimited.cmake

## `(<__str_ref:<string&>>)-><__str_ref:<string&>> <string>`
##
## Removes delimiters of a string and the undelimited string is returned.
## The undelimited string is also removed from the input string reference (__str_ref).
## Notes on the delimiter:
##  - Default is double quote ""
##  - Beginning and end delimiter can be specified
##  - May only be a single char
##  - Escaped delimiters are unescaped
##
## **Examples**
##  set(in_ref_str "'a string'")
##  string_take_delimited(in_ref_str ') # => in_ref_str equals "" and res equals "a string"
##  set(in_ref_str "'a string'")
##  string_take_delimited(in_ref_str "''") # => same as above
##
##
function(string_take_delimited __string_take_delimited_string_ref )
  regex_delimited_string(${ARGN})
  ans(__string_take_delimited_regex)
  string_take_regex(${__string_take_delimited_string_ref} "${__string_take_delimited_regex}")
  ans(__string_take_delimited_match)
  if(NOT __string_take_delimited_match)
    creturn()
  endif()
  set("${__string_take_delimited_string_ref}" "${${__string_take_delimited_string_ref}}" PARENT_SCOPE)

  # removes the delimiters
  string_slice("${__string_take_delimited_match}" 1 -2)
  ans(res)
  # unescape string
  string(REPLACE "\\${delimiter_end}" "${delimiter_end}" res "${res}")
  return_ref(res) 
endfunction()

## faster version
function(string_take_delimited __str_ref )
  set(input "${${__str_ref}}")

  regex_delimited_string(${ARGN})
  ans(regex)
  if("${input}" MATCHES "^${regex}")
    string(LENGTH "${CMAKE_MATCH_0}" len)
    if(len)
      string(SUBSTRING "${input}" ${len} -1 input )
    endif()
    string(REPLACE "\\${delimiter_end}" "${delimiter_end}" res "${CMAKE_MATCH_1}")
    set("${__str_ref}" "${input}" PARENT_SCOPE)
    set(__ans "${res}" PARENT_SCOPE)
  else()
    set(__ans PARENT_SCOPE)
  endif()

endfunction()



# File: source/string/string_take_regex.cmake

## `(<str_name:<string&>> <regex:<string>> <replace:<string>>)-><str_name:<string&>> <string>`
##
## Tries to match the regex at the begging of ${${str_name}} and returns the match.
## Side effect: Input reference ${str_name} is shortened in the process.
## See **Examples** for passing references.
##
## **Examples**
##  set(in_ref_str "keep_two_whitespaces  ")
##  string_take_regex(in_ref_str "[^ ]*" "") # => in_ref_str equals "  "
##
##
function(string_take_regex str_name regex)
  string(REGEX MATCH "^(${regex})" match "${${str_name}}")
  string(LENGTH "${match}" len)
  if(len)
    string(SUBSTRING "${${str_name}}" ${len} -1 res )
    set(${str_name} "${res}" PARENT_SCOPE)
    return_ref(match)
  endif()
  creturn()
endfunction()

# faster version
function(string_take_regex_replace str_name regex replace)
  string_take_regex(${str_name} "${regex}")
  ans(match)
  if("${match}_" STREQUAL _)
    creturn()
  endif()
  set(${str_name} "${${str_name}}" PARENT_SCOPE)
  string(REGEX REPLACE "${regex}" "${replace}" match "${match}")
  return_ref(match)
endfunction()

## fasterversion does not work in case of nested regex parenthesis
## and unknown matchgroup of rest string
# function(string_take_regex str_name regex)
#   if("${${str_name}}" MATCHES "^(${regex})(.*)$")
#     set(${str_name} "${CMAKE_MATCH_2}" PARENT_SCOPE)
#     set(__ans "${CMAKE_MATCH_1}" PARENT_SCOPE)
    
#     endif()
#   else()
#     set(__ans PARENT_SCOPE)
#   endif()



# endfunction()


## fasterversion
## also does not work.... 
# function(string_take_regex str_name regex)
#   if("${${str_name}}" MATCHES "^(${regex})")
#     set(__ans "${CMAKE_MATCH_1}" PARENT_SCOPE)
#     string(REGEX REPLACE "^(${regex})" "" "${str_name}" "${${str_name}}")
#     set(${str_name} "${${str_name}}" PARENT_SCOPE)    
#   else()
#     set(__ans PARENT_SCOPE)
#   endif()
# endfunction()


# File: source/string/string_take_whitespace.cmake

## `(<__str_ref:<string&>>)-><__str_ref:<string&>>`
##
## Removes preceeding whitespaces of the input string reference.
## See **Examples** for passing references.
##
## **Examples**
##  set(in_ref_str "   test")
##  string_take_whitespace(in_ref_str) # => in_ref_str equals "test"
##  set(in_ref_str "   test  ")
##  string_take_whitespace(in_ref_str) # => in_ref_str equals "test  "
##
##
function(string_take_whitespace __string_take_whitespace_string_ref)
  string_take_regex("${__string_take_whitespace_string_ref}" "[ ]+")
  ans(__string_take_whitespace_res)
  set("${__string_take_whitespace_string_ref}" "${${__string_take_whitespace_string_ref}}" PARENT_SCOPE)
  return_ref(__string_take_whitespace_res)
endfunction()

## Faster version
macro(string_take_whitespace __str_ref)
  if("${${__str_ref}}" MATCHES "^([ ]+)(.*)")
    set(__ans "${CMAKE_MATCH_1}")
    set(${__str_ref} "${CMAKE_MATCH_2}")
  else()
    set(__ans)
  endif()
endmacro()




# File: source/string/string_to_target_name.cmake

function(string_to_target_name str)
  string(REGEX REPLACE " \\-\\\\\\/" "_" str "${str}")
  return_ref(str)
endfunction()

# File: source/string/string_to_title.cmake

## `(<input:<string>>)-><string>`
##
## Transforms the input string to title case.
## Tries to be smart and keeps some words small.
## List of words that are kept small:
## "a, an, and, as, at, but, by, en, for, if, in, of, on, or, the, to, via, vs, v, v., vs."
##
## **Examples**
##  set(input "the function string_totitle works")
##  string_to_title("${input}") # => "The Function string_totitle Works"
##  set(input "testing a small word")
##  string_to_title("${input}") # => "Testing a Small Word"
##
##
function(string_to_title input)
  set(list_keep_small a an and as at but by en for if in of on or the to via vs v v. vs. A An And As At But By En For If In Of On Or The To Via Vs V V. Vs.)
  set(other "[^ ]+")
  set(ws "[ ]+")
  set(is_subsentence true)
  set(res "")

  encoded_list("${input}")
  ans(input_encoded)
  string(REGEX MATCHALL "(${ws})|(${other})" tokens "${input_encoded}")
  
  foreach(token ${tokens})
    if("${token}" MATCHES  "^([^a-zA-Z0-9]*)([a-zA-Z])([a-z]*[']?[a-z]*)([:?!',)]*)$")
      set(pre ${CMAKE_MATCH_1})
      set(first_letter ${CMAKE_MATCH_2})
      set(lc_letters ${CMAKE_MATCH_3})
      set(post ${CMAKE_MATCH_4})
      
      list(FIND list_keep_small "${first_letter}${lc_letters}" index)
      if(index GREATER -1)
         if(is_subsentence)
          string(TOUPPER ${first_letter} first_letter)
        else()
          string(TOLOWER ${first_letter} first_letter)
        endif()
      else()
         string(TOUPPER ${first_letter} first_letter)
      endif()
      
      if("${post}" MATCHES "[^,')]")
        set(is_subsentence true)
      else()
        set(is_subsentence false)
      endif()

      set(token "${pre}${first_letter}${uc_letters}${lc_letters}${post}")
    endif()

    set(res "${res}${token}")
  endforeach()

  return_ref(res)
endfunction()


# File: source/string/string_tolower.cmake

## `(<input:<string>>)-><string>`
##
## Transforms the specified string to lower case.
## 
## **Examples**
##  string_tolower("UPPER") # => "upper"
##
##
function(string_tolower input)
  string(TOLOWER "${input}" input)
  return_ref(input)
endfunction()

# File: source/string/string_toupper.cmake

## `(<input:<string>>)-><string>`
##
## Transforms the specified string to upper case.
## 
## **Examples**
##  string_tolower("lower") # => "LOWER"
##
##
function(string_toupper input)
  string(TOUPPER "${input}" input)
  return_ref(input)
endfunction()

# File: source/string/string_trim.cmake

## `(<input:<string>>)-><string>`
##
## Trims the string, by removing whitespaces at the beginning and end.
## 
## **Examples**
##  string_tolower("  whitespaces  ") # => "whitespaces"
##
##
function(string_trim input)
  string(STRIP "${input}" input)
  return_ref(input)
endfunction()

# File: source/string/string_trim_to_difference.cmake

## `(<lhs:<string&>> <rhs:<string&>>)-><lhs:<string&>> <rhs:<string&>>`
##
## Removes the beginning of the string that matches
## from reference string "lhs" and "rhs". 
## See **Examples** for passing references.
##
## **Examples**
##  set(in_lhs "simple test")
##  set(in_rhs "simple a")
##  string_trim_to_difference(in_lhs in_rhs) # => in_lhs equals "test", in_rhs equals "a" 
##  set(in_lhs "a test")
##  set(in_rhs "b test")
##  string_trim_to_difference(in_lhs in_rhs) # => in_lhs equals "a test", in_rhs equals "b test" 
##
##
function(string_trim_to_difference lhs rhs)
  string_overlap("${${lhs}}" "${${rhs}}")
  ans(overlap)

  string_take(${lhs} "${overlap}")
  string_take(${rhs} "${overlap}")

  set("${lhs}" "${${lhs}}" PARENT_SCOPE)
  set("${rhs}" "${${rhs}}" PARENT_SCOPE)
endfunction()


# File: source/task/is_promise.cmake

## `(<any>)-><bool>`
##
## returns true if the specified argument is a promise
function(is_promise)
  map_get_special("${ARGN}" $type)
  ans(type)
  if("${type}_" STREQUAL "promise_")
    set(__ans true PARENT_SCOPE)
  else()
    set(__ans false PARENT_SCOPE)
  endif()
endfunction()

# File: source/task/is_task.cmake


function(is_task)
  map_get_special("${ARGN}" $type)
  ans(type)
  if("${type}" STREQUAL "task")
    creturn(true)
  endif()
  creturn(false)
endfunction()

# File: source/task/promise.cmake

## `(<task>|<promise>|<any>)-><promise>` 
##
## transforms the input into a promise
## if the input is a promise it is directly retunred
## if input is  a task it is transformed into a promise
## if input is anything else it is wrapped inside a resolved promise
function(promise)
  set(promise "${ARGN}")
  is_promise("${promise}")
  ans(is_promise)
  if(NOT is_promise)
    
    is_task("${promise}")
    ans(is_task)
    if(is_task)
      promise_from_task("${promise}")
      ans(promise)
    else()
      promise_from_value("${promise}")
      ans(promise)
    endif()
  endif()
  task_queue_global()
  ans(task_queue)
  map_set_default("${promise}" task_queue "${task_queue}")  

  return_ref(promise)
endfunction()

function(promise_new)
  map_new()
  ans(promise)
  map_set_special("${promise}" $type promise)
  map_set("${promise}" promise_state "pending")
  return_ref(promise)
endfunction()

function(promise_from_value)
  promise_new()
  ans(promise)
  map_set("${promise}" promise_state "resolved")
  map_set("${promise}" value "${ARGN}")
  return_ref(promise)
endfunction()
  
function(promise_from_task)
  promise_new()
  ans(promise)

  task("${ARGN}")
  ans(task)

  if(NOT task)
    creturn()
  endif()

  map_set("${promise}" task "${task}")
  
  creturn(${promise})
endfunction()


function(promise_from_callable callable)
  task_new("${callable}")
  ans(task)
  promise_from_task("${task}")
  ans(promise)
  return_ref(promise)
endfunction()

function(promise_from_anonymous)
  arguments_anonymous_function(0 ${ARGC})
  ans(function)
  promise_from_callable("${function}")
  return_ans()
endfunction()





# File: source/task/promise_all.cmake

function(promise_all)
  arguments_foreach(0 ${ARGC} promise)
  ans(promises)
  map_new()
  ans(accu)
  list(LENGTH promises count)
  task_anonymous("" ())
  ans(promise_all)
  promise("${promise_all}")
  ans(promise_all)
  foreach(promise ${promises})
    map_tryget("${promise}" task_queue)
    map_set("${promise_all}" task_queue "${__ans}")

    promise_then_anonymous("${promise}" ()
      map_set(${accu} ${promise} \${ARGN})
      map_count(${accu})
      ans(count)
      if(\${count} EQUAL ${count})
        ## this orders the keys in the correct order
        map_set_special("${accu}" keys ${promises})
        map_values("${accu}")
        ans(values)
        promise_resolve("${promise_all}" "\${values}")
      endif()
      )
    
  endforeach()
  return_ref(promise_all)
endfunction()


# File: source/task/promise_continuation_resolve.cmake

## `(<promise>)-><void>`
##
## internal function which resolves a continuation
function(continuation_resolve promise continuation)
  promise_is_resolved("${continuation}")
  ans(continuation_is_resolved)
  if(continuation_is_resolved)
    creturn()
  endif()
  
  map_tryget("${continuation}" task)
  ans(continuation_task)


  map_tryget("${promise}" value)
  ans(value)
  ## decide depending on value and continuation_task 
  ## what to do.
  if(continuation_task)  
    # task_anonymous("" ()
    #   #message("resolving ${promise}'s task continuation ${continuation} with ${value}")
    #   map_set(${continuation_task} arguments ${value})
    #   set(promise ${continuation})
    #   task_invoke(${continuation_task})
    #   ans(result)
    #   #message("task returned \${result}")
    #   promise_resolve("${continuation}" "\${result}")
    #   )
    address_new()
    ans(value_adr)
    address_set("${value_adr}" "${value}")
    task_from_cmake_code("
      address_get(${value_adr})
      ans(value)
      map_set(${continuation_task} arguments \"\${value}\")
      set(promise ${continuation})
      task_invoke(${continuation_task})
      ans(result)
      promise_resolve(${continuation} \"\${result}\")
      ")
    ans(task)
  else()
    # task_anonymous("" ()
    #   #message("resolving ${promise}'s value continuation ${continuation} with ${value}")
    #   promise_resolve("${continuation}" "${value}")
    #   )
    # ans(task)
    task_from_cmake_code("promise_resolve(\"${continuation}\" \"${value}\")")
    ans(task)
  endif()


  ## use the task_queue provided by the continuation 
  ## if that fails use the task queue from the previous promise
  ## if that failes use the global task queue
  map_tryget("${continuation}" task_queue)
  ans(task_queue)
  if(NOT task_queue)
    map_tryget("${promise}" task_queue)
    ans(task_queue)
    if(NOT task_queue)
      message(FATAL_ERROR "no task queue specified")
    endif()
    map_set("${continuation}" task_queue "${task_queue}")
  endif()
  ## append task to task queue
  task_queue_push("${task_queue}" "${task}")


  return_ref(task)
endfunction()


# File: source/task/promise_execute.cmake

function(promise_execute)
  execute(${ARGN} --async)
  ans(process_handle)
  promise_then_anonymous(""
    ()
    process_isrunning("${process_handle}")
    ans(still_running)
    if(still_running)
      map_tryget("\${task}" task_queue)
      ans(task_queue)
      task_queue_push("\${task_queue}" "\${task}")
      creturn()
    endif()
    creturn("${process_handle}")
    )
  return_ans()
endfunction()

# File: source/task/promise_is_resolved.cmake

## `(<promise>)-><bool>`
##
## returns true if the promise is resolved
function(promise_is_resolved promise)
  promise_state("${promise}")
  ans(state)
  if("${state}" STREQUAL "resolved")
    creturn(true)
  endif()
  creturn(false)
endfunction()



# File: source/task/promise_resolve.cmake

## `(<promise> <promise>|<any>...)-><bool>` 
##
## if input is a promise then the promise will be resolved after the input
## promise is resolved
##
## resolves the specified promise
## returns true if promise could be resolved
## returns false if promise was already resolved
## returns <null> if resolution was a promise and promise will be resolved later
function(promise_resolve promise)
  promise("${promise}")
  ans(promise)

  promise_is_resolved("${promise}")
  ans(is_resolved)
  if(is_resolved)
    #message("tried to re-resolve promise ${promise}")
    creturn(false)
  endif()



  is_promise("${ARGN}")
  ans(is_promise)
  if(is_promise)
   # message("trying to resolve promise with promise")
    promise_then("${ARGN}" "${promise}")
    creturn()
  endif()

  ## todo
  ##is_error("${ARGN}")
  ##ans(is_error)


  map_tryget("${promise}" continuations)
  ans(continuations)
  map_set("${promise}" value "${ARGN}")
  map_set("${promise}" promise_state "resolved")
 # message("resolving promise ${promise} with '${ARGN}' ")

  foreach(continuation ${continuations})
    continuation_resolve("${promise}" "${continuation}")
  endforeach()

  creturn(true)
endfunction()

# File: source/task/promise_state.cmake

## `(<promise>)-> <promise state>`
##
## ```
## <promise state> ::= "resolved"|"pending"
## ```
## returns the state of the specified promise
macro(promise_state promise)
  map_tryget("${promise}" promise_state)
endmacro()

# File: source/task/promise_then.cmake

## `(<promise> <continuation:<promise>>)-><promise>`
##
## adds the continuation to the specified promise. 
## when the promise is resolved it will schedule continuation to be executed
function(promise_then promise continuation)
  promise("${promise}")
  ans(promise)

  promise("${continuation}")
  ans(continuation)

  promise_is_resolved("${promise}")
  ans(is_resolved)

  if(is_resolved)
    continuation_resolve("${promise}" "${continuation}")
  else()
    map_append("${promise}" continuations "${continuation}")
  endif()

  return_ref(continuation)
endfunction()


# File: source/task/promise_then_anonymous.cmake

## `(<promise> <inline cmake code>)-><promise>`
##
## adds an inline continuation to the specified promise
function(promise_then_anonymous promise)
  arguments_anonymous_function(1 ${ARGC})
  ans(function)
  promise_from_callable("${function}")
  ans(continuation)
  promise_then("${promise}" "${continuation}")
  return_ans()
endfunction()



# File: source/task/promise_wait.cmake

## `(<promise> [--ticks <uint>] [--timeout <uint>])-><any>...`
##
## waits for the specified promise to complete. causes the execution of 
## the promises task queue.
## --ticks and --timout indicate constaints on how long the tasks will run
function(promise_wait promise)
  map_tryget("${promise}" task_queue)
  ans(task_queue)
  task_queue_run("${task_queue}" ${ARGN})
  map_tryget("${promise}" value)
  return_ans()
endfunction()


# File: source/task/task.cmake

## `(<~task>)-><task>`
##
## coerces taskish to `<task>`
function(task taskish)
  map_get_special("${taskish}" $type)
  ans(type)
  if("${type}_" STREQUAL "task_" AND NOT ARGN)
    creturn("${taskish}")
  endif()
  task_new("${taskish}" ${ARGN})
  return_ans()
endfunction()

# File: source/task/task_anonymous.cmake

## `(<arguments: <any>...> <cmake code>...)-><task>`
##
## convenience functions which creates a task from the specified
## cmake code
## **example**
## ```
##  task_anonymous("1;2;3" (a b c) message("\${a} \${b} \${c}"))
##  ans(task)
##  task_invoke("${task}") ## prints '1 2 3'
## ```
function(task_anonymous arguments)
  arguments_cmake_code(1 ${ARGC})
  ans(code)
  anonymous_function_new("${code}")
  ans(func)
  task_new("${func}" ${arguments})
  return_ans()
endfunction()



# File: source/task/task_enqueue.cmake

## this file should not have the extension .cmake 
## because it needs to be included manually and last
## adds a callable as a task which is to be invoked later
function(task_enqueue callable)

  ## semicolon encode before string_encode_semicolon exists
  string(ASCII  31 us)
  string(REPLACE ";" "${us}" callable "${callable}")
  set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
  
  if(cmakepp_is_loaded)
    function(task_enqueue callable)
      task_new("${callable}")
      ans(task)
      task_queue_global()
      ans(task_queue)
      task_queue_push("${task_queue}" "${task}")
      return_ref(task)
    endfunction()
    address_get(__initial_invoke_later_list)
    ans(tasks)
    foreach(task ${tasks})
      string_decode_semicolon("${task}")
      ans(task)
      task_enqueue("${task}")
    endforeach()
  endif()
endfunction()

# initial version of task_enqueue which is used before cmakepp is loaded
# ## create invoke later functions 
# function(task_enqueue callable)
#   ## semicolon encode before string_encode_semicolon exists
#   string(ASCII  31 us)
#   string(REPLACE ";" "${us}" callable "${callable}")
#   set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
#   creturn()
# endfunction()


# File: source/task/task_from_cmake_code.cmake

  function(task_from_cmake_code code)
    function_new()
    ans(function)
    eval("function(${function})\n ${code} \nendfunction()")
    task_new("${function}")
    return_ans()
  endfunction()


# File: source/task/task_invoke.cmake

## `(<task>)-><true>` 
##
## invokes the specified task
## scope: 
## * `task` instance of the task currently being invoked
## * `task_queue` if invoked in a task_queue
## * `arguments` contains the arguments for the specified task
function(task_invoke task)
  map_tryget(${task} callable)
  ans(callable)
  map_tryget(${task} arguments)
  ans(arguments)
  call2("${callable}" ${arguments})
  ans(res)

  map_set(${task} return_value ${res})
  return_ref(res)    
endfunction()






# File: source/task/task_is_completed.cmake

## `(<task>)-><bool>`
##
## returns true if task is complete
function(task_is_completed task)
  task_state("${task}")
  ans(state)
  if("${state}" STREQUAL "completed")
    creturn(true)
  endif()
  creturn(false)
endfunction()


# File: source/task/task_new.cmake

## `(<~callable> <any>...)-><task>`
## 
## creates a new task accepting a callable and arguments vor its invocation
##
## ```
## <task> ::= {
##   callable: <callable>   ## contains the callable that is invoked
##   arguments: <any>...    ## contains the arguments that the task is invoked with
##   return_value: <any>    ## is set when task is complete
## }
## ```
function(task_new callable)
  if(NOT callable)
    creturn()
  endif()
  callable("${callable}")
  ans(callable)
  if(NOT callable)
    creturn()
  endif()

  map_new()
  ans(task)
  map_set_special(${task} $type task)
  task_queue_global()
  ans(default_task_queue)
  map_set("${task}" task_queue "${default_task_queue}")  
  map_set("${task}" callable "${callable}")
  map_set("${task}" arguments "${ARGN}")
  creturn(${task})
endfunction()



# File: source/task/task_queue_global.cmake

##
##
## returns the global task_queue
function(task_queue_global)
  task_queue_new()
  ans(task_queue)
  eval_cmake(
    function(task_queue_global)
      creturn(${task_queue})
    endfunction()
    )
  creturn(${task_queue})
endfunction()


# File: source/task/task_queue_is_empty.cmake

## 
##
## returns true iff the task queue is empty
function(task_queue_is_empty task_queue)
  linked_list_peek_front("${task_queue}")
  ans(first)
  if(first)
    creturn(false)
  endif()
  creturn(true)
endfunction()


# File: source/task/task_queue_new.cmake

## 
##
## creates a new task queue which is a linked list of tasks.
function(task_queue_new)
  linked_list_new()
  ans(task_queue)
  map_set_special(${task_queue} $type task_queue)
  map_set(${task_queue} is_running false)
  map_set(${task_queue} ticks 0)
  creturn(${task_queue})
endfunction()


# File: source/task/task_queue_push.cmake

##
##
## pushes a task onto the back of the task queue
function(task_queue_push task_queue task)
  task("${task}" ${ARGN})
  ans(task)
  map_set("${task}" task_queue "${task_queue}")
  linked_list_push_back("${task_queue}" ${task})
  ans(node)
  creturn(${task})
endfunction()


# File: source/task/task_queue_push_all.cmake

##
##
## pushes all specified tasks onto the task queue
function(task_queue_push_all task_queue)
  foreach(task ${ARGN})
    task_queue_push("${task_queue}" ${task})
  endforeach()

endfunction()

# File: source/task/task_queue_run.cmake

## 
##
## runs the task queue until it is either empty, maximum number of ticks reached or times out
## returns the number of tasks that where run
## at least one task is run
function(task_queue_run task_queue)
  set(args ${ARGN})
  list_extract_labelled_value(args --ticks)
  ans(max_ticks)
  list_extract_labelled_value(args --timeout)
  ans(timeout)
  set(timer)
  if(NOT "${timeout}_" STREQUAL "_")
    address_new()
    ans(timer)
  endif()

  if("${max_ticks}_" STREQUAL "_")
    set(max_ticks -1)
  endif()

  if(timer)
    timer_start(${timer})
  endif()

  set(ticks 0)
  while(true)
    task_queue_tick("${task_queue}")
    ans(completed_task)
    if(NOT completed_task)
      break()
    endif()
    math(EXPR ticks "${ticks} + 1")
    if("${max_ticks}" GREATER -1 AND NOT ${ticks} LESS ${max_ticks})
      break()
    endif()
    if(timer)
      timer_elapsed(${timer})
      ans(elapsed_time)
      if("${elapsed_time}" GREATER "${timeout}")
        break()
      endif()
    endif()
  endwhile()

  creturn(${ticks})
endfunction()

# File: source/task/task_queue_tick.cmake

##
##
## executes the next task in the task queue 
## returns the executed task. 
## returns nothing if the task queue is empty
function(task_queue_tick task_queue)
  
  linked_list_pop_front("${task_queue}")
  ans(task)
  if(NOT task)
    creturn()
  endif()
  
  map_tryget("${task_queue}" can_tick)
  ans(can_tick)
  if(can_tick)
    call2("${can_tick}" "${task_queue}")
    ans(can_tick)    
    if(NOT can_tick)
      creturn()
    endif()
  endif()


  task_invoke("${task}")
  ans(success)

  return_ref(task)
endfunction()


# File: source/task/task_start.cmake

function(task_start task)
  task_queue_global()
  ans(task_queue)
  task_queue_push("${task_queue}" "${task}")
  creturn()
endfunction()



# File: source/task/task_start_anonymous.cmake

  function(task_start_anonymous arguments)
    arguments_anonymous_function(1 ${ARGC})
    ans(function_name)
    task_new("${function_name}" ${arguments})
    ans(task)
    task_start("${task}")
    return_ref(task)
  endfunction() 


# File: source/task/task_state.cmake

## `(<task>)-><task state>`
## 
## ```
## <task state> ::= "completed"|"running"
## ```
function(task_state task)
  map_has("${task}" return_value)
  ans(is_complete)
  if(is_complete)
    creturn("completed")
  endif()
  creturn("running")
endfunction()


# File: source/task/tqr.cmake

function(tqr)
  task_queue_global()
  ans(task_queue)
  task_queue_run("${task_queue}" ${ARGN})
endfunction()

# File: source/templating/eval_predicate_template_cmake.cmake



function(eval_predicate_template_cmake scope template)
    template_run_scoped("${scope}" "${template}")
    ans(expr)
    eval_predicate_cmake("${expr}")
    ans(use)        
    return_ref(use)
endfunction()

# File: source/templating/helpers/markdown_compile_function.cmake


function(markdown_compile_function file)
  path_qualify(file)
  if(NOT "${file}" MATCHES "(.+)\\.cmake")
    message(FATAL_ERROR "invalid file")
  endif()
  set(target "${CMAKE_MATCH_1}.md")
  markdown_template_function_descriptions(${file})
  ans(res)
  if(NOT res)
    creturn()
  endif()
  fwrite("${target}" "${res}")
  creturn()
endfunction()

# File: source/templating/helpers/markdown_eval.cmake


## evalutes the specified cmake code verbatim and prints it and its result
function(markdown_eval str)
    set(le_code "${str}")
    eval_ref(le_code)
    ans(result)
    set(result "${result}" PARENT_SCOPE)
    is_address("${result}")
    ans(is_address)
    if (is_address)
        json("${result}")
        ans(result)
    else ()
        set(result "`${result}`")
    endif ()
    template_out("${str} # => ${result}")
    creturn()
endfunction()

# File: source/templating/helpers/markdown_include_sourcecode.cmake

function(markdown_include_sourcecode path)
  path("${path}")
  ans(qualified_path)
  if(EXISTS "${qualified_path}")  
    fread("${path}")
    ans(res)
    else()
      set(res "<file does not exist>")
    endif()
    set(res "*${path}*: \n```${ARGN}\n${res}\n```")
    return_ref(res)
endfunction()


# File: source/templating/helpers/markdown_link.cmake


function(markdown_link id name)
    ## get link
    creturn("[${name}](#${id})")
endfunction()

# File: source/templating/helpers/markdown_section.cmake

function(markdown_section id name)
    creturn("## <a name=\"${id}\"></a> ${name}")
endfunction()

# File: source/templating/helpers/markdown_see_function.cmake


function(markdown_see_function function_sig)
  if("${function_sig}" MATCHES "^([a-zA-Z0-9_]+)[ \\t]*\\(")
    set(function_name "${CMAKE_MATCH_1}")

    creturn("[`${function_sig}`](#${function_name})")
  endif()
  creturn()
endfunction()

# File: source/templating/helpers/markdown_template_function_descriptions.cmake

# EXtrack
function(markdown_template_function_descriptions)
  string(REPLACE "\;" ";" files "${ARGN}")
  set(res)
  foreach(template_path ${files})
    fread("${template_path}")
    ans(content)
    cmake_script_comment_header("${content}")
    ans(comments)
    cmake_script_parse("${content}" --first-function-header)
    ans(function_def)
    assign(function_name = function_def.function_args[0])
    if(NOT "${function_name}_" STREQUAL "_")
      get_filename_component(template_dir "${template_path}" PATH)
      pushd("${template_dir}")
      template_run("${comments}")
      ans(comments)
      popd()
      set(res
          "${res}## <a name=\"${function_name}\"></a> `${function_name}`\n\n${comments}\n\n\n\n"
      )
    endif()
  endforeach()
  return_ref(res)
endfunction()


# File: source/templating/helpers/markdown_template_function_header.cmake


function(markdown_template_function_header signature)
  assign(function_name = function_def.function_args[0])

  creturn("[**`${function_name}${signature}`**](${template_path})")
endfunction()


# File: source/templating/helpers/markdown_template_function_list.cmake

function(markdown_template_function_list)
    set(function_list)
    string(REPLACE "\;" ";" files "${ARGN}")
    foreach (file ${files})
        cmake_script_parse_file(${file} --first-function-header)
        ans(function_def)

        assign(function_name = function_def.function_args[0])
        set(function_list "${function_list}\n* [${function_name}](#${function_name})")
    endforeach ()
    return_ref(function_list)
endfunction()

# File: source/templating/helpers/markdown_template_link.cmake

function(markdown_template_link file)
    path_qualify(file)
    path_relative("${root_template_dir}" "${file}")
    ans(relative_path)

    fread_lines("${file}" --limit-count 1 --regex "#+ .*")
    ans(title)

    string(REGEX REPLACE "#+ *(.*)" "\\1" title "${title}")
    creturn("[${title}](${relative_path})")
endfunction()

# File: source/templating/helpers/template_shell.cmake


function(template_shell command)
    if("${command}" STREQUAL "set_base_dir")
        address_set(template_shell_base_dir "${ARGN}")
    endif()
    address_get(template_shell_base_dir)
    ans(shell_base_dir)
    if(NOT shell_base_dir)
        pwd()
        ans(shell_base_dir)
        address_set(template_shell_base_dir "${shell_base_dir}")
    endif()
    
    set(args ${ARGN})
    list_extract_flag(args --echo)
    ans(echo)
    pwd()
    ans(pwd)
    path_relative("${shell_base_dir}" "${pwd}")
    ans(rel_pwd)
    string_combine(" " ${args})
    ans(arg_string)
    template_out("${rel_pwd}/> ${command} ${arg_string}")
    call2("${command}" ${args})
    ans(res)
    if(NOT echo)
        creturn()
    endif()
    json_indented("${res}")
    ans(res)
    string(REPLACE "${shell_base_dir}" "." res "${res}")
    template_out("\n")
    template_out("${res}")
endfunction()


# File: source/templating/map_filter_template_key.cmake


function(map_filter_template_key map scope)
  map_keys("${map}")
  ans(keys)

  foreach(key ${keys})
    eval_predicate_template_cmake("${scope}" "${key}")
    ans(result)

    if(result)
      return_ref(key)
    endif()
  endforeach()  
  creturn()
endfunction()

# File: source/templating/map_template_evaluate_scoped.cmake



 function(map_template_evaluate_scoped scope)
 #todo -> needs to be implemented to correctly do recursion
 ## needs to have max iterations
    if(NOT __recurse)
        set(__recurse true)
        map_new()
        ans(visited)
    endif()

    list(LENGTH scope count)

    if("${count}" EQUAL "0")
        creturn()
    endif()


    if("${count}" GREATER "1")
        set(result)
        foreach(arg ${ARGN})
            map_template_evaluate_scoped("${arg}")
            ans_append(result)            
        endforeach()
        return_ref(result)
    endif()

    set(value ${ARGN})
    is_map("${value}")
    ans(is_map)
    if(NOT is_map)
        template_run_scoped("${scope}" "${value}")
        return_ans()
    endif()

    map_has("${visited}" "${value}")
    ans(result)

    if(result)
        return_ref(result)
    endif()
    

    map_new()
    ans(result)

    map_set(${visited} "${value}" "${result}")

    map_keys("${value}")
    ans(keys)
        
    foreach(key ${keys})
        map_tryget("${value}" "${key}")
        ans(propTemplate)
        map_template_evaluate_scoped("${scope}" ${propTemplate})
        ans(prop)
        map_set("${result}" "${key}" "${prop}")
    endforeach()

    return_ref(result)

        # map_clone_deep(${})
        # ans(clone)


        # if("${value}" STREQUAL "${scope}")
        #     set(scope "${clone}")
        # endif()
            
        # set(changed true)
        # while(changed)




        #     set(changed false)
        #     foreach(key ${keys})
        #         map_tryget(${value} "${key}")
        #         ans(template)
        #         map_tryget(${clone} "${key}")
        #         ans(previousValue)

        #         template_run_scoped(${scope} "${template}" )
        #         ans(value)
        #         print_vars(key template value)

        #         if(NOT "${value}_" STREQUAL "${previousValue}_")
        #             map_set(${clone} "${key}" "${value}")
        #             set(changed true)
        #         endif()
        #     endforeach()
        # endwhile()



# if(changed)
#         creturn()
#     else()
#         creturn(${clone})
#     endif()

    return_ref(result)
    
 endfunction()

# File: source/templating/template/template_begin.cmake

## `()-><void>`
## begins a new template after calling this inner template functions start
## to work (like template_out())
##
function(template_begin)
    address_new()
    ans(ref)
    set(__template_output_stream ${ref} PARENT_SCOPE)
endfunction()


# File: source/templating/template/template_end.cmake

## `()-><generated content:<string>>`
## ends the current template and returns the generated content
function(template_end)
  template_guard()
  address_get("${__template_output_stream}")
  return_ans()
endfunction()


# File: source/templating/template/template_guard.cmake

##
## `()-><template output:<address>>`
##
## fails if not executed inside of a template else returns the 
## template output ref
##
function(template_guard)
  template_output_stream()
  ans(ref)
  if(NOT ref)
    message(FATAL_ERROR "call may only occure inside of a template")
  endif()  
  creturn(${ref})
endfunction()



# File: source/templating/template/template_out.cmake

## `(<string...>) -> <void>`
## 
## writes the specified string(s) to the templates output stream
## fails if not called inside a template
##
function(template_out)
    template_guard()
    ans(ref)
    address_append_string(${ref} "${ARGN}")
    creturn()
endfunction()



# File: source/templating/template/template_out_format.cmake

## `(<format string...?>-><void>`
##
## formats the specified string and and append it to the template output stream
##
function(template_out_format)
  format("${ARGN}")
  ans(res)
  template_out("${res}")
  creturn()
endfunction() 

# File: source/templating/template/template_out_json.cmake

## `(<structured data...>) -> <void>`
## 
## writes the serialized data to the templates output
## fails if not called inside a template
##
function(template_out_json)
  json_indented(${ARGN})
  ans(res)
  template_out("${res}")
  creturn()
endfunction()


# File: source/templating/template/template_output_stream.cmake

## `()-><template output stream:<address>>`
##
## returns the output ref for the template
##
function(template_output_stream)
 creturn(${__template_output_stream})
endfunction()

# File: source/templating/template_compile.cmake

# `(<input:<string>>)-><cmake code>`
#
#
# creates and returns cmake code from specified template string
# the syntax is as follows
# * `<%%` `%%>` encloses cmake code
# * `<%%%` and `%%%>` escape `<%%` and `%%>` resp.
# * shorthands
#     * `<%%=` runs the function specified if possible (only single line function calls allowed) or formats the following nonspace string using the `format()` function (allows things like `<%%="${var} {format.expression[3].navigation.key}%%>`)
#     * single line function calls are `func(.....)` but not `func(... \n ....)`
#     * `@@<cmake function call>` is replaced with `<%%= <cmake function call> %%>`
#     * `@@<navigation expression>` is replaced with `<%%= {<navigation expression>}%%>`
#
# **Examples:**
# * assume `add(lhs rhs) => {lhs+rhs}`
# * assume `data = {a:1,b:[2,3,4],c:{d:5,b:[6,7,8]}}`
# * assume `data2 = "hello!"`
# * `@@@@` => `@@`
# * `<%%%` => `<%%`
# * `%%%>` => `%%>`
# * `@@data2` => `hello!`
# * `@@add(1 4)` => `5`
# * `@@foreach(i RANGE 1 3)@@i@@endforeach()` => `123`
# * `<%%= ${data2} %%>` => `hello!`
# * `<%%= ${data2} ${data2} bye! %%>` => `hello!;hello!;bye!`
# * `<%%= "${data2} ${data2} bye!" %%>` => `hello! hello! bye!`
# * `<%%= add(1 4) %%> => `5`
# * `<%% template_out(hi) %%>` => `hi`
#
# **NOTE** *never use ascii 16 17 18 28 29 31* as these special chars are used internally
function(template_compile input)
  regex_cmake()
  # encode input
  set(delimiter_start "<%")
  set(delimiter_end "%>")
  set(delimiter_start_escape "<%%")
  set(delimiter_end_escape "%%>")
  set(shorthand_indicator "@")
  set(shorthand_indicator_escape "@@")

  string(ASCII 16 shorthand_indicator_code)
  string(ASCII 17 delimiter_code)
  string(ASCII 18 delimiter_start_escape_code)
  string(ASCII 19 delimiter_end_escape_code)
  string(ASCII 20 shorthand_indicator_escape_code)

  string(REPLACE "${shorthand_indicator_escape}"
                 "${shorthand_indicator_escape_code}" input "${input}")
  string(REPLACE "${delimiter_start_escape}" "${delimiter_start_escape_code}"
                 input "${input}")
  string(REPLACE "${delimiter_end_escape}" "${delimiter_end_escape_code}" input
                 "${input}")

  string_encode_semicolon("${input}")
  ans(input)
  string_encode_bracket("${input}")
  ans(input)
  string(REPLACE "${delimiter_start}" "${delimiter_code}" input "${input}")
  string(REPLACE "${delimiter_end}" "${delimiter_code}" input "${input}")
  string(REPLACE "${shorthand_indicator}" "${shorthand_indicator_code}" input
                 "${input}")

  # match all fragments (literal and code fragments)
  set(code_fragment_regex
      "${delimiter_code}([^${delimiter_code}]*)${delimiter_code}")
  set(literal_fragment_regex "([^${delimiter_code}]+)")
  set(regex_cmake_function
      "(${regex_cmake_identifier})?\\(([^\n${shorthand_indicator_code}]*)\\)")

  string(REGEX
         REPLACE "${shorthand_indicator_code}(${regex_cmake_function})"
                 "${delimiter_code}=\\1${delimiter_code}" input "${input}")

  string(
    REGEX
    REPLACE
      # "${shorthand_indicator_code}([^
      # ${shorthand_indicator_code}${delimiter_code}\"'\r\n\\/]+)"
      "${shorthand_indicator_code}((${regex_cmake_identifier})(\\.${regex_cmake_identifier})*)"
      "${delimiter_code}=\"{\\1}\"${delimiter_code}"
      input
      "${input}")

  string(REGEX MATCHALL "(${code_fragment_regex})|(${literal_fragment_regex})"
               fragments "${input}")

  # decode escaped delimiters
  string(REPLACE "${delimiter_start_escape_code}" "${delimiter_start}"
                 fragments "${fragments}")
  string(REPLACE "${delimiter_end_escape_code}" "${delimiter_end}" fragments
                 "${fragments}")
  string(REPLACE "${shorthand_indicator_escape_code}" "${shorthand_indicator}"
                 fragments "${fragments}")
  string(REPLACE "${shorthand_indicator_code}" "${shorthand_hindicator}"
                 fragments "${fragments}")

  address_new()
  ans(result)
  address_append_string("${result}" "template_begin()")

  # set(result)
  foreach(fragment ${fragments})
    # message("${fragment}") decode brackets and semicolon in fragment now the
    # fragment input is exactly the same as it was in input
    string_decode_bracket("${fragment}")
    ans(fragment)

    string_decode_semicolon("${fragment}")
    ans(fragment)

    if("${fragment}" MATCHES "${code_fragment_regex}")
      # handle code fragment
      set(code "${CMAKE_MATCH_1}")

      if("${code}" MATCHES "^>>([a-zA-Z_0-9]+ )(.*)")
        set(func "${CMAKE_MATCH_1}")
        cmake_string_escape("${CMAKE_MATCH_2}")
        ans(output)
        set(code "${func}(${output})\n")
      elseif("${code}" MATCHES "^>([a-zA-Z_0-9]+ )(.*)")
        set(output_var "${CMAKE_MATCH_1}")
        cmake_string_escape("${CMAKE_MATCH_2}")
        ans(output)
        set(code "set(${output_var} \"${output}\")\n")
      endif()

      # special case <%=
      if("${code}" MATCHES "^=(.*)")
        set(code "${CMAKE_MATCH_1}")
        if("${code}" MATCHES "${regex_cmake_function}")
          set(exprcode "expr(\"${CMAKE_MATCH_1}(${CMAKE_MATCH_2})\")")
          # message("'set(__ans) \n ${exprcode} \n
          # template_out(\"\${__ans}\")'")
          set(code "set(__ans) \n ${exprcode} \n template_out(\"\${__ans}\")")
        else()
          set(code "template_out_format(${code})")
        endif()
      else()

      endif()

      address_append_string("${result}" "\n${code}")

    else()
      # handle literal fragment
      cmake_string_escape("${fragment}")
      ans(fragment)
      address_append_string("${result}" "\ntemplate_out(\"${fragment}\")")
    endif()
  endforeach()

  address_append_string("${result}" "\ntemplate_end()")

  address_get(${result})
  ans(res)
  # _message("template_compile\n~~~~~~~~~~~~~~\n${res}\n~~~~~~~~~~~~~~")
  return_ref(res)
endfunction()


# File: source/templating/template_compile_file.cmake

##
## `(<file path>)-> <cmake code>`
## 
## reads the contents of the specified path and generates a template from it
## * return
##   * the generated template code
##
function(template_compile_file path)
  fread("${path}")
  ans(content)
  template_compile("${content}")
  return_ans()
endfunction()

# File: source/templating/template_execute.cmake

## `(<template file:<file path>> <?output file:<file path>>)-><file path>`
##
## compiles the specified template file to the speciefied output file
## if no output file is given the template file is expected to end with `.in`) and the 
## output file will be set to the same path without the `.in` ending
##
## Uses  see [`template_run_file`](#template_run_file) internally. 
##
## returns the path to which it was compiled
##
function(template_execute template_path)
    set(args ${ARGN})
    list_pop_front(args)
    ans(output_file)
    if (NOT output_file)
        if (NOT "${template_path}" MATCHES "\\.in$")
            message(FATAL_ERROR "expected a '.in' file")
        endif ()
        string(REGEX REPLACE "(.+)\\.in" "\\1" output_file "${template_path}")
    endif ()

    template_run_file("${template_path}")
    ans(generated_content)
    fwrite("${output_file}" "${generated_content}")

    creturn("${output_file}")
endfunction()


# File: source/templating/template_run.cmake

## `(<template:<string>>)-><generated content:<string>>`
##
##  this function takes the input string compiles it and evaluates it
##  returning the result of the evaluations
##
function(template_run template)
  template_compile("${template}")
  ans(template_code)
  eval("${template_code}")
  return_ans()
endfunction()


# File: source/templating/template_run_file.cmake

##
## `(<template_path:<file path>>)-><generated content:string>`
##  
## opens the specified template and runs it in its directory
## keeps track of recursive template calling
## * returns 
##    * the output of the template
## * scope
##    * `pwd()` is set to the templates path
##    * `${template_path}` is set to the path of the current template
##    * `${template_dir}` is set to the directory of the current template
##    * `${root_template_dir}` is set to the directory of the first template run
##    * `${root_template_path}` is set to the path of the first template run
##    * `${parent_template_dir}` is set to the calling templates dir 
##    * `${parent_template_path}`  is set to the calling templates path
## 
## 
function(template_run_file template_path)
    template_compile_file("${template_path}")
    ans(template)

    get_filename_component(template_dir "${template_path}" PATH)

    if (NOT root_template_path)
        set(root_template_path "${template_path}")
        get_filename_component(root_template_dir "${template_path}" PATH)
        set(parent_template_dir)
        set(parent_template_path)
    endif ()
    set(parent_template_path "${template_path}")
    set(parent_template_dir "${template_dir}")
    path_relative("${root_template_path}" "${template_path}")
    ans(relative_template_path)

    path_relative("${root_template_dir}" "${template_dir}")
    ans(relative_template_dir)

    pushd("${template_dir}")
    eval("${template}")
    ans(result)
    popd()
    return_ref(result)
endfunction()

# File: source/templating/template_run_scoped.cmake


function(template_run_scoped scope)
  map_import_properties_all("${scope}")
  template_run("${ARGN}")
  return_ans()
endfunction()

# File: source/testing/assert.cmake

# checks to see if an assertion holds true. per default this halts the program if the assertion fails
# usage:
# assert(<assertion> [MESSAGE <string>] [MESSAGE_TYPE <FATAL_ERROR|STATUS|...>] [RESULT <ref>])
# <assertion> := <truth-expression>|[<STRING|NUMBER>EQUALS <list> <list>]
# <truth-expression> := anything that can be checked in if(<truth-expression>)
# <list> := <ref>|<value>|<value>;<value>;...
# if RESULT is set then the assertion will not cause the program to fail but return the true or false
# if ACCU is set result is treated as a list and if an assertion fails the failure message is added to the end of result
# examples
#
# assert("3" STREQUAL "3") => nothing happens
# assert("3" STREQUAL "b") => FATAL_ERROR assertion failed: '"3" STREQUAL "b"'
# assert(EXISTS "none/existent/path") => FATAL_ERROR assertion failed 'EXISTS "none/existent/path"'
# assert(EQUALS a b) => FATAL_ERROR assertion failed ''
# assert(<assertion> MESSAGE "hello") => if assertion fails prints "hello"
# assert(<assertion> RESULT res) => sets result to false if assertion fails or to true if it holds
# assert(EQUALS "1;3;4;6;7" "1;3;4;6;7") => nothing happens lists are equal
# assert(EQUALS 1 2 3 4 1 2 3 4) =>nothing happens lists are equal (see list_equal)
# assert(EQUALS C<list> <list> COMPARATOR <comparator> )... todo
# todo: using the variable result as a boolean check fails because the name is used inside assert

function(assert)
    # parse arguments
    set(options == EQUALS AREEQUAL ARE_EQUAL ACCU SILENT DEREF INCONCLUSIVE ISNULL ISNOTNULL)
    set(oneValueArgs EXISTS COUNT MESSAGE RESULT MESSAGE_TYPE CONTAINS MISSING MATCH MAP_MATCHES FILE_CONTAINS)
    set(multiValueArgs CALL PREDICATE)
    set(prefix)
    cmake_parse_arguments("${prefix}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    #_UNPARSED_ARGUMENTS
    set(result)


    #if no message type is set set FATAL_ERROR
    # so execution halts on failing assertion
    if (NOT _MESSAGE_TYPE)
        set(_MESSAGE_TYPE FATAL_ERROR)
    endif ()

    # if continue is set: set the mesype to statussage t
    if (_RESULT AND _MESSAGE_TYPE STREQUAL FATAL_ERROR)
        set(_MESSAGE_TYPE STATUS)
    endif ()

    if (_DEREF)
        #format( "${_UNPARSED_ARGUMENTS}")
        format("${_UNPARSED_ARGUMENTS}")
        ans(_UNPARSED_ARGUMENTS)
    endif ()

    ## transform call into further arguments
    if (_CALL)
        call(${_CALL})

        ans(vars)
        list(APPEND _UNPARSED_ARGUMENTS ${vars})
    endif ()

    #
    if (_EQUALS OR _ARE_EQUAL OR _AREEQUAL)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: lists not equal [${_UNPARSED_ARGUMENTS}]")
        endif ()
        list_equal(${_UNPARSED_ARGUMENTS})
        ans(result)
    elseif (_EXISTS)
        list_pop_front(_UNPARSED_ARGUMENTS)
        ans(not)
        if (NOT "${not}_" STREQUAL "NOT_")
            set(not)
        endif ()
        path("${_EXISTS}")
        ans(_EXISTS)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: file does not exists ${_EXISTS}")
        endif ()

        if (${not} EXISTS "${_EXISTS}")
            set(result true)
        else ()
            set(result false)
        endif ()
    elseif (_PREDICATE)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: predicate does not hold: '${_PREDICATE}'")
        endif ()
        #	message("predicate '${_PREDICATE}'")
        call(${_PREDICATE} (${_UNPARSED_ARGUMENTS}))
        ans(result)
    elseif (_FILE_CONTAINS)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: file '${_FILE_CONTAINS}' does not contain: ${_UNPARSED_ARGUMENTS}")
        endif ()
        file(READ "${_FILE_CONTAINS}" contents)
        if ("${contents}" MATCHES "${_UNPARSED_ARGUMENTS}")
            set(result true)
        else ()
            set(result false)
        endif ()
    elseif (_INCONCLUSIVE)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion inconclusive")
        endif ()
        set(result true)

    elseif (_MATCH)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: input does not match '${_MATCH}'")
        endif ()
        list_extract_flag_name(_UNPARSED_ARGUMENTS NOT)
        ans(not)

        if (${not} "${_UNPARSED_ARGUMENTS}" MATCHES "${_MATCH}")
            set(result true)
        else ()
            set(result false)
        endif ()
    elseif (_COUNT OR "_${_COUNT}" STREQUAL _0)
        list(LENGTH _UNPARSED_ARGUMENTS len)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: expected '${_COUNT}' elements got '${len}'")
        endif ()
        eval_truth("${len}" EQUAL "${_COUNT}")
        ans(result)
    elseif (_ISNULL)
        if ("${_UNPARSED_ARGUMENTS}_" STREQUAL "_")
            set(result true)
        else ()
            set(_MESSAGE "assertion failed: '${_UNPARSED_ARGUMENTS}' is not null")
            set(result false)
        endif ()
    elseif (_ISNOTNULL)
        if ("${_UNPARSED_ARGUMENTS}_" STREQUAL "_")
            set(result false)
        else ()
            set(_MESSAGE "assertion failed: argument is null")
            set(result true)
        endif ()
    elseif (_MAP_MATCHES)
        data("${_MAP_MATCHES}")
        ans(_MAP_MATCHES)
        map_match("${_UNPARSED_ARGUMENTS}" "${_MAP_MATCHES}")
        ans(result)
        if (NOT _MESSAGE)
            json("${_MAP_MATCHES}")
            ans(expected)
            json("${_UNPARSED_ARGUMENTS}")
            ans(actual)
            set(_MESSAGE "assertion failed: match failed: expected: '${expected}' actual:'${actual}'")
        endif ()

    elseif (_CONTAINS OR _MISSING)
        if (NOT _MESSAGE)
            set(_MESSAGE "assertion failed: list does not contain '${_CONTAINS}' list:(${_UNPARSED_ARGUMENTS})")
        endif ()
        list(FIND _UNPARSED_ARGUMENTS "${_CONTAINS}" idx)

        if (${idx} LESS 0)
            if (_MISSING)
                set(result true)
            else ()
                set(result false)
            endif ()
        else ()
            if (_MISSING)
                set(result false)
            else ()
                set(result true)
            endif ()
        endif ()

    else ()
        # if nothing else is specified use _UNPARSED_ARGUMENTS as a truth expresion
        eval_truth((${_UNPARSED_ARGUMENTS}))
        ans(result)
    endif ()

    # if message is not set add default message
    if ("${_MESSAGE}_" STREQUAL "_")
        list_to_string(_UNPARSED_ARGUMENTS " ")
        ans(msg)
        set(_MESSAGE "assertion failed : '${_UNPARSED_ARGUMENTS}'")
    endif ()

    # print message if assertion failed, SILENT is not specified or message type is FATAL_ERROR
    if (NOT result)
        if (_MESSAGE_TYPE STREQUAL "FATAL_ERROR")
            message("'${_MESSAGE}'")
            message(PUSH "log:")
            log_print(10)
            message(POP)
            message(FATAL_ERROR " ")
        endif ()

        if (NOT _SILENT OR _MESSAGE_TYPE STREQUAL "FATAL_ERROR")
            message(${_MESSAGE_TYPE} "'${_MESSAGE}'")
        endif ()
    endif ()

    # depending on wether to accumulate the results or not
    # set result to a boolean or append to result list
    if (_ACCU)
        set(lst ${_RESULT})
        list(APPEND lst ${_MESSAGE})
        set(${_RESULT} ${lst} PARENT_SCOPE)
    else ()
        set(${_RESULT} ${result} PARENT_SCOPE)
    endif ()

endfunction()

# File: source/testing/assert_matches.cmake

## fails if ARGN does not match expected value
## see map_match
function(assert_matches expected)
  assign(expected = ${expected})
  assign(actual = ${ARGN})
  map_match("${actual}" "${expected}")
  ans(result)
  if(NOT result)
    echo_append("expected: ")
    json_print(${expected})
    echo_append("actual:")
    json_print(${actual})
    _message(FATAL_ERROR "values did not match")
  endif()
endfunction()

# File: source/testing/assertf.cmake



function(assertf)
  set(args ${ARGN})
  list_extract_flag(args DEREF)
  assert(${args} DEREF)
  creturn()
endfunction()

# File: source/testing/define_test_function.cmake



  ## deprecated
  function(define_test_function name parse_function_name)
    set(args ${ARGN})
    list(LENGTH args arg_len)
    matH(EXPR arg_len "${arg_len} + 1")


    string_combine(" " ${args})
    ans(argstring)
    set(evaluated_arg_string)
    foreach(arg ${ARGN})
      set(evaluated_arg_string "${evaluated_arg_string} \"\${${arg}}\"")
    endforeach()
   # messagE("argstring ${argstring}")
   # message("evaluated_arg_string ${evaluated_arg_string}")
    eval("
      function(${name} expected ${argstring})
        arguments_encoded_list(${arg_len} \${ARGC})
        ans(encoded_arguments)
        arguments_sequence(${arg_len} \${ARGC})
        ans(arguments_sequence)
        set(args \${ARGN})
        list_extract_flag(args --print)
        ans(print)
        data(\"\${expected}\")
        ans(expected)
        #if(parsed)
        #  set(expected \${parsed})
        #endif()
        #if(NOT expected)
        #  message(FATAL_ERROR \"invalid expected value\")
        #endif()
        ${parse_function_name}(${evaluated_arg_string} \${args})
        ans(uut)

        if(print)
          json_print(\${uut})
        endif()


        
        map_match(\"\${uut}\" \"\${expected}\")
        ans(res)
        if(NOT res)
          echo_append(\"actual: \")
          json_print(\${uut})
          echo_append(\"expected: \")
          json_print(\${expected})
        endif()
        assert(res MESSAGE \"values do not match\")
      endfunction()

    ")
    creturn()
  endfunction()


# File: source/testing/define_test_function2.cmake


  ## defines a test function
  ## improved version.  use this 
  function(define_test_function2 function_name uut)
    arguments_cmake_string(2 ${ARGC})
    ans(predefined_args)

    #list_extract_flag(predefined_args --timer)
    #ans(timer)
    ## store predefined_args in a ref which is restored 
    ## in function definition
    ## this is necessary because else the args would have to be escaped
    address_new()
    ans(predefined_address)
    address_set(${predefined_address} "${predefined_args}")


    ## define the test function 
    ## which executes the uut and compares
    ## it structurally to the expected value
    define_function("${function_name}" (expected)
      arguments_cmake_string(1 \${ARGC})
      ans(arguments)


      set(scope)
      if("\${expected}" MATCHES "^<(.+)>(.*)$")
        set(scope \${CMAKE_MATCH_1})
        set(expected \${CMAKE_MATCH_2})
      endif()

      obj("\${scope}")
      ans(scope)


      address_get(${predefined_address})
      ans(predefined_args)

      set(__ans)
      set(___code "${uut}(\${predefined_args} \${arguments})")
      
      if(use_timer)
        set(___code "timer_start(t1)\n\${___code}\nans(result)\ntimer_print_elapsed(t1)\nreturn_ref(result)\n")
      endif()
      #print_Vars(___code)
      eval_ref(___code)
      ans(result)

      data("\${expected}")
      ans(expected)

      map_match("\${result}" "\${expected}" )
      ans(res)
      if(NOT res)
        echo_append("actual: ")
        json_print(\${result})
        echo_append("expected: ")
        json_print(\${expected})  
      endif()
      assert(res MESSAGE "values do not match")

      set(test_scope \${scope} PARENT_SCOPE)
      map_keys(\${scope})
      ans(keys)
      foreach(key \${keys})
        map_tryget(\${scope} "\${key}")
        ans(current_value)

        map_match("\${\${key}}" "\${current_value}")
        ans(success)

        assert(success MESSAGE "scope var '\${key}' (\${\${key}}) does not match expected value '\${current_value}'")
      endforeach()

      return_ref(result)
    )
    creturn()
  endfunction()


# File: source/testing/test_execute.cmake

function(test_execute test)
    event_addhandler(on_log_message "[](msg) message(FORMAT '{msg.function}> {msg.message}') ")
    ans(handler)

    message(STATUS "running test ${test}...")

    #initialize variables which test can use

    get_filename_component(test_name "${test}" NAME_WE)

    # intialize message listener

    # setup a directory for the test
    string_normalize("${test_name}")
    ans(test_dir)
    cmakepp_config(temp_dir)
    ans(temp_dir)
    set(test_dir "${temp_dir}/tests/${test_dir}")
    file(REMOVE_RECURSE "${test_dir}")
    get_filename_component(test_dir "${test_dir}" REALPATH)
    path_qualify(test)
    message(STATUS "test directory is ${test_dir}")

    pushd("${test_dir}" --create)
    call("${test}" ())
    popd()

    event_removehandler(on_log_message ${handler})
endfunction()

# File: source/testing/test_new.cmake


function(test_create file)

  get_filename_component(test_name "${test}" NAME_WE) 
  # setup a directory for the test
  string_normalize("${test_name}")
  ans(test_dir)
  cmakepp_config(temp_dir)
  ans(temp_dir)
  set(test_dir "${temp_dir}/tests/${test_dir}")
  file(REMOVE_RECURSE "${test_dir}")
  get_filename_component(test_dir "${test_dir}" REALPATH)
  
  map_capture_new(test_dir test_name)
  return_ans()  
endfunction()



# File: source/timer/timer_delete.cmake

## removes the specified timer
function(timer_delete id)
  map_remove(__timers "${id}")
  creturn()
endfunction()


# File: source/timer/timer_elapsed.cmake

# returns the time elapsed since timer identified by id was started
function(timer_elapsed id)      
  millis()
  ans(now)
  map_get(__timers ${id})
  ans(then)
  # so this has to be done because cmake can't handle numbers which are too large
  string_trim_to_difference(then now)
  map_tryget(__timers __prejudice)      
  ans(prejudice)
  ## if now and the are equal null is returned so here it normalized
  if(NOT now)
    set(now 0)
  endif()
  if(NOT then)
    set(then 0)
  endif()
  math(EXPR elapsed "${now} - ${then} - ${prejudice}")
  math_max(${elapsed} 0)
  ans(elapsed)
  creturn("${elapsed}")
endfunction()

# File: source/timer/timer_print_elapsed.cmake

## prints elapsed time for timer identified by id
function(timer_print_elapsed id)
  timer_elapsed("${id}")
  ans(elapsed)
  message("${ARGN}${id}: ${elapsed} ms")
  creturn()
endfunction()


# File: source/timer/timer_start.cmake

## starts a timer identified by id
## 
function(timer_start id)
  map_set_hidden(__timers __prejudice 0)

  # actual implementation of timer_start
  function(timer_start id)
    return_reset()      
    millis()
    ans(millis)
    map_set(__timers ${id} ${millis})
  endfunction()



  ## this is run the first time a timer is started: 
  ## it calculates a prejudice value 
  ## (the time it takes from timer_start to timer_elapsed to run)
  ## this prejudice value is then subtracted everytime elapse is run
  ## thus minimizing the error

  #foreach(i RANGE 0 3)
    timer_start(initial)  
    timer_elapsed(initial)
    ans(prejudice)

    map_tryget(__timers __prejudice)
    ans(pre)
    math(EXPR prejudice "${prejudice} + ${pre}")
    map_set_hidden(__timers __prejudice ${prejudice})
  #endforeach()


  timer_delete(initial)


  return_reset()
  timer_start("${id}")
endfunction()

# File: source/timer/timers_get.cmake

## returns the list of known timers
function(timers_get)
  map_keys(__timers)
  ans(timers)
  return_ref(timers)
endfunction()


# File: source/timer/timers_print_all.cmake

## prints the elapsed time for all known timer
function(timers_print_all)
  timers_get()
  ans(timers)
  foreach(timer ${timers})
    timer_print_elapsed("${timer}")
  endforeach()  
  creturn()
endfunction()

# File: source/tooling/compile_tool.cmake

# compiles a tool (single cpp file with main method)
# and create a cmake function (if the tool is not yet compiled)
# expects tool to print cmake code to stdout. this code will 
# be evaluated and the result is returned  by the tool function
# the tool function's name is name
# currently only allows default headers
function(compile_tool name src)
    if (CMAKE_HOST_WIN32)
        set(exe_name "${name}.exe")
    else ()
        set(exe_name "${name}")
    endif ()


    checksum_string("${src}")
    ans(chksum)

    cmakepp_config(temp_dir)
    ans(temp_dir)

    cmakepp_config(cache_dir)
    ans(cache_dir)

    set(build_dir "${temp_dir}/tools/${chksum}")
    set(tool_dir "${cache_dir}/tools/${chksum}")

    if (NOT EXISTS "${tool_dir}")
        mkdir("${tool_dir}")
        pushd("${build_dir}" --create)
        fwrite("main.cpp" "${src}")
        fwrite("CMakeLists.txt" "
project(${name})
if (\"\${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")
    include(CheckCXXCompilerFlag)
    CHECK_CXX_COMPILER_FLAG(\"-std=c++11\" COMPILER_SUPPORTS_CXX11)
    CHECK_CXX_COMPILER_FLAG(\"-std=c++0x\" COMPILER_SUPPORTS_CXX0X)
    if (COMPILER_SUPPORTS_CXX11)
        set(CMAKE_CXX_FLAGS \"\${CMAKE_CXX_FLAGS} -std=c++11\")
    elseif (COMPILER_SUPPORTS_CXX0X)
        set(CMAKE_CXX_FLAGS \"\${CMAKE_CXX_FLAGS} -std=c++0x\")
    else ()
        message(STATUS \"The compiler \${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.\")
    endif ()

endif ()
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG \${CMAKE_BINARY_DIR}/bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE \${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG \${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE \${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG \${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE \${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/bin)
add_executable(${name} main.cpp)
      ")
        mkdir(build)
        cd(build)
        cmake(../ --process-handle)
        ans(configure_result)
        cmake(--build . --process-handle)
        ans(build_result)

        map_tryget(${build_result} exit_code)
        ans(error)
        map_tryget(${build_result} stdout)
        ans(log)
        popd()

        if (NOT "${error}" STREQUAL "0")
            rm("${build_dir}")
            rm("${tool_dir}")
            message(FATAL_ERROR "failed to compile tool :\n ${log}")
        endif ()

        cp("${build_dir}/build/bin/${exe_name}" "${tool_dir}/${exe_name}")
    endif ()

    wrap_executable_bare("__${name}" "${tool_dir}/${exe_name}")

    eval("
function(${name})
    __${name}(\${ARGN})
    ans_extract(error)
    if (error)
        message(FATAL_ERROR \"${name} tool (${dir}/build/bin/${name}) failed with \${error}\")
    endif ()
    ans(stdout)
    eval(\"\${stdout}\")
    # _message(\${__ans})
    return_ans()
endfunction()
    ")
endfunction()





# File: source/type/arguments_extract_defined_value_map.cmake



macro(arguments_extract_defined_value_map __start_arg_index __end_arg_index __name)
  arguments_encoded_list("${__start_arg_index}" "${__end_arg_index}")
  set(__current_function_name "${__current_function_name}::${__name}")
  ans(__arg_res)
  parameter_definition_get("${__name}")
  ans(___defs)
  
  if(___defs)
    list_extract_defined_values(__arg_res "${___defs}")
  endif()


  #ans_extract(values)
  #ans(rest)  
endmacro()

# File: source/type/arguments_extract_defined_values.cmake



##  args => contains unparsed arguments
macro(arguments_extract_defined_values __start_arg_index __end_arg_index __name)
  arguments_extract_defined_value_map("${__start_arg_index}" "${__end_arg_index}" "${__name}")
  ans_extract(__map)
  ans(___temp)
  map_import_properties_all("${__map}")
  set(__ans "${___temp}")
  ## ans now contains rest of input list (unparsed args)
  ## 
endmacro()

# File: source/type/arguments_extract_typed_values.cmake

##
##
##
##
macro(arguments_extract_typed_values __start_arg_index __end_arg_index)
  arguments_encoded_list("${__start_arg_index}" "${__end_arg_index}")
  ans(__arg_res)
  list_extract_typed_values(__arg_res ${ARGN})
endmacro()


# File: source/type/help.cmake

## prints help for specified function
function(help)
  

  parameter_definition_get("${ARGN}")
  ans(res)
  if(NOT res)
    message(INFO "no help found for function ${ARGN}")
    creturn()
  endif() 

  map_import_properties(${res} positionals nonpositionals name description)

  message("Usage:")

  if(description)
    string_indent("${description}" "\t" 50)
    ans(description)
    message("${description}\n")
  endif()

  message("\tpositional parameters: ")
  set(counter 0)
  foreach(positional ${positionals})
    map_import_properties(${positional} name type comment optional default_value)
    if(comment)
      set(comment "  --  ${comment}")
    endif()
    if(type)
      set(type ": <${type}>")
    endif()
    if(optional)
      set(optional)
    else()
      set(optional " *required* ")
    endif()    
    if(default_value)
      set(default_value "(= '${default_value}')")
    endif()

    message("\t\t[${counter}] ${name}${optional}${type}${default_value}${comment}")
    math(EXPR counter "${counter} + 1")

  endforeach()
  message("\tnonpositional parameters: ")

  foreach(nonpositional ${nonpositionals})
    map_import_properties(${nonpositional} name type comment optional default_value)
    if(comment)
      set(comment "  --  ${comment}")
    endif()
    if(type)
      set(type ": <${type}>")      
    else()
      set(type)
    endif()

    if(optional)
      set(optional)
    else()  
      if(type)    
        set(optional " *required* ")
      else()
        set(optional)
        set(type ": <flag>")
      endif()
    endif()        
    if(default_value)
      set(default_value "(default = '${default_value}')")
    endif()
    message("\t\t${name}${optional}${type}${default_value}${comment}")
  endforeach()


endfunction()



# File: source/type/helplist.cmake


function(helplist)
  parameter_definition_list()
  ans(keys)
  return_ref(keys)
endfunction()

# File: source/type/list_extract_defined_value.cmake

##
## extracts a single typed value defined by def
##
function(list_extract_defined_value lst def)
  map_tryget(${def} kind)
  ans(kind)
  map_tryget("${def}" type)
  ans(type)
  set(value)
  if("${kind}" STREQUAL "nonpositional")  
    map_tryget("${def}" name)
    ans(name)
    if(NOT type)
      list_extract_flag(${lst} ${name})
      ans(value)
    else()
      list_extract_labelled_value(${lst} ${name})
      ans(value)
    endif()    
  else()
    list_pop_front(${lst})
    ans(value)
  endif()

  encoded_list_decode("${value}")
  ans(value)

  if("${value}_" STREQUAL "_")
    map_tryget("${def}" default_value)
    ans(value)    
  endif()

  map_tryget("${def}" optional)
  ans(optional)

  if(NOT optional AND NOT "${value}_" STREQUAL "_" )
    if(type AND NOT "${type}" MATCHES "^(any)|(string)$" AND COMMAND "t_${type}")  
      eval("t_${type}(\"${value}\")")
      ans_extract(success)
      ans(value)

      if(NOT success)
        message(FATAL_ERROR "could not parse ${type} from '${value}'")
      endif()
    endif()
  else()
    ## optional
  endif()
  
  set(${__lst} ${${__lst}} PARENT_SCOPE)
  return_ref(value)
endfunction()

# File: source/type/list_extract_defined_values.cmake

##
## 
function(list_extract_defined_values __lst defs)
  if(NOT defs)
    message(FATAL_ERROR "no definitions map specified")
  endif()
  map_tryget("${defs}" positionals)
  ans(positionals)
  map_tryget("${defs}" nonpositionals)
  ans(nonpositionals)
  map_new()
  ans(result)
  foreach(def ${nonpositionals} ${positionals})
    list_extract_defined_value(${__lst} "${def}")    
    ans(value)
    map_tryget(${def} variable_name)
    ans(variable_name)
    map_set(${result} "${variable_name}" "${value}")
  endforeach()
  list(APPEND result ${${__lst}})
  return_ref(result)
endfunction()

# File: source/type/list_extract_typed_value.cmake

##  
##
## extracts a `<typed_value>` from the specified list
## ```
##   <typed_value>: ("<"|"[") ["--"] <parameter-name> [ "=>" <argument-name> ] [":" "<" <type-name> ">" ["?"] [ "=" <any> ] ] (">"|"]")
## ```
## the formal definition is relatively hard to understand but using examples it should be easy
## 
## ```
##    set(list1 a --test c b)
##    set(list2 a b c)
##    list_extract_typed_value(list1 [--test])  #=> "test;true"  rest=>a c b
##    list_extract_typed_value(list1 [--test])  #=> ""
##    list_extract_typed_value(list1 [--test:<any>=4])  #=> "test;4"
##    
## ```
function(list_extract_typed_value 
  __lst 
  __letsv_def

  )
  regex_cmake()
  set(__letsv_regex "^([<\\[])(${regex_cmake_flag})(\\{(.*)\\})?(=>(${regex_cmake_identifier}))?(:(.*))?(\\]|>)$")
  if("${__letsv_def}" MATCHES "${__letsv_regex}")
    if(CMAKE_MATCH_6)
      set(__letsv_name ${CMAKE_MATCH_6})
    else()
      set(__letsv_name ${CMAKE_MATCH_2})
    endif()
    set(__letsv_type ${CMAKE_MATCH_8})
    #set(__letsv_comment ${CMAKE_MATCH_4})
    ## set comment if outvar was detected
    if(ARGN)        
      string(REPLACE "\"" "" CMAKE_MATCH_4 "${CMAKE_MATCH_4}")
      set("${ARGN}" "${CMAKE_MATCH_4}" PARENT_SCOPE)        
    endif()
    if("${CMAKE_MATCH_1}" STREQUAL "<")
      set(__letsv_positional true)
    else()
      set(__letsv_positional false)
    endif()

    string(REGEX REPLACE "--(.*)" "\\1" __letsv_identifier "${__letsv_name}")
    string(REPLACE "-" "_" __letsv_identifier "${__letsv_identifier}")

    if(NOT __letsv_type)

    elseif("${__letsv_type}" MATCHES "<(${regex_cmake_identifier})(.*)>(.*)")
      #_message("${__letsv_type} : 0 ${CMAKE_MATCH_0} 1  ${CMAKE_MATCH_1} 2 ${CMAKE_MATCH_2} 3 ${CMAKE_MATCH_3}")
      set(__letsv_type "${CMAKE_MATCH_1}")
      set(__letsv_optional false)
      set(__letsv_default_value)
      if("${CMAKE_MATCH_3}_" STREQUAL "?_")
        set(__letsv_optional true)
      elseif("${CMAKE_MATCH_3}" MATCHES "^=(.*)")
        set(__letsv_default_value ${CMAKE_MATCH_1})
      endif()


      #print_vars(__letsv_identifier __letsv_optional)
    else() 
      message(FATAL_ERROR "invalid __letsv_type __letsv_def: '${__letsv_type}' (needs to be inside angular brackets)")
    endif()


    if(NOT __letsv_positional AND NOT __letsv_type)
      list_extract_flag(${__lst} ${__letsv_name})
      ans(__letsv_value)
    elseif(NOT __letsv_positional)
      list_extract_labelled_value(${__lst} ${__letsv_name})
      ans(__letsv_value)
    else()
      list_pop_front(${__lst})
      ans(__letsv_value)
    endif()

    encoded_list_decode("${__letsv_value}")
    ans(__letsv_value)

    if("${__letsv_value}_" STREQUAL "_")
      set(__letsv_value ${__letsv_default_value})
    endif()

    if(NOT __letsv_optional AND NOT "${__letsv_value}_" STREQUAL "_" )
      if(__letsv_type AND NOT "${__letsv_type}" MATCHES "^(any)|(string)$" AND COMMAND "t_${__letsv_type}")  
        eval("t_${__letsv_type}(\"${__letsv_value}\")")
        ans_extract(__letsv_success)
        ans(__letsv_value_parsed)

        if(NOT __letsv_success)
          message(FATAL_ERROR "could not parse ${__letsv_type} from '${__letsv_value}'")
        endif()
        set(__letsv_value ${__letsv_value_parsed})

      endif()
    else()
      ## optional
    endif()
      


    set(__ans ${__letsv_identifier} ${__letsv_value} PARENT_SCOPE)
    set(${__lst} ${${__lst}} PARENT_SCOPE)
  else()


    message(FATAL_ERROR "invalid definition: ${__letsv_def}")
  endif()
endfunction()

# File: source/type/list_extract_typed_values.cmake



function(list_extract_typed_values __lst)
  regex_cmake()
  string(REGEX MATCHALL "(^|;)<.*>($|;)" __letv_positionals "${ARGN}")
  string(REGEX MATCHALL "(^|;)\\[.*\\]($|;)" __letv_nonpositionals "${ARGN}")
  set(names)    
  foreach(__letv_arg ${__letv_nonpositionals} ${__letv_positionals})
    list_extract_typed_value(${__lst} "${__letv_arg}" __letv_comment)
    ans_extract(__letv_name)
    ans(__letv_value)
    #print_vars(__letv_name __letv_value ${__lst})
    set("${__letv_name}" ${__letv_value} PARENT_SCOPE)
    list(APPEND names ${__letv_name})
    set("${__letv_name}_comment" "${__letv_comment}" PARENT_SCOPE)    
  endforeach()
  set(__extracted_names ${names} PARENT_SCOPE)

  return_ref(${__lst})
endfunction()


# File: source/type/parameter_definition.cmake


## registers a parameter definition for the specified function name
## the function may parse the input values from this definition
## help function can parse the input parameters
function(parameter_definition name)
  if(name)
    ## cache values until cmakepp is loaded
    set_property(GLOBAL APPEND PROPERTY __param_defs ${name})
    set_property(GLOBAL PROPERTY "__param_defs.${name}" "${ARGN}")
    if(NOT cmakepp_is_loaded)
      creturn()
    endif()

    ## actual function
    function(parameter_definition name)
      typed_value_definitions("${name}" ${ARGN})
      ans(definitions)
      map_set(__global_definitions "${name}" "${definitions}")
      creturn(${definitions})
    endfunction()
  endif()
  if(NOT cmakepp_is_loaded)
    creturn()
  endif()

  ## load cached values
  get_property(names GLOBAL PROPERTY __param_defs)
  foreach(name ${names})
    get_property(defstring GLOBAL PROPERTY "__param_defs.${name}")
    parameter_definition("${name}" ${defstring})
  endforeach()


endfunction()

# File: source/type/parameter_definition_get.cmake



function(parameter_definition_get name)
  map_tryget(__global_definitions "${name}")
  return_ans()
endfunction()



# File: source/type/parameter_definition_list.cmake


function(parameter_definition_list)
  map_keys(__global_definitions)
  return_ans()
endfunction()

# File: source/type/prompt.cmake

## prompts the user for input on the console
function(prompt type)

  
  query_type(prompt_input "${type}")
  return_ans()
endfunction()


# File: source/type/prompt_input.cmake


  function(prompt_input)
    echo_append("> ")
    read_line()
    ans(res)
    return_ref(res)
  endfunction()


# File: source/type/prompt_property.cmake



  function(prompt_property prop)
    query_property(prompt_input "${prop}")
    return_ans()
  endfunction()

# File: source/type/property_def.cmake


    ## parses a property 
  function(property_def prop)
    data("${prop}")
    ans(prop)
    is_map("${prop}")
    ans(ismap)

    if(ismap)
      return_ref(prop)
    endif()

    map_new()
    ans(res)


    string_take_regex(prop "[^:]+")
    ans(prop_name)

    if("${prop}_" STREQUAL "_")
      set(prop_type "any")
    else()
      string_take(prop :)
      set(prop_type "${prop}")
    endif()


    map_set(${res} property_name "${prop_name}")
    map_set(${res} display_name "${prop_name}")
    map_set(${res} property_type "${prop_type}")
    return_ref(res)
  endfunction()

# File: source/type/query_fundamental.cmake


  function(query_fundamental input_callback type)
      
      call("${input_callback}"(${type}))
      ans(res)
      return_ref(res)
  endfunction()

# File: source/type/query_properties.cmake


  function(query_properties input_callback type)

    map_new()
    ans(res)

    message_indent_push()
    foreach(property ${properties})
      property_def("${property}")
      ans(property)
      query_property("${input_callback}" "${property}")
      ans(value)
      map_tryget(${property} property_name)
      ans(prop_name)
      map_set(${res} "${prop_name}" "${value}")
    endforeach()
    message_indent_pop()
    return_ref(res)
  endfunction()


# File: source/type/query_property.cmake



  ## queries a property
  function(query_property input_callback property)
    property_def("${property}")
    ans(property)
    map_tryget(${property} "display_name")
    ans(display_name)
    map_tryget(${property} "property_type")
    ans(property_type)
    type_def("${property_type}")
    ans(property_type)
    map_tryget(${property_type} type_name)
    ans(property_type_name)
    message("enter ${display_name} (${property_type_name})")
    query_type("${input_callback}" "${property_type}")
    ans(res)
    return_ref(res)
  endfunction()

  



# File: source/type/query_type.cmake




  ## queries a type
  function(query_type input_callback type)
    type_def("${type}")
    ans(type)

    map_tryget(${type} properties)
    ans(properties)

    list(LENGTH properties is_complex)

    if(NOT is_complex)
      query_fundamental("${input_callback}" "${type}")
      ans(res)
    else()
      query_properties("${input_callback}" "${type}")
      ans(res)      
    endif()
    return_ref(res)
  endfunction()  

# File: source/type/t_bool.cmake


  function(t_bool)
    if(ARGN)
      creturn(true true)
    else()
      creturn(true false)
    endif()    
  endfunction()

# File: source/type/t_callable.cmake


  function(t_callable)
    if(NOT ARGN)
      creturn(false)
    endif()
    callable("${ARGN}")
    ans(callable)
    creturn(true ${callable})
  endfunction()


# File: source/type/t_data.cmake

function(t_data)
  
  fopen_data("${ARGN}")
  ans(data)

  if(data)
    set(data true ${data})
    return_ref(data)
  endif()

  data(${ARGN})
  ans(data)

  if(data)
    set(data true ${data})
    return_ref(data)
  endif()

  creturn(false)
endfunction()

# File: source/type/t_int.cmake

function(t_int)
  if("${ARGN}" MATCHES "-?(0|([1-9][0-9]*))")
    creturn(true ${ARGN})
  else()
    creturn(false)
  endif()
endfunction()

# File: source/type/t_map.cmake

function(t_map)
  obj("${ARGN}")
  ans(map)
  if(NOT map)
    creturn(false)
  endif()
  creturn(true ${map})
endfunction()





# File: source/type/t_path.cmake

function(t_path)
  path("${ARGN}")  
  ans(res)
  creturn(true ${res})
endfunction()

# File: source/type/t_semver.cmake

function(t_semver)
  semver("${ARGN}")
  ans(res)
  if(NOT res)
    creturn(false)
  endif()

  creturn(true ${res})
endfunction()

# File: source/type/t_target_identifier.cmake


function(t_target_identifier)
  if("${ARGN}" MATCHES "^[a-zA-Z0-9_:]+$")  
    creturn(true ${ARGN})
  else()
    creturn(false)
  endif()
endfunction()

# File: source/type/t_uri.cmake


  function(t_uri)
    uri(${ARGN})
    ans(uri)
    if(uri)
      creturn(true ${uri})

    else()
      creturn(false)
    endif()
  endfunction()

# File: source/type/type_def.cmake


## parses and registers a type or returns an existing one by type_name

function(type_def)
  function(type_def)
    data("${ARGN}")
    ans(type)

    if("${type}_" STREQUAL "_")
      set(type any)
    endif()


    list(LENGTH type length)
    if(length GREATER 1)
      map_new()
      ans(t)
      map_set(${t} properties ${type})
      set(type ${t})
    endif()


    is_map("${type}")
    ans(ismap)
    if(ismap)
      map_tryget(${type} type_name)
      ans(type_name)
      if("${type_name}_" STREQUAL "_")
        string(RANDOM type_name)
        map_set("${type}" "anonymous" true)
        #map_set(${type} "type_name" "${type_name}")
      else()
        map_set("${type}" "anonymous" false)
      endif()
    
      map_tryget(data_type_map "${type_name}")
      ans(registered_type)
      if(NOT registered_type)
        map_set(data_type_map "${type_name}" "${type}")
      endif()
      
      map_tryget("${type}" properties)
      ans(props)
      is_map("${props}")
      ans(ismap)
      if(ismap)
        map_iterator("${props}")
        ans(it)
        set(props)
        while(true)
          map_iterator_break(it)
          list(APPEND props "${it.key}:${it.value}")

        endwhile()
        map_set(${type} properties "${props}")
      endif()

      return_ref(type)



    endif()


    map_tryget(data_type_map "${type}")
    ans(res)
    if(res)
      return_ref(res)
    endif()


    map_new()
    ans(res)

    map_set(${res} type_name "${type}")
    map_set(data_type_map "${type}" "${res}")
    return_ref(res)
  endfunction()

  type_def("{
    type_name:'string'
    }")


  type_def("{
    type_name:'int',
    regex:'[0-9]+'
  }")

  type_def("{
    type_name:'any'
  }")


  type_def("{
    type_name:'bool',
    regex:'true|false'
  }")

  
  type_def(${ARGN})
  return_ans()
endfunction()

# File: source/type/typed_value_definition.cmake

##
## parses the specified typed value definition
##
function(typed_value_definition definition)
  regex_cmake()
  set(regex "^([<\\[])(${regex_cmake_flag})(\\{(.*)\\})?(=>(${regex_cmake_identifier}))?(:(.*))?(\\]|>)$")
  if("${definition}" MATCHES "${regex}")   
    set(name "${CMAKE_MATCH_2}")

    if(CMAKE_MATCH_6)
      set(variable_name "${CMAKE_MATCH_6}")    
    else()
      set(variable_name "${CMAKE_MATCH_2}")
    endif()
    set(type_def "${CMAKE_MATCH_8}")
    set(comment "${CMAKE_MATCH_4}")


    if("${CMAKE_MATCH_1}" STREQUAL "<")
      set(kind positional)
    else()
      set(kind nonpositional)
    endif()

    string(REGEX REPLACE "^\"(.*)\"$" "\\1" comment "${comment}")

    set(type)
    set(optional false)
    set(default_value)
    
    if(type_def)
      if("${type_def}" MATCHES "<(${regex_cmake_identifier})(.*)>(.*)")      
        set(type "${CMAKE_MATCH_1}")
        if("${CMAKE_MATCH_3}_" STREQUAL "?_")        
          set(optional true)      
        elseif("${CMAKE_MATCH_3}" MATCHES "^=(.*)")
          set(default_value "${CMAKE_MATCH_1}")
          string(REGEX REPLACE "^\"(.*)\"$" "\\1" default_value "${default_value}")          
        endif()      
      else() 
        message(FATAL_ERROR "invalid type definition for '${definition}': '${__letsv_type}' (needs to be inside angular brackets)")
      endif()
    endif()
    ## replace variable name
    string(REGEX REPLACE "--(.*)" "\\1" variable_name "${variable_name}")
    string(REPLACE "-" "_" variable_name "${variable_name}")

    map_capture_new(name variable_name type_def comment kind type optional default_value)
    return_ans()
  else()
    message(FATAL_ERROR "invalid definition: ${definition}")
  endif()
endfunction()

# File: source/type/typed_value_definitions.cmake

## 
## parsers the spefied type definitions
function(typed_value_definitions name)
  regex_cmake()
  string(REGEX MATCHALL "(^|;)<.*>($|;)" positionals "${ARGN}")
  string(REGEX MATCHALL "(^|;)\\[.*\\]($|;)" nonpositionals "${ARGN}")
  string(REGEX REPLACE "((^|;)<.*>($|;))|(^|;)\\[.*\\]($|;)" "" comments "${ARGN}")
  string(REGEX REPLACE "(^|[\n])[ \t]*#([^\n]*)" "\\2\n" comments "${comments}")

  map_new()
  ans(def)  
  map_set(${def} name "${name}")
  
  if(comments)
    map_set(${def} description "${comments}")
  endif()  
  foreach(positional ${positionals})
  typed_value_definition("${positional}")
    ans(d)
    map_append(${def} positionals ${d})
  endforeach()

  foreach(nonpositional ${nonpositionals})
    typed_value_definition("${nonpositional}")
    ans(d)
    map_append(${def} nonpositionals ${d})
  endforeach()
  creturn(${def})
endfunction()

# File: source/uri/dns_parse.cmake



  function(dns_parse input)
    regex_uri()

    string_take_regex_replace(input "${dns_user_info_regex}" "\\1")
    ans(user_info)
    
    set(host_port "${input}")


    string_take_regex_replace(input "${dns_host_regex}" "\\1")
    ans(host)

    string_take_regex(input "${dns_port_regex}")
    ans(port)


    if(port AND NOT "${port}" LESS 65536)
      creturn()
    endif()
    set(rest ${input})

    set(input "${host}")
    string_take_regex(input "${ipv4_regex}")
    ans(ip)

    set(top_label)
    set(labels)
    if(NOT ip)
      while(true)
        string_take_regex(input "${dns_domain_label_regex}")
        ans(label)
        if("${label}_" STREQUAL "_")
          break()

        endif()
        set(top_label "${label}")
        list(APPEND labels "${label}")
        string_take_regex(input "${dns_domain_label_separator}")
        ans(separator)
        if(NOT separator)
          break()
        endif()

      endwhile()


    endif()

    list(LENGTH labels len)
    set(domain)
    if("${len}" GREATER 1)
      list_slice(labels -3 -1)
      ans(domain)
      string_combine("." ${domain} )
      ans(domain)
    else()
      set(domain "${top_label}")
    endif()

    string_split_at_first(user_name password "${user_info}" ":")


    set(normalized_host "${host}")
    if("${normalized_host}_" STREQUAL "_" )
      set(normalized_host localhost)
    endif()

    map_capture_new(
      user_info
      user_name
      password
      host_port
      host
      normalized_host
      labels
      top_label
      domain
      ip
      port
      rest
      )
    return_ans()
  endfunction()

# File: source/uri/uri.cmake

function(uri uri)
  is_address("${uri}")
  ans(ismap)
  if(ismap)
    return_ref(uri)
  endif()
  uri_parse("${uri}" ${ARGN})
  ans(uri)
  return_ref(uri)
endfunction()



# File: source/uri/uri_check_scheme.cmake

## 
## checks to see if all specified items are in list 
## using list_check_items
## 
function(uri_check_scheme uri)
  uri_coerce(uri)
  map_tryget(${uri} schemes)
  ans(schemes)
  list_check_items(schemes ${ARGN})
  return_ans()
endfunction()

# File: source/uri/uri_coerce.cmake

##
## forces the specified variable reference to become an uri
macro(uri_coerce __uri_ref)
  uri("${${__uri_ref}}")
  ans("${__uri_ref}")
endmacro()

# File: source/uri/uri_decode.cmake

## decodes an uri encoded string ie replacing codes %XX with their ascii values
 function(uri_decode str)
  set(hex "[0-9A-Fa-f]")
  set(encoded "%(${hex}${hex})")
  string(REGEX MATCHALL "${encoded}" matches "${str}")

  list(REMOVE_DUPLICATES matches)
  foreach(match ${matches})
    string(SUBSTRING "${match}" 1 -1  hex_code)
    hex2dec("${hex_code}")
    ans(dec_code)
    string(ASCII "${dec_code}" char)
    string(REPLACE "${match}" "${char}" str "${str}")
  endforeach()
  return_ref(str)

 endfunction()

# File: source/uri/uri_encode.cmake

## encodes a string to uri format 
## if you can pass decimal character codes  which are encoded 
## if you do not pass any codes  the characters  recommended by rfc2396
## are encoded
function(uri_encode str ) 

  if(NOT ARGN)
    uri_recommended_to_escape()
    ans(codes)
    list(APPEND codes)
  else()
    set(codes ${ARGN})
  endif()

  foreach(code ${codes})
    string(ASCII "${code}" char)
    dec2hex("${code}")
    ans(hex)
    # pad with zero
    if("${code}" LESS  16)
      set(hex "0${hex}")
    endif()

    string(REPLACE "${char}" "%${hex}" str "${str}" )
  endforeach()

  return_ref(str)
endfunction()



# File: source/uri/uri_format.cmake


  function(uri_format uri)
    set(args ${ARGN})

    list_extract_flag(args --no-query)
    ans(no_query)

    list_extract_flag(args --no-scheme)
    ans(no_scheme)

    list_extract_labelled_value(args --remove-scheme)
    ans(remove_scheme)



    obj("${args}")
    ans(payload)


    uri("${uri}")
    ans(uri)
    map_tryget("${uri}" params)
    ans(params)

    if(payload)

      map_merge( "${params}" "${payload}")
      ans(params)
    endif()

    set(query)
    if(NOT no_query)
      uri_params_serialize("${params}")
      ans(query)
      if(query)
        set(query "?${query}")
      endif()
    endif()

    if(NOT no_scheme)

      if(NOT remove_scheme STREQUAL "")
        map_tryget("${uri}" schemes)
        ans(schemes)

        string(REPLACE "+" ";" remove_scheme "${remove_scheme}")

        list_remove(schemes ${remove_scheme})
        string_combine("+" ${schemes})
        ans(scheme)
      else()
        map_tryget("${uri}" scheme)
        ans(scheme)
      endif()

      if(NOT "${scheme}_" STREQUAL "_")
        set(scheme "${scheme}:")
      endif()
    endif()

    map_tryget("${uri}" net_path)
    ans(net_path)

    if("${net_path}_" STREQUAL "_")
      map_tryget(${uri} path)
      ans(path)
      set(uri_string "${scheme}${path}${query}")
    else()
      set(uri_string "${scheme}//${net_path}${query}")
    endif()
    return_ref(uri_string)

  endfunction()

# File: source/uri/uri_normalize_input.cmake


## normalizes the input for the uri
## expects <uri> to have a property called input
## ensures a property called uri is added to <uri> which contains a valid uri string 
function(uri_normalize_input input_uri)
  set(flags ${ARGN})


  # options  
  set(handle_windows_paths true)
  set(default_file_scheme true)
  set(driveletter_separator :)
  set(delimiters "''" "\"\"" "<>")
  set(encode_input 32) # character codes to encode in delimited input
  set(ignore_leading_whitespace true)
  map_get("${input_uri}" input)
  ans(input)

  if(ignore_leading_whitespace)
    string_take_whitespace(input)
  endif()

  set(delimited)
  foreach(delimiter ${delimiters})
    string_take_delimited(input "${delimiter}")
    ans(delimited)
    if(NOT "${delimited}_" STREQUAL "_")
      break()
    endif()
  endforeach()

  set(delimiters "${delimiter}")

    # if string is delimited encode whitespace 
    if(NOT "${delimited}_" STREQUAL "_")
      set(rest "${input}")
      set(input "${delimited}")
      
      if(ignore_leading_whitespace)
        string_take_whitespace(input)
      endif()

      if(encode_input)
        uri_encode("${input}" 32)
        ans(input)
      endif()
    endif()

    

    # the whole uri is delimited by a space or end of string
    set(CMAKE_MATCH_1)
    set(CMAKE_MATCH_2)
    set(uri)
    if("_${input}" MATCHES "^_(${uric}+)(.*)")
      set(uri "${CMAKE_MATCH_1}")
      set(input "${CMAKE_MATCH_2}")
    endif()
    #string_take_regex(input "${uric}+")
    #ans(uri)

    if("${rest}_" STREQUAL "_")
      set(rest "${input}")
    endif()


    set(windows_absolute_path false)
    if(default_file_scheme)
      if(handle_windows_paths)
        # replace backward slash with forward slash
        # for windows paths - non standard behaviour
        string(REPLACE \\ /  uri "${uri}")
      endif()  


      if("_${uri}" MATCHES "^_/" AND NOT "_${uri}" MATCHES "^_//")
        set(uri "file://${uri}")
      endif()

      if("_${uri}" MATCHES "^_[a-zA-Z]:")
        #local windows path no scheme -> scheme is file://
        # <drive letter>: is replaced by /<drive letter>|/
        # also colon after drive letter is normalized to  ${driveletter_separator}
        string(REGEX REPLACE "^_([a-zA-Z]):(.+)" "\\1${driveletter_separator}\\2" uri "_${uri}")
        set(uri "file:///${uri}")
        set(windows_absolute_path true)
      endif()

    endif()
    
    # the rest is not part of input_uri
    map_capture(${input_uri} uri rest delimited_rest delimiters windows_absolute_path)
    return_ref(input_uri)

endfunction()


# File: source/uri/uri_params_deserialize.cmake


  function(uri_params_deserialize query)
      
    string(REPLACE "&" "\;" query_assignments "${query}")
    set(query_assignments ${query_assignments})
    string(ASCII 21 c)
    map_new()
    ans(query_data)
    foreach(query_assignment ${query_assignments})
      string(REPLACE "=" "\;"  value "${query_assignment}")
      set(value ${value})
      list_pop_front(value)
      ans(key)
      set(path "${key}")      

      string(REPLACE "[]" "${c}" path "${path}")      
      string(REGEX REPLACE "\\[([^0-9]+)\\]" ".\\1" path "${path}")
      string(REPLACE "${c}" "[]" path "${path}")


      uri_decode("${path}")
      ans(path)
      uri_decode("${value}")
      ans(value)  


      ref_nav_set("${query_data}" "!${path}" "${value}")

    endforeach()
    return_ref(query_data)
  endfunction()

# File: source/uri/uri_params_serialize.cmake

  function(uri_params_serialize )
    function(uri_params_serialize_value)

      set(path ${path})
      list_pop_front(path)
      ans(first)


      set(res "${first}")
      foreach(part ${path})
        uri_encode("${part}")
        ans(part)
        set(res "${res}[${part}]")
      endforeach()

      uri_encode("${node}")
      ans(node)
      set(res "${res}=${node}")
      map_append(${context} assignments ${res})
    endfunction()
   map()
    kv(value uri_params_serialize_value)
   end()
  ans(callbacks)
  function_import_table(${callbacks} uri_params_serialize_callback)

  # function definition
  function(uri_params_serialize obj )
    obj("${obj}")
    ans(obj)  
    map_new()
    ans(context)
    dfs_callback(uri_params_serialize_callback ${obj})
    map_tryget(${context} assignments)
    ans(assignments)
    string_combine("&" ${assignments})
    return_ans()  
  endfunction()
  #delegate
  uri_params_serialize(${ARGN})
  return_ans()
  endfunction()

# File: source/uri/uri_parse.cmake

## parses an uri
## input can be any path or uri
## whitespaces in segments are allowed if string is delimited by double or single quotes(non standard behaviour)
##{
#  scheme,
#  net_root: # is // if the uri is a net uri
#  authority: # is the authority part if uri has a net_root
#  abs_root: # is / if the uri is a absolute path
#  segments: # an array of uri segments (folder)
#  file: # the last segment 
#  file_name: # the last segment without extension 
#  extension: # extension of file 
#  rest: # the ret of the input string which is not part of the uri
#  query: # the query part of the uri 
#  fragment # fragment part of uri
# }
##
##
##
function(uri_parse str)
  set(flags ${ARGN})

  list_extract_labelled_value(flags --into-existing)
  ans(res)
  list_extract_flag(flags --basic)
  ans(basic)
  list_extract_flag(flags --notnull)
  ans(notnull)
  if(notnull)
    set(notnull --notnull)
  else()
    set(notnull)
  endif()


  regex_uri()



  # set input data for uri
  if(NOT res)
    map_new()
    ans(res)
  endif()


  map_set(${res} input "${str}")
  

  ## normalize input of uri
  uri_normalize_input("${res}" ${flags})
  map_get("${res}" uri)
  ans(str)
  # scheme
  set(CMAKE_MATCH_1)
  set(CMAKE_MATCH_2)
  if("_${str}" MATCHES "^_(${scheme_regex})${scheme_delimiter}(.*)")
    set(scheme "${CMAKE_MATCH_1}")
    set(str "${CMAKE_MATCH_2}")
  else()
    set(scheme)
  endif()
  #string_take_regex(str "${scheme_regex}:")
  #ans(scheme)

  #if(NOT "${scheme}_"  STREQUAL _)
  #  string_slice("${scheme}" 0 -2)
  #  ans(scheme)
  #endif()

  # scheme specic part is rest of uri
  set(scheme_specific_part "${str}")


  # net_path
  set(net_path)
  set(authority)
  set(CMAKE_MATCH_1)
  set(CMAKE_MATCH_2)
  if("_${str}" MATCHES "^_(${net_root_regex})(.*)")
    set(net_path "${CMAKE_MATCH_1}")
    set(str "${CMAKE_MATCH_2}")
    set(CMAKE_MATCH_1)
    set(CMAKE_MATCH_2)
    if("_${str}" MATCHES "^_(${authority_regex})(.*)")
      set(authority "${CMAKE_MATCH_1}")
      set(str "${CMAKE_MATCH_2}")
    endif()
  endif()
  #string_take_regex(str "${net_root_regex}")
  #ans(net_path)

  # authority
#  set(authority)
 # if(net_path)
  #  string_take_regex(str "${authority_regex}")
   # ans(authority)
 # endif()

  set(path)
  set(CMAKE_MATCH_1)
  set(CMAKE_MATCH_2)
  if("_${str}" MATCHES "^_(${path_char_regex}+)(.*)")
    set(path "${CMAKE_MATCH_1}")
    set(str "${CMAKE_MATCH_2}")
  endif()




  if(net_path)
    set(net_path "${authority}${path}")
  endif()


 # string_take_regex(str "${path_char_regex}+")
 # ans(path)

  set(query)
  set(CMAKE_MATCH_1)
  set(CMAKE_MATCH_2)
  if("_${str}" MATCHES "^_${query_delimiter}(${query_char_regex}*)(.*)")
    set(query "${CMAKE_MATCH_1}")
    set(str "${CMAKE_MATCH_2}")
  endif()
  #string_take_regex(str "${query_regex}")
  #ans(query)
  #if(query)
  #  string_slice("${query}" 1 -1)
  #  ans(query)
  #endif()

  set(CMAKE_MATCH_1)
  set(CMAKE_MATCH_2)
  set(fragment)
  if("_${str}" MATCHES "^_${fragment_delimiter_regex}(${fragment_char_regex}*)(.*)")
    set(fragment "${CMAKE_MATCH_1}")
    set(str "${CMAKE_MATCH_2}")
  endif()

  #string_take_regex(str "${fragment_regex}")
  #ans(fragment)
  #if(fragment)
  #  string_slice("${fragment}" 1 -1)
  #  ans(fragment)
  #endif()


  map_capture(${res}
    
    scheme 
    scheme_specific_part
    net_path
    authority 
    path      
    query 
    fragment 

    ${notnull}
  )


  if(NOT basic)
    # extended parse
    uri_parse_scheme(${res})
    uri_parse_authority(${res})
    uri_parse_path(${res})
    uri_parse_file(${res})
    uri_parse_query(${res})      
  endif()


  return_ref(res)

endfunction()

# File: source/uri/uri_parse_authority.cmake

function(uri_parse_authority uri)
  map_get(${uri} authority)
  ans(authority)

  map_get(${uri} net_path)
  ans(net_path)

  ## set authoirty to localhost if no other authority is specified but it is a net_path (starts wth //)
  if("_authority" STREQUAL "_" AND NOT "${net_path}_" STREQUAL "_")
    set(authority localhost)
  endif()

  dns_parse("${authority}")
  ans(dns)


  map_iterator(${dns})
  ans(it)
  while(true)
    map_iterator_break(it)
    if(NOT "${it.key}" STREQUAL "rest")
      map_set(${uri} ${it.key} ${it.value})
    endif()
  endwhile()

  creturn()

endfunction()


# File: source/uri/uri_parse_file.cmake

## expects last_segment property to exist
## ensures file_name, file, extension exists
function(uri_parse_file uri)
  map_get("${uri}" last_segment)
  ans(file)

  if ("_${file}" MATCHES "\\.") # file contains an extension
      string(REGEX MATCH "[^\\.]+$" extension "${file}")
      string(LENGTH "${extension}" extension_length)

      if (extension_length)
          math(EXPR extension_length "0 - ${extension_length}  - 2")
          string_slice("${file}" 0 ${extension_length})
          ans(file_name)
      endif ()
  else ()
      set(file_name "${file}")
      set(extension "")
  endif ()
  map_capture(${uri} file extension file_name)
endfunction()

# File: source/uri/uri_parse_path.cmake

function(uri_parse_path uri)
    map_get("${uri}" path)
    ans(path)

    set(segments)
    set(encoded_segments)
    set(last_segment)
    string_take_regex(path "${segment_separator_char}")
    ans(slash)
    set(leading_slash ${slash})

    while (true)
        string_take_regex(path "${segment_char}+")
        ans(segment)

        if ("${segment}_" STREQUAL "_")
            break()
        endif ()

        string_take_regex(path "${segment_separator_char}")
        ans(slash)

        list(APPEND encoded_segments "${segment}")

        uri_decode("${segment}")
        ans(segment)
        list(APPEND segments "${segment}")
        set(last_segment "${segment}")
    endwhile ()

    set(trailing_slash "${slash}")
    set(normalized_segments)
    set(current_segments ${segments})

    while (true)
        list_pop_front(current_segments)
        ans(segment)

        if ("${segment}_" STREQUAL "_")
            break()
        elseif ("${segment}" STREQUAL ".")

        elseif ("${segment}" STREQUAL "..")
            list(LENGTH normalized_segments len)

            list_pop_back(normalized_segments)
            ans(last)
            if ("${last}" STREQUAL "..")
                list(APPEND normalized_segments .. ..)
            elseif ("${last}_" STREQUAL "_")
                list(APPEND normalized_segments ..)
            endif ()
        else ()
            list(APPEND normalized_segments "${segment}")
        endif ()
    endwhile ()

    if (("${segments}_" STREQUAL "_") AND leading_slash)
        set(trailing_slash "")
    endif ()

    map_capture(${uri} segments encoded_segments last_segment trailing_slash leading_slash normalized_segments)
    creturn()
endfunction()

# File: source/uri/uri_parse_query.cmake

## parses the query field of uri and sets  the uri.params field to the parsed data
function(uri_parse_query uri)
  map_tryget(${uri} query)
  ans(query)
  uri_params_deserialize("${query}")
  ans(params)
  map_set(${uri} params ${params})
  creturn()

endfunction()

# File: source/uri/uri_parse_scheme.cmake

function(uri_parse_scheme uri)
  map_tryget(${uri} scheme)
  ans(scheme)

  string(REPLACE "+" "\;" schemes "${scheme}")
  map_set(${uri} schemes ${schemes})

endfunction()

# File: source/uri/uri_qualify_local_path.cmake


  ## tries to interpret the uri as a local path and replaces it 
  ## with a normalized local path (ie file:// ...)
  ## returns a new uri
  function(uri_qualify_local_path uri)
    uri("${uri}")
    ans(uri)

    map_tryget(${uri} input)
    ans(uri_string)

    map_tryget(${uri} normalized_host)
    ans(normalized_host)

    map_tryget("${uri}" scheme)
    ans(scheme)


    ## check if path path is going to be local
    eval_truth(
       "${scheme}_" MATCHES "(^_$)|(^file_$)" # scheme is file
       AND normalized_host STREQUAL "localhost" # and host is localhost 
       AND NOT "${uri_string}" MATCHES "^[^/]+:" # and input uri is not scp like ssh syntax
     ) 
    ans(is_local)

    ## special handling of local path
    if(is_local)
      ## use the locally qualfied full path
      map_get("${uri}" path)
      ans(local_path)
      path_qualify(local_path)
      map_tryget(${uri} params)
      ans(params)
      uri("${local_path}")
      ans(uri)
      map_set("${uri}" params "${params}")
    endif()
    return_ref(uri)
  endfunction()

# File: source/uri/uri_recommended_to_escape.cmake


## characters specified in rfc2396
## 37 %  (percent)
## 126 ~ (tilde) 
## 1-32 (control chars) (nul is not allowed) 
## 127 (del)
## 32 (space)
## 35 (#) sharp fragment identifer
## 60 (<) 62 (>) 34 (") delimiters 
## unwise 
## 123 { 125 } 124 | 92 \ 94 ^ 91 [ 93 ] 96 `

function(uri_recommended_to_escape)
  ## control chars
  index_range(1 31)
  ans(dec_codes)

  
  list(APPEND dec_codes 
    32   # space
    34   # "
    35   # #
    60   # <
    62   # >
    91   # [
    93   # ]
    94   # ^ 
    96   # ` 
    123  # {
    124  # |
    125  # }
    127  # del
    )

  set(dec_codes
      37   # %  (this is prepended - important in uri_encode )
      ${dec_codes}
      )
  return_ref(dec_codes)



endfunction()

# File: source/uri/uri_remove_scheme.cmake

  function(uri_remove_schemes uri)
    uri("${uri}")
    ans(uri)
    map_tryget(${uri} schemes)
    ans(schemes)
    list_remove(schemes ${ARGN})
    map_set(${uri} schemes)
    list_combine("+" ${schemes})
    ans(scheme)
    map_tryget(${uri} scheme)
    return_ref(uri)
  endfunction()

  function(uri_set_schemes uri)
    uri("${uri}")
    ans(uri)
    


    map_set(${uri} schemes ${ARGN})

    list_combine("+" ${ARGN})
    ans(scheme)

    map_tryget("${uri}" scheme)
    ans(old_scheme)

    map_set("${uri}" scheme "${scheme}")


    map_tryget(${uri} uri)
    ans(uri_string)

    if(NOT old_scheme)
        set(uri_string "${scheme}:${uri_string}" )
    else()
        string(REPLACE "${old_scheme}:" "${scheme}:" uri_string "${uri_string}")
    endif()

    map_set(${uri} uri "${uri_string}")
    return_ref(uri)
  endfunction()

  function(uri_add_schemes uri)

    uri("${uri}")
    ans(uri)

    map_tryget(${uri} schemes)
    ans(schemes)

    set(schemes ${ARGN} ${schemes})
    list_remove_duplicates(schemes)

    uri_set_schemes(${uri} ${schemes})
    return_ans()

  endfunction()

# File: source/uri/uri_to_localpath.cmake

## formats an <uri~> to a localpath 
function(uri_to_localpath uri)
  uri("${uri}")
  ans(uri)

  map_tryget("${uri}" normalized_segments)
  ans(segments)

  map_tryget(${uri} leading_slash)
  ans(rooted)

  map_tryget(${uri} trailing_slash)
  ans(trailing_slash)

  map_tryget(${uri} windows_absolute_path)
  ans(windows_absolute_path)

  string_combine("/" ${segments})
  ans(path)

  if(CMAKE_HOST_WIN32 AND "${path}" MATCHES "^[a-zA-Z]:")
    # do nothing
  elseif(rooted AND NOT windows_absolute_path)
    set(path "/${path}")
  endif()
  set(path "${path}${trailing_slash}")
  return_ref(path)
endfunction()


# File: source/value.cmake


  function(value)
    set(value ${ARGN})

    if("${value}_" STREQUAL "_")
      creturn()
    endif()

    set(callable)
    set(is_callable false)


    is_lambda("${ARGV0}")
    ans(is_lambda)

    if(COMMAND "${ARGV0}")
      list(REMOVE_AT value 0)
      callable("${ARGV0}")
      ans(callable)
      set(is_callable true)
    elseif(is_lambda)
      list(REMOVE_AT value 0)
      callable("${ARGV0}")
      ans(callable)
      set(is_callable true)
    else()
      is_callable("${ARGV0}")
      ans(is_callable)
      if(is_callable)
        set(callable "${ARGV0}")
      endif()
    endif()
    if(is_callable)
      call2("${callable}" ${value})
      return_ans()
    endif()

    data(${value})
    return_ans()
  endfunction()


# File: source/vcs/git/git.cmake

## ''
## wraps the git executable into an easy to use function
function(git)
    find_package(Git)
    if (NOT GIT_FOUND)
        message(FATAL_ERROR "missing git")
    endif ()

    wrap_executable(git "${GIT_EXECUTABLE}")
    git(${ARGN})
    return_ans()
endfunction()  


# File: source/vcs/git/git_base_dir.cmake


## returns the git base dir (the directory in which .git is located)
function(git_base_dir)  
  git_dir("${ARGN}")
  ans(res)
  path_component("${res}" --parent-dir)
  ans(res)
  return_ref(res)
endfunction()

# File: source/vcs/git/git_cached_clone.cmake

  ## git_cached_clone(<remote uri:<~uri>> <?target_dir> [--readonly] ([--file <>]|[--read<>]) [--ref <git ref>])-> 
    function(git_cached_clone remote_uri)
      set(args ${ARGN})


      list_extract_flag(args --readonly)
      ans(readonly)
      
      list_extract_labelled_value(args --ref)
      ans(git_ref)

      list_extract_labelled_value(args --file)
      ans(file)

      list_extract_labelled_value(args --read)
      ans(read)

      list_pop_front(args)
      ans(target_dir)


      path_qualify(target_dir)

      cmakepp_config(temp_dir)
      ans(cache_dir)

      string(MD5 cache_key "${remote_uri}" )

      set(repo_cache_dir "${cache_dir}/git_cache/${cache_key}")

      if(NOT EXISTS "${repo_cache_dir}")
        git_lean(clone --mirror "${remote_uri}" "${repo_cache_dir}")
        ans_extract(error)
        if(error)
          rm("${repo_cache_dir}")
          message(FATAL_ERROR "git could not clone ${remote_uri}")
        endif()

      endif()
      set(result)
      pushd("${repo_cache_dir}")
        set(ref "${git_ref}")
        if(NOT ref)
          set(ref "HEAD")
        endif()
        if(read OR file)
          git_lean(fetch)
          ans_extract(error)
          if(error)
            message(FATAL_ERROR "failed to fetch")
          endif()

          git_lean(show "${ref}:${read}")
          ans_extract(error)
          ans(git_result)

          if(NOT error)
            set(result "${git_result}")
            if(file)
              set(target_path "${target_dir}/${file}")
              fwrite("${target_path}" "${git_result}")
              set(result "${target_path}")
            endif()
          endif()
        else()
          git_lean(clone --reference "${repo_cache_dir}" "${remote_uri}" "${target_dir}")
          ans_extract(error)
          if(error)
            message(FATAL_ERROR "failed to reference clone params:(clone --reference \"${repo_cache_dir}\" \"${remote_uri}\" \"${target_dir}\") ")
          endif()
          pushd("${target_dir}")
            git_lean(checkout "${git_ref}")
            ans_extract(error)
            if(error)
              message(FATAL_ERROR "failed to checkout ${git_ref}")
            endif()
            git_lean(submodule init)
            ans_extract(error)
            if(error)
              message(FATAL_ERROR "failed to init submodules for  ${git_ref}")
            endif()
            git_lean(submodule update)
            ans_extract(error)
            if(error)
              message(FATAL_ERROR "failed to update submodules for  ${git_ref}")
            endif()
          popd()   
          set(result "${target_dir}")
        endif()
       popd()

      return_ref(result)      

    endfunction()

# File: source/vcs/git/git_dir.cmake


# returns the git directory for pwd or specified path
function(git_dir)
  set(path ${ARGN})
  path("${path}")
  ans(path)
  message("${path}")

  pushd("${path}")
  git(rev-parse --show-toplevel)
  ans(res)
  message("${res}")
  
  popd()
  string(STRIP "${res}" res)
  set(res "${res}/.git")
  message("${res}")
  return_ref(res)
endfunction()


# File: source/vcs/git/git_lean.cmake

## `(<args...>)`[<exitcode>, <stdout>]
##
## a lean wrapper for git
## does not take part in the process management of cmakepp
function(git_lean)
  find_package(Git)
  if(NOT GIT_FOUND)
    message(FATAL_ERROR "missing git")
  endif()

  wrap_executable_bare(git_lean "${GIT_EXECUTABLE}")
  git_lean(${ARGN})
  return_ans()


endfunction()

# File: source/vcs/git/git_read_single_file.cmake

# reads a single file from a git repository@branch using the 
# repository relative path ${path}. returns the contents of the file
function(git_read_single_file repository branch path )
  mktemp()
  ans(tmp_dir)

  set(branch_arg)
  if(branch)
    set(branch_arg --branch "${branch}") 
  endif()

  git_lean(clone --no-checkout ${branch_arg} --depth 1 "${repository}" "${tmp_dir}")
  ans_extract(error)

  if(error)
    rm(-r "${tmp_dir}")
    popd()
    creturn()
  endif()

  if(NOT branch)
    set(branch HEAD)
  endif()


  pushd("${tmp_dir}")
  git_lean(show --format=raw "${branch}:${path}")
  ans_extract(error)
  ans(res)

  popd()


  popd()
  rm(-r "${tmp_dir}")

  
  if(error)
    creturn()
  endif()
  

  return_ref(res)
  
endfunction()

# File: source/vcs/git/git_ref_parse.cmake

# parses a git ref and retruns a map with the fields type and name
function(git_ref_parse  ref)
  set(res)
  if(${ref} STREQUAL HEAD)
    map_new()
    ans(res)
    map_set(${res} type HEAD)
    map_set(${res} name HEAD)
  endif()
  if("${ref}" MATCHES "^refs/([^/]*)/(.*)$")
    string(REGEX REPLACE "^refs/([^/]*)/(.*)$" "\\1;\\2" parts "${ref}")
    list_extract(parts type name)
    map_new()
    ans(res)
    map_set(${res} type ${type})
    map_set(${res} name ${name})
  endif()
  return_ref(res)
endfunction()

# File: source/vcs/git/git_register_hook.cmake

# registers a git hook
function(git_register_hook hook_name)
  git_directory()
  ans(git_dir)


endfunction()


function(git_local_hooks)
  set(hooks
    pre-commit
    post-commit
    prepare-commit-msg
    commit-msg
    pre-rebase
    post-checkout

    )
  return_ref(hooks)

endfunction()


# File: source/vcs/git/git_remote_exists.cmake


# checks wether the uri is a remote git repository
function(git_remote_exists uri)
  git_uri("${uri}")
  ans(uri)


  git_lean(ls-remote "${uri}")
  ans_extract(error)
  
  if(error)
    creturn(false)
  endif()
  creturn(true)
endfunction()

# File: source/vcs/git/git_remote_has_ref.cmake


# checks the remote uri if a ref exists ref_type can be * to match any
# else it can be tags heads or HEAD
function(git_remote_has_ref uri ref_name ref_type)
  git_remote_ref("${uri}" "${ref_name}" "${ref_type}")
  ans(res)
  if(res)
    creturn(true)
  else()
    creturn(false)
  endif()

endfunction()




# File: source/vcs/git/git_remote_ref.cmake


# checks the remote uri if a ref exists ref_type can be * to match any
# else it can be tags heads or HEAD
# returns the corresponding ref object
function(git_remote_ref uri ref_name ref_type)
  git_remote_refs( "${uri}")
  ans(refs)
  foreach(current_ref ${refs})
    map_navigate(name "current_ref.name")
    if("${name}" STREQUAL "${ref_name}")
      if(ref_type STREQUAL "*")
        creturn(${current_ref})
      else()
        map_navigate(type "current_ref.type")
        if(${type} STREQUAL "${ref_type}")
          creturn("${current_ref}")
        endif()
        creturn()
      endif()
    endif()
  endforeach()
  creturn()
endfunction()




# File: source/vcs/git/git_remote_refs.cmake

# returns a list of ref maps containing the fields 
# name type and revision
function(git_remote_refs uri)
  git_uri("${uri}")
  ans(uri)

  git_lean(ls-remote ${uri})
  ans_extract(error)
  ans(stdout)

  if(error)
    creturn()
  endif()

  string_split( "${stdout}" "\n")
  ans(lines)
  set(res)
  foreach(line ${lines})
    string(STRIP "${line}" line)

    # match
    if("${line}" MATCHES "^([0-9a-fA-F]*)\t(.*)$")
      string(REGEX REPLACE "^([0-9a-fA-F]*)\t(.*)$" "\\1;\\2" parts "${line}")
      list_extract(parts revision ref)
      git_ref_parse("${ref}")
      ans(ref_map)
      
      map_set("${ref_map}" uri "${uri}")
      if(ref_map)
        map_set(${ref_map} revision ${revision})
        set(res ${res} ${ref_map})
        #address_print(${ref_map})
      endif()
    endif()
  endforeach()   
  return_ref(res)
endfunction()

# File: source/vcs/git/git_repository_name.cmake

function(git_repository_name repository_uri)
  get_filename_component(repo_name "${repository_uri}" NAME_WE)
  creturn("${repo_name}")
endfunction()

# File: source/vcs/git/git_scm_descriptor.cmake


    function(git_scm_descriptor git_ref)

        set(scm_descriptor)
        assign(!scm_descriptor.scm = 'git')
        assign(!scm_descriptor.ref = git_ref)

        return_ref(scm_descriptor)
    endfunction()

# File: source/vcs/git/git_uri.cmake

## returns the git uri for the given ARGN
## if its empty emtpy is returned
## if it exists it is returned
## if it exists after qualification the qualifed path is returned
## else it is retunred
function(git_uri)

  set(uri ${ARGN})
  if(NOT uri)
    creturn()
  endif()
  if(EXISTS "${uri}")
    creturn("${uri}")
  endif()
  path("${uri}")
  ans(uri_path)
  if(EXISTS "${uri_path}")
    return_ref(uri_path)
  endif()
  return_ref(uri)
endfunction()




# File: source/vcs/scm_which.cmake


## `(<path=".">)->"git"|"svn"|"hg"|<null>`
##
## returns the scm found `"git"|"svn"|"hg"` in specified directory
function(scm_which)
    #message(FATAL_ERROR notimplemented)
    path("${ARGN}")
    ans(path)
    pushd("${path}")
    git(status --exit-code)
    ans(error)
    if (NOT error)
        popd()
        creturn(git)
    endif ()
    hg(status --exit-code)
    ans(error)
    if (NOT error)
        popd()
        creturn(hg)
    endif ()
    popd()
    creturn()
endfunction()

# File: source/vcs/svn/svn.cmake

# convenience function for accessing subversion
# use cd() to navigate to working directory
# usage is same as svn command line client
# syntax differs: svn arg1 arg2 ... -> svn(arg1 arg2 ...)
# also see wrap_executable for usage
# add a --process-handle flag to get a object containing return code, output
# input args etc.
# add --exit-code flag to get the return code of the commmand
# by default fails if return code is not 0 else returns  stdout/stderr
function(svn)
  find_package(Subversion)
  if(NOT SUBVERSION_FOUND)
    message(FATAL_ERROR "subversion is not installed")
  endif()
  # to prohibit non utf 8 decode errors
  set(ENV{LANG} C)
  set(ENV{LC_MESSAGES} C)
  
  wrap_executable(svn "${Subversion_SVN_EXECUTABLE}")
  
  svn(${ARGN})
  return_ans()
endfunction()

# File: source/vcs/svn/svn_cached_checkout.cmake

## svn_cached_checkout()
function(svn_cached_checkout uri)
  set(args ${ARGN})
  path_qualify(target_dir)

  list_extract_flag(args --refresh)
  ans(refresh)
  
  list_extract_flag(args --readonly)
  ans(readonly)


  list_extract_labelled_keyvalue(args --revision)
  ans(revision)
  list_extract_labelled_keyvalue(args --branch)
  ans(branch)
  list_extract_labelled_keyvalue(args --tag)
  ans(tag)

  list_pop_front(args)
  ans(target_dir)
  path_qualify(target_dir)

  
  svn_uri_analyze(${uri} ${revision} ${branch} ${tag})
  ans(svn_uri)

  map_import_properties(${svn_uri} base_uri ref_type ref revision relative_uri)

  if(NOT revision)
    set(revision HEAD)
  endif()


  if("${ref_type}" STREQUAL "branch")
    set(ref_type branches)
  elseif("${ref_type}" STREQUAL "tag")
    set(ref_type tags)
  endif()
  
  cmakepp_config(temp_dir)
  ans(cache_dir)

  string(MD5 cache_key "${base_uri}@${revision}@${ref_type}@${ref}")
  set(cached_path "${cache_dir}/svn_cache/${cache_key}")
  
  if(EXISTS "${cached_path}" AND NOT refresh)
    if(readonly)
      return_ref(cached_path)
    else()
      cp_dir("${cached_path}" "${target_dir}")
      return_ref(target_dir)
    endif()
  endif()

  set(checkout_uri "${base_uri}/${ref_type}/${ref}@${revision}")
  svn_remote_exists("${checkout_uri}")
  ans(remote_exists)
  
  if(NOT remote_exists)
    creturn()
  endif()


  if(EXISTS "${cached_path}")
    rm("${cached_path}")
  endif()
  mkdir("${cached_path}")


  svn(checkout "${checkout_uri}" "${cached_path}" --non-interactive  --exit-code)
  ans(error)

  if(error)
    rm("${cached_path}")
    creturn()
  endif()

  if(readonly)
    return_ref(cached_path)
  else()
    cp_dir("${cached_path}" "${target_dir}")
    return_ref(target_dir)
  endif()
endfunction()



# File: source/vcs/svn/svn_get_revision.cmake

## returns the revision for the specified svn uri
function(svn_get_revision)
  svn_info("${ARGN}")
  ans(res)
  nav(res.revision)
  return_ans()
endfunction()

# File: source/vcs/svn/svn_info.cmake

## returns an info object for the specified svn url
## {
##    path:"path",
##    revision:"revision",
##    kind:"kind",
##    url:"url",
##    root:"root",
##    uuid:"uuid",
## }
## todo: cached?
function(svn_info uri)
    svn_uri("${uri}")
    ans(uri)


    svn(info ${uri} --process-handle --xml ${ARGN})
    ans(res)
    map_tryget(${res} exit_code)
    ans(error)
    if(error)
      creturn()
    endif()

    map_tryget(${res} stdout)
    ans(xml)

    xml_parse_attrs("${xml}" entry path)    
    ans(path)
    xml_parse_attrs("${xml}" entry revision)    
    ans(revision)
    xml_parse_attrs("${xml}" entry kind)    
    ans(kind)
    xml_parse_values("${xml}" url)
    ans(url)
    xml_parse_values("${xml}" root)
    ans(root)
    xml_parse_values("${xml}" relative-url)
    ans(relative_url)

    string(REGEX REPLACE "^\\^/" "" relative_url "${relative_url}")

    xml_parse_values("${xml}" uuid)
    ans(uuid)
    map()
      var(path revision kind url root uuid relative_url)
    end()
    ans(res)
    return_ref(res)
endfunction()

# File: source/vcs/svn/svn_remote_exists.cmake

## returns true if a svn repository exists at the specified location
  function(svn_remote_exists uri)
    svn(ls "${uri}" --depth empty --non-interactive --exit-code)
    ans(error)
    if(error)
      creturn(false)
    endif()
    creturn(true)
  endfunction()

# File: source/vcs/svn/svn_uri.cmake

## returns the svn_uri for the given ARGN
## if its empty emtpy is returned
## if it exists it is returned
## if it exists after qualification the qualifed path is returned
## else it is retunred
function(svn_uri)

  set(uri ${ARGN})
  if(NOT uri)
    creturn()
  endif()
  if(EXISTS "${uri}")
    creturn("${uri}")
  endif()
  path("${uri}")
  ans(uri_path)
  if(EXISTS "${uri_path}")
    return_ref(uri_path)
  endif()
  return_ref(uri)
endfunction()




# File: source/vcs/svn/svn_uri_analyze.cmake

  ## svn_uri_analyze(<input:<?uri>> [--revision <rev>] [--branch <branch>] [--tag <tag>])-> 
  ## {
  ##   input: <string>
  ##   uri: <uri string>
  ##   base_uri: <uri string>
  ##   relative_uri: <path>
  ##   ref_type: "branch"|"tag"|"trunk"
  ##   ref: <string>
  ##   revision: <rev>
  ## }
  ##
  ## 
  function(svn_uri_analyze input)
    set(args ${ARGN})

    list_extract_labelled_value(args --revision)
    ans(args_revision)
    list_extract_labelled_value(args --branch)
    ans(args_branch)
    list_extract_labelled_value(args --tag)
    ans(args_tag)

    uri("${input}")
    ans(uri)


    assign(params_revision = uri.params.rev)
    assign(params_branch = uri.params.branch)
    assign(params_tag = uri.params.tag)

    set(trunk_dir trunk)
    set(tags_dir tags)
    set(branches_dir branches)

    uri_format(${uri} --no-query)
    ans(formatted_uri)

    set(uri_revision)
    if("${formatted_uri}" MATCHES "@(([1-9][0-9]*)|HEAD)(\\?|$)")
      set(uri_revision "${CMAKE_MATCH_1}")
      string(REGEX REPLACE "@${uri_revision}" "" formatted_uri "${formatted_uri}")
    endif()

    set(CMAKE_MATCH_3)
    set(uri_ref)
    set(base_uri "${formatted_uri}")
    set(uri_tag)
    set(uri_branch)
    set(uri_rel_path)
    set(uri_ref_type)
    set(ref_type)
    set(ref)
    if("${formatted_uri}" MATCHES "(.*)/(${trunk_dir}|${tags_dir}|${branches_dir})(/|$)")
      set(base_uri "${CMAKE_MATCH_1}")
      set(uri_ref_type "${CMAKE_MATCH_2}")

      set(uri_rel_path "${formatted_uri}")
      string_take(uri_rel_path "${base_uri}/${uri_ref_type}")
      string_take(uri_rel_path "/")

      if(uri_ref_type STREQUAL "${tags_dir}" OR uri_ref_type STREQUAL "${branches_dir}")
        string_take_regex(uri_rel_path "[^/]+")
        ans(uri_ref)
      endif()
      
      if(uri_ref_type STREQUAL "${branches_dir}")
        set(uri_branch ${uri_ref})
      endif()
      if(uri_ref_type STREQUAL "${tags_dir}")
        set(uri_tag "${uri_ref}")
      endif()      

    endif()



    set(revision ${args_revision} ${params_revision} ${uri_revision})
    list_peek_front(revision)
    ans(revision)



    if(uri_ref_type STREQUAL "trunk")
      set(ref_type trunk)
      set(ref trunk)
    endif()

    if(uri_ref_type STREQUAL "branches")
      set(ref_type branch)
      set(ref ${uri_ref})
    endif()

    if(uri_ref_type STREQUAL "tags")
      set(ref_type tag)
      set(ref ${uri_ref})
    endif()

    
    if(args_branch)
      set(ref_type branch)
      set(ref ${args_branch})
    endif()

    if(args_tag)
      set(ref_type tag)
      set(ref ${args_tag})
    endif()

    if("${ref_type}_" STREQUAL "_")
      set(ref_type trunk)
      set(ref)
    endif()


    map_new()
    ans(result)
    map_set(${result} input ${input})
    map_set(${result} uri ${formatted_uri} )
    map_set(${result} base_uri "${base_uri}")
    map_set(${result} relative_uri "${uri_rel_path}")
    map_set(${result} ref_type "${ref_type}")
    map_set(${result} ref "${ref}")
    map_set(${result} revision "${revision}")

    creturn(${result})
  endfunction()

# File: source/vcs/svn/svn_uri_format_package_uri.cmake


  function(svn_uri_format_package_uri svn_uri)
    map_import_properties(${svn_uri} base_uri revision ref ref_type)

    string(REGEX REPLACE "^svnscm\\+" "" base_uri "${base_uri}")

    if("${ref_type}" STREQUAL "branch")
      set(ref_type branches)
    elseif("${ref_type}" STREQUAL "tag")
      set(ref_type tags)
    endif()

    if(revision STREQUAL "HEAD")
      set(revision)
    endif() 


    set(params)
    if(NOT ref_type STREQUAL "trunk" OR revision)
      map_new()
      ans(params)
      if(NOT revision STREQUAL "")
        map_set(${params} rev "${revision}")
      endif()
      if(ref_type STREQUAL trunk)
      elseif("${ref_type}" STREQUAL "branch")
        map_set(${params} branch "${ref}")
      elseif("${ref_type}" STREQUAL "tag")
        map_set(${params} branch "${ref}")
      endif()
      uri_params_serialize(${params})
      ans(query)
      set(query "?${query}")
    endif()

    set(result "${base_uri}${query}")


    return_ref(result)


  endfunction()

# File: source/vcs/svn/svn_uri_format_ref.cmake


  function(svn_uri_format_ref svn_uri)
    map_import_properties(${svn_uri} base_uri revision ref ref_type)

    string(REGEX REPLACE "^svnscm\\+" "" base_uri "${base_uri}")
    if(NOT revision)
      set(revision HEAD)
    endif()

    if("${ref_type}" STREQUAL "branch")
      set(ref_type branches)
    elseif("${ref_type}" STREQUAL "tag")
      set(ref_type tags)
    endif()
    
    set(checkout_uri "${base_uri}/${ref_type}/${ref}@${revision}")
    return_ref(checkout_uri)

  endfunction()


# File: source/web/bitbucket/bitbucket_api.cmake

## bitbucket_api()
## 
## 
function(bitbucket_api)

  set(bitbucket_api_token)
 # if(NOT "$ENV{BITBUCKET_API_TOKEN}_" STREQUAL "_" )
 #   set(bitbucket_api_token "?client_id=$ENV{BITBUCKET_API_TOKEN}&client_secret=$ENV{GITHUB_DEVEL_TOKEN_SECRET}")
#  endif()
  set(api_uri "https://api.bitbucket.org/2.0")
  define_http_resource(bitbucket_api "${api_uri}/:path${bitbucket_api_token}")

  bitbucket_api(${ARGN})
  return_ans()
endfunction()

# File: source/web/bitbucket/bitbucket_default_branch.cmake



function(bitbucket_default_branch user repo)
  set(api_uri "https://bitbucket.org/api/1.0")
  set(query_uri "${api_uri}/repositories/${user}/${repo}/main-branch" )

  http_get("${query_uri}" --json --silent-fail)
  ans(response)

  if(NOT response)
    creturn()
  endif()

  map_tryget(${response} name)
  ans(res)
  return_ref(res)

endfunction()


# File: source/web/bitbucket/bitbucket_read_file.cmake


    function(bitbucket_read_file user repo ref path)
      set(raw_uri "https://bitbucket.org/${user}/${repo}/raw/${ref}/${path}")
      http_get("${raw_uri}" "" --silent-fail)
      return_ans()
    endfunction()

# File: source/web/bitbucket/bitbucket_remote_ref.cmake


  function(bitbucket_remote_ref user repo ref_type ref)
    set(api_uri "https://bitbucket.org/api/1.0")
    http_get("${api_uri}/repositories/${user}/${repo}/changesets/${ref}" --silent-fail --json)
    ans(bitbucket_response)
    if(NOT bitbucket_response)
      creturn()
    endif()
    map_tryget(${bitbucket_response} raw_node)
    ans(commit)
    map_capture_new(user repo ref_type ref commit bitbucket_response)
    return_ans()
  endfunction()

# File: source/web/bitbucket/bitbucket_remote_refs.cmake


function(bitbucket_remote_refs user repo ref_type_query ref_name_query )
  set(api_uri "https://bitbucket.org/api/1.0")
  http_get("${api_uri}/repositories/${user}/${repo}/branches-tags" --silent-fail --json)
  ans(refs)
  if(NOT refs)
    creturn()
  endif()
  set(branches)
  set(tags)
  
  if("${ref_type_query}_" STREQUAL "*_" OR "${ref_type_query}_" STREQUAL "branches_")
    map_tryget(${refs} branches)
    ans(branches)
  endif()
  if("${ref_type_query}_" STREQUAL "*_" OR "${ref_type_query}_" STREQUAL "tags_")
    map_tryget(${refs} tags)
    ans(tags)
  endif()

  set(refs)

  foreach(branch ${branches})
    map_tryget(${branch} name)
    ans(ref)
    map_tryget(${branch} changeset)
    ans(commit)
    set(ref_type "branches")

    if("${ref_name_query}_" STREQUAL "*_" OR "${ref_name_query}_" STREQUAL "${ref}_")
      set(bitbucket_response ${branch})
      map_capture_new(user repo ref_type ref commit bitbucket_response)
      ans_append(refs)
    endif()
  endforeach()
  
  foreach(tag ${tags})
    map_tryget(${tag} name)
    ans(ref)
    map_tryget(${tag} changeset)
    ans(commit)
    set(ref_type "tags")  


    if("${ref_name_query}_" STREQUAL "*_" OR "${ref_name_query}_" STREQUAL "${ref}_")
      set(bitbucket_response ${tag})
      map_capture_new(user repo ref_type ref commit bitbucket_response)
      ans_append(refs)
    endif()

  endforeach()

  return_ref(refs)
endfunction()

# File: source/web/bitbucket/bitbucket_repositories.cmake



function(bitbucket_repositories user)
    set(result)

    set(api_uri "https://api.bitbucket.org/2.0")
    set(current_uri "${api_uri}/repositories/${user}")
    set(names)
    while (true)
        http_get("${current_uri}" --response)
        ans(response)
        assign(error = response.client_status)
        assign(current_result = response.content)
        if (error)
            error("failed to query ${current_uri} http client said: {response.client_message} ({response.client_status})}")
            creturn()
        endif ()
        json_extract_string_value(next "${current_result}")
        ans(current_uri)
        json_extract_string_value(name "${current_result}")
        ans_append(names)

        if (NOT current_uri)
            break()
        endif ()
    endwhile ()

    list_remove_duplicates(names)

    ## hack because of the way that json_extract_string_value works I have to remove other names
    # Doesn't work properly, but who uses bitbucket in 2020...
    list_remove(names ssh https master)

    return_ref(names)
endfunction()

# File: source/web/check_host.cmake

macro(check_host url)
 
  # expect webservice to be reachable
  http_get("${url}" --exit-code)
  ans(error)

  if(error)
    message("Test inconclusive webserver unavailable")
    creturn()
  endif()

endmacro()

# File: source/web/define_http_resource.cmake


  function(define_http_resource function uri_string)
    uri("${uri_string}")
    ans(uri)

    map_tryget("${uri}" scheme_specific_part)
    ans(scheme_specific_part)
    map_tryget("${uri}" scheme)
    ans(scheme)

    string(REGEX MATCHALL ":([a-zA-Z][a-zA-Z0-9_]*)" replaces "${scheme_specific_part}")

    list_remove_duplicates(replaces)

    set(function_args "")

    foreach(replace ${replaces})
      string(REGEX REPLACE ":([a-zA-Z][a-zA-Z0-9_]*)" "\\1" name "${replace}")
      string(REPLACE "${replace}" "\${${name}}" uri_string "${uri_string}")
      set(function_args "${function_args} ${name}")
    endforeach()    

    set(code "
      function(${function}${function_args})
        set(args \${ARGN})
        list_extract_flag(args --put)
        ans(put)
        set(resource_uri \"${uri_string}\")

        if(put)
          http_put(\"\${resource_uri}\" \${args})
        else()
          http_get(\"\${resource_uri}\" \${args})
        endif()
        return_ans()
      endfunction()
    ")
    eval("${code}")
    creturn()

  endfunction()

# File: source/web/download.cmake

## download(uri [target] [--progress])
## downloads the specified uri to specified target path
## if target path is an existing directory the files original filename is kept
## else target is treated as a file path and download stores the file there
## if --progress is specified then the download progress is shown
## returns the path of the successfully downloaded file or null
function(download uri)
  set(args ${ARGN})

  set(uri_string "${uri}")
  uri("${uri}")
  ans(uri)


  list_extract_flag(args --progress)
  ans(show_progress)
  if(show_progress)
    set(show_progress SHOW_PROGRESS)
  else()
    set(show_progress)
  endif()

  list_pop_front(args)
  ans(target_path)
  path_qualify(target_path)

  map_tryget("${uri}" file)
  ans(filename)

  if(IS_DIRECTORY "${target_path}")
    set(target_path "${target_path}/${filename}")    
  endif()
  
  file(DOWNLOAD 
    "${uri_string}" "${target_path}" 
    STATUS status 
   # LOG log
    ${show_progress}
    TLS_VERIFY OFF 
    ${args})


  list_extract(status code message)
  if(NOT "${code}" STREQUAL 0)    
    error("failed to download: {message} (code {code})")
    rm("${target_path}")
    creturn()
  endif()

  return_ref(target_path)
endfunction()

# File: source/web/download_cached.cmake


  ## downloadsa the specified url and stores it in target file
  ## if specified
  ## --refresh causes the cache to be updated
  ## --readonly allows optimization if the result is not modified
  function(download_cached uri)
    set(args ${ARGN})
    list_extract_flag(args --refresh)
    ans(refresh)
    list_extract_flag(args --readonly)
    ans(readonly)
    
    cmakepp_config(temp_dir)
    ans(cache_dir)

    string(MD5 cache_key "${uri}")
    set(cached_path "${cache_dir}/download_cache/${cache_key}")
   
    if(EXISTS "${cached_path}" AND NOT refresh)
      if(readonly)
        glob("${cached_path}/**")
        ans(file_path)
        if(EXISTS "${file_path}")
          return_ref(file_path)
        endif()
        rm("${cached_path}")
      else()
        message(FATAL_ERROR "not supported")
      endif()
    endif()

    mkdir("${cached_path}")
    download("${uri}" "${cached_path}" ${args})
    ans(res)
    if(NOT res)
      rm("${cached_path}")
    endif()
    return_ref(res)
  endfunction()


# File: source/web/github/git_repository.cmake



# File: source/web/github/github_api.cmake

## github_api()
## 
## 
function(github_api)
    set(github_api_token)
    if (NOT "$ENV{GITHUB_DEVEL_TOKEN_ID}_" STREQUAL "_")
        set(github_api_token "?client_id=$ENV{GITHUB_DEVEL_TOKEN_ID}&client_secret=$ENV{GITHUB_DEVEL_TOKEN_SECRET}")
    endif ()
    set(api_uri "https://api.github.com")
    define_http_resource(github_api "${api_uri}/:path${github_api_token}")

    github_api(${ARGN})
    return_ans()
endfunction()

# File: source/web/github/github_get_file.cmake

function(github_get_file user repo ref path)
    set(raw_uri "https://raw.githubusercontent.com/")
    set(path_uri "${raw_uri}/${user}/${repo}/${ref}/${path}")
    http_get("${path_uri}" ${ARGN})
    return_ans()
endfunction()

# File: source/web/github/github_get_latest_release_tag.cmake

## github_get_latest_release_tag() -> name of the tag
##
## returns the list of repositories for the specified user
function(github_get_latest_release_tag user repo)
    github_api("repos/${user}/${repo}/releases/latest" --response)
    ans(res)
    assign(error = res.client_status)
    if (error)
        creturn()
    endif ()
    assign(content = res.content)

    ## this is a quick way to get all full_name fields of the unparsed json
    ## parsing large json files would be much too slow
    json_extract_string_value(tag_name "${content}")
    return_ans()
endfunction()

# File: source/web/github/github_remote_refs.cmake

## github_remote_refs( <?ref type query>)-> {
##   ref_type: "branches"|"tags"|"commits"
##   ref: <name>
##   commit: <sha>
## }
##
## ref type query ::= "branches"|"tags"|"commits"|"*"
## returns the remote refs for the specified github repository
function(github_remote_refs user repo ref_query)
    set(args ${ARGN})
    list_pop_front(args)
    ans(ref_name_query)

    set(tags)
    set(branches)
    set(commits)
    set(refs)

    if (ref_query AND "${ref_query}" STREQUAL "commits" AND ref_name_query)
        github_api("repos/${user}/${repo}/commits/${ref_name_query}" --exit-code)
        ans(error)
        if (NOT error)
            set(ref ${ref_name_query})
            set(commit ${ref_name_query})
            set(ref_type "commits")
            map_capture_new(ref_type ref commit)
            ans_append(refs)
        endif ()
    endif ()

    if (ref_query AND "${ref_query}" STREQUAL "*" OR "${ref_query}" STREQUAL "tags")
        github_api("repos/${user}/${repo}/tags" --json --silent-fail)
        ans(tags)
        foreach (tag ${tags})
            assign(ref = tag.name)
            assign(commit = tag.commit.sha)
            set(ref_type "tags")
            map_capture_new(ref_type ref commit)
            ans_append(refs)
        endforeach ()
    endif ()
    if (ref_query AND "${ref_query}" STREQUAL "*" OR "${ref_query}" STREQUAL "branches")
        github_api("repos/${user}/${repo}/branches" --json --silent-fail)
        ans(branches)

        foreach (branch ${branches})
            assign(ref = branch.name)
            assign(commit = branch.commit.sha)
            set(ref_type "branches")
            map_capture_new(ref_type ref commit)
            ans_append(refs)
        endforeach ()

    endif ()

    if (ref_name_query AND NOT "${ref_name_query}" STREQUAL "*")
        set(result)
        foreach (ref ${refs})
            map_tryget(${ref} ref)
            ans(ref_name)
            map_tryget(${ref} commit)
            ans(commit)
            if ("${ref_name_query}" STREQUAL "${ref_name}" OR "${ref_name_query}" STREQUAL "${commit}")
                list(APPEND result ${ref})
            endif ()
        endforeach ()
        set(refs ${result})
    endif ()
    return_ref(refs)
endfunction()

# File: source/web/github/github_repository_list.cmake

## github_repositories() -> {
##   full_name:
##   default_branch:
## }
##
## returns the list of repositories for the specified user
function(github_repository_list user)
    set(repositories)
    github_api("users/${user}/repos?per_page=100" --response)
    ans(res)
    assign(error = res.client_status)
    if (error)
        creturn()
    endif ()
    assign(content = res.content)


    ## this is a quick way to get all full_name fields of the unparsed json
    ## parsing large json files would be much too slow
    json_extract_string_value(full_name "${content}")
    ans(full_names)
    json_extract_string_value(default_branch "${content}")
    ans(default_branches)

    set(repos)
    foreach (full_name ${full_names})
        list_pop_front(default_branches)
        ans(default_branch)
        map_capture_new(full_name default_branch)
        ans_append(repos)
    endforeach ()
    return_ref(repos)
endfunction()

# File: source/web/http_get.cmake

## http_get(<~uri> <?content:<structured data>> [--progress] [--response] [--exit-code] )-> <http response>
##
##
## flags: 
##   --json         flag deserializes the content and returns it 
##   --show-progress     flag prints the progress of the download to the console
##   --response     flag
##   --exit-code  flag
##   --silent-fail  flag
##  
function(http_get uri)
    set(args ${ARGN})
    list_extract_flag(args --json)
    ans(return_json)
    list_extract_flag(args --show-progress)
    ans(show_progress)
    list_extract_flag(args --response)
    ans(return_response)
    list_extract_flag(args --exit-code)
    ans(return_error)
    list_extract_flag(args --silent-fail)
    ans(silent_fail)


    if (show_progress)
        set(show_progress SHOW_PROGRESS)
    else()
        set(show_progress "")
    endif ()

    path_temp()
    ans(target_path)

    list_pop_front(args)
    ans(content)

    obj("${content}")
    ans(content)

    uri("${uri}")
    ans(uri)

    uri_format("${uri}" "${content}")
    ans(uri)

    if (return_response)
        set(log LOG http_log)
    endif ()

    event_emit(on_http_get "${uri}")
    ans(modified_uri)

    if (modified_uri)
        set(uri "${modified_uri}")
    endif ()

    ## actual request - uses file DOWNLOAD which
    ## uses cUrl internally
    file(DOWNLOAD
            "${uri}"
            "${target_path}"
            STATUS status
            ${log}
            ${show_progress}
            TLS_VERIFY OFF
            ${args}
            )

    # split status into client_status and client_message
    list_extract(status client_status client_message)

    ## return only error code if requested
    if (return_error)
        return_ref(client_status)
    endif ()

    ## read content if client was executed correctly
    ## afterwards delete file
    if (NOT client_status)
        fread("${target_path}")
        ans(content)
    else ()
        error("http_get failed for '{uri}': ${client_message}")
        if (NOT silent_fail AND NOT return_response)
            rm("${target_path}")
            if ("$ENV{TRAVIS}")
                ## do not show the query if travis build because it could contain sensitive
                ## data
                uri_format("${uri}" --no-query)
                ans(uri)
            endif ()
            message(FATAL_ERROR "http_get failed for '${uri}': ${client_message}")
        elseif (silent_fail AND NOT return_response)
            rm("${target_path}")
            creturn()
        endif ()
    endif ()
    rm("${target_path}")

    ## if the response is not to be returnd
    ## check if deserialization is wished and
    ## and return content
    if (NOT return_response)
        if (return_json)
            json_deserialize("${content}")
            ans(content)
        endif ()
        return_ref(content)
    endif ()

    ## parse response and set further fields
    http_last_response_parse("${http_log}")
    ans(response)

    map_set(${response} content "${content}")
    map_set(${response} client_status "${client_status}")
    map_set(${response} client_message "${client_message}")
    map_set(${response} request_url "${uri}")

    string(LENGTH "${content}" content_length)
    map_set(${response} content_length "${content_length}")
    map_set(${response} http_log "${http_log}")

    return_ref(response)
endfunction()

# File: source/web/http_headers_parse.cmake



function(http_headers_parse http_headers)
  http_regexes()
  string_encode_semicolon("${http_headers}")
  ans(http_headers)

  string(REGEX MATCHALL "${http_header_regex}" http_header_lines "${http_headers}")

  map_new()
  ans(result)
  foreach(header_line ${http_header_lines})
    string(REGEX REPLACE "${http_header_regex}" "\\1" header_key "${header_line}")
    string(REGEX REPLACE "${http_header_regex}" "\\2" header_value "${header_line}")
    string_decode_semicolon("${header_value}")
    ans(header_value)
    map_set(${result} "${header_key}" "${header_value}")
  endforeach()

  return_ref(result)
endfunction()


# File: source/web/http_last_response_parse.cmake


## returns a response object for the last response in the specified http_log
## http_log is returned by cmake's file(DOWNLOAD|PUT LOG) function
## layout
## {
##   http_version:
##   http_status_code:
##   http_reason_phrase:
##   http_headers:{}
##   http_request:{
##      http_version:	
##      http_request_url:	
##      http_method:
##      http_headers:{}	
##   }
## }
function(http_last_response_parse http_log)
	string_encode_semicolon("${http_log}")
	ans(http_log)
	http_regexes()
	
	string(REGEX MATCHALL "(${http_request_header_regex})" requests "${http_log}")
	string(REGEX MATCHALL "(${http_response_header_regex})" responses "${http_log}")

	list_pop_back(requests)
	ans(request)
	http_request_header_parse("${request}")
	ans(request)

	list_pop_back(responses)
	ans(response)

	http_response_header_parse("${response}")
	ans(response)
	map_set(${response} http_request "${request}")
	return_ref(response)
endfunction()

# File: source/web/http_put.cmake

## http_put() -> 
##
## flags:
##   --response     						flag will return the http response object
##
##   --json											flag will deserialize the result data
##
##   --exit-code    						flag will return the http clients return code 
##															non-zero indicates an error
##   --show-progress 						flag causes a console message which indicates 
##															the progress of the operation
##
##   --raw           					 	flag witll cause input to be sent raw 
##															if flag is not specified the input is serialized
##															to json before sending
##
##   --file <file>							flag PUT the specified file instead of the input
##
##   --silent-fail						 	flag causes function to return nothing if it fails
##															(only usable if --response was not set)
##
##   --timeout <n>						 	value 
##
##   --inactivity-timeout <n>  	value 
## 
## events:
##   on_http_put(<uri> <content>)-> <uri?>:
##     event is called before put request is performed
##     user may cancel event and return a modified uri 
##     which is used to perform the request 
function(http_put uri)
    set(args ${ARGN})

    list_extract_flag(args --response)
    ans(return_response)

    list_extract_labelled_value(args --timeout)
    ans(timeout)

    list_extract_labelled_value(args --inactivity-timeout)
    ans(inactivity_timeout)

    list_extract_flag(args --show-progress)
    ans(show_progress)

    list_extract_flag(args --exit-code)
    ans(return_return_code)

    list_extract_flag(args --json)
    ans(return_json)

    list_extract_flag(args --raw)
    ans(put_raw)

    list_extract_labelled_value(args --file)
    ans(put_file)

    list_extract_flag(args --silent-fail)
    ans(silent_fail)

    path_temp()
    ans(temp_file)

    if (put_file)
        path_qualify(put_file)
        set(content_file "${put_file}")
        if (NOT EXISTS "${content_file}")
            error("http_put - file does not exists ${content_file}")
            message(FATAL_ERROR "http_put - file does not exists ${content_file}")
        endif ()
    else ()
        if (NOT put_raw)
            data("${args}")
            ans(content)
            json_write("${temp_file}" ${content})
            set(content_file "${temp_file}")
        else ()
            fwrite("${temp_file}" "${args}")
            set(content_file "${temp_file}")
        endif ()

    endif ()

    ## emit on_http_put event
    ##
    event_emit(on_http_put ${uri} ${content})
    ans(modified_uri)
    if (modified_uri)
        set(uri "${modified_uri}")
    endif ()

    ## delegate cmake flags in correct format to file command
    if (show_progress)
        set(show_progress SHOW_PROGRESS)
    else ()
        set(show_progress "")
    endif ()
    if (NOT "${timeout}_" STREQUAL "_")
        set(timeout TIMEOUT "${timeout}")
    endif ()
    if (NOT "${inactivity_timeout}_" STREQUAL "_")
        set(inactivity_timeout INACTIVITY_TIMEOUT "${inactivity_timeout}")
    endif ()

    ## upload a file (this actually does a http put request)
    file(UPLOAD
            "${content_file}"
            "${uri}"
            STATUS client_result
            LOG http_log
            ${show_progress}
            ${timeout}
            ${inactivity_timeout}
            )
    ## parse http client status
    list_extract(client_result client_status client_message)
    if (EXISTS "${temp_file}")
        rm("${temp_file}")
    endif ()

    if (return_return_code)
        return_ref(client_status)
    endif ()

    ## parse response from log since it is not downloaded
    set(response_content)
    if ("${http_log}" MATCHES "Response:\n(.*)\n\nDebug:\n")
        set(response_content "${CMAKE_MATCH_1}")
    endif ()

    if (NOT return_response AND client_status)
        error("http_put failed: ${client_message} - ${client_status}")
        if (NOT silent_fail)
            message(FATAL_ERROR "http_put failed: ${client_message} - ${client_status}")
        endif ()
        creturn()
    endif ()

    if (return_json)
        json_deserialize("${response_content}")
        ans(response_content)
    endif ()

    if (NOT return_response)
        return_ref(response_content)
    endif ()

    ## parse rest of response
    http_last_response_parse("${http_log}")
    ans(response)

    map_set(${response} content "${response_content}")
    map_set(${response} client_status "${client_status}")
    map_set(${response} client_message "${client_message}")

    return_ref(response)
endfunction()

# File: source/web/http_request_header_parse.cmake




function(http_request_header_parse http_request)
  http_regexes()

  string_encode_semicolon("${http_request}")
  ans(http_request)

  string(REGEX REPLACE "${http_request_header_regex}" "\\1" http_request_line "${http_request}")
  string(REGEX REPLACE "${http_request_header_regex}" "\\5" http_request_headers "${http_request}")

  string(REGEX REPLACE "${http_request_line_regex}" "\\1" http_method "${http_request_line}")
  string(REGEX REPLACE "${http_request_line_regex}" "\\2" http_request_uri "${http_request_line}")
  string(REGEX REPLACE "${http_request_line_regex}" "\\3" http_version "${http_request_line}")


  
  http_headers_parse("${http_request_headers}")
  ans(http_headers)

  map_new()
  ans(result)

  map_set(${result} http_method "${http_method}")
  map_set(${result} http_request_uri "${http_request_uri}")
  map_set(${result} http_version "${http_version}")
  map_set(${result} http_headers ${http_headers})

  return_ref(result)
endfunction()

# File: source/web/http_response_header_parse.cmake



function(http_response_header_parse http_response)
  http_regexes()
  string_encode_semicolon("${http_response}")
  ans(http_response)

  string(REGEX REPLACE "${http_response_header_regex}" "\\1" response_line "${response}")
  string(REGEX REPLACE "${http_response_header_regex}" "\\5" response_headers "${response}")

  string(REGEX REPLACE "${http_response_line_regex}" "\\1" http_version "${response_line}" )
  string(REGEX REPLACE "${http_response_line_regex}" "\\2" http_status_code "${response_line}" )
  string(REGEX REPLACE "${http_response_line_regex}" "\\3" http_reason_phrase "${response_line}" )



  http_headers_parse("${response_headers}")
  ans(http_headers)


  map_new()
  ans(result)
  map_set(${result} "http_version" "${http_version}")
  map_set(${result} "http_status_code" "${http_status_code}")
  map_set(${result} "http_reason_phrase" "${http_reason_phrase}")
  map_set(${result} "http_headers" "${http_headers}")
  return_ref(result)

endfunction()
## include task_enqueue last



## this file should not have the extension .cmake 
## because it needs to be included manually and last
## adds a callable as a task which is to be invoked later
function(task_enqueue callable)

  ## semicolon encode before string_encode_semicolon exists
  string(ASCII  31 us)
  string(REPLACE ";" "${us}" callable "${callable}")
  set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
  
  if(cmakepp_is_loaded)
    function(task_enqueue callable)
      task_new("${callable}")
      ans(task)
      task_queue_global()
      ans(task_queue)
      task_queue_push("${task_queue}" "${task}")
      return_ref(task)
    endfunction()
    address_get(__initial_invoke_later_list)
    ans(tasks)
    foreach(task ${tasks})
      string_decode_semicolon("${task}")
      ans(task)
      task_enqueue("${task}")
    endforeach()
  endif()
endfunction()

# initial version of task_enqueue which is used before cmakepp is loaded
# ## create invoke later functions 
# function(task_enqueue callable)
#   ## semicolon encode before string_encode_semicolon exists
#   string(ASCII  31 us)
#   string(REPLACE ";" "${us}" callable "${callable}")
#   set_property(GLOBAL APPEND PROPERTY __initial_invoke_later_list "${callable}") 
#   creturn()
# endfunction()


## setup global variables to contain command_line_args
parse_command_line(command_line_args "${command_line_args}") # parses quoted command line args
map_set(global "command_line_args" ${command_line_args})
map_set(global "unused_command_line_args" ${command_line_args})
## todo... change this 
# setup cmakepp config
map()
kv(base_dir
        LABELS --cmakepp-base-dir
        MIN 1 MAX 1
        DISPLAY_NAME "cmakepp installation dir"
        DEFAULT "${CMAKE_CURRENT_LIST_DIR}"
        )
kv(keep_temp
        LABELS --keep-tmp --keep-temp -kt
        MIN 0 MAX 0
        DESCRIPTION "does not delete temporary files after")
kv(temp_dir
        LABELS --temp-dir
        MIN 1 MAX 1
        DESCRIPTION "the directory used for temporary files"
        DEFAULT "${cmakepp_tmp_dir}/cmakepp"
        )
kv(cache_dir
        LABELS --cache-dir
        MIN 1 MAX 1
        DESCRIPTION "the directory used for caching data"
        DEFAULT "${cmakepp_cache_dir}/cmakepp"
        )
kv(bin_dir
        LABELS --bin-dir
        MIN 1 MAX 1
        DEFAULT "${CMAKE_CURRENT_LIST_DIR}/bin"
        )
kv(cmakepp_path
        LABELS --cmakepp-path
        MIN 1 MAX 1
        DEFAULT "${CMAKE_CURRENT_LIST_FILE}"
        )
end()
ans(cmakepp_config_definition)
cd("${CMAKE_SOURCE_DIR}")
# setup config_function for cmakepp
config_setup("cmakepp_config" ${cmakepp_config_definition})
#_message(FATAL_ERROR "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
## run all currently enqueued tasks
set(cmakepp_is_loaded true)
task_enqueue("[]()") ## dummy
tqr()
## register all function defs
parameter_definition("")
## check if in script mode and script file is equal to this file
## then invoke either cli mode
cmake_entry_point()
ans(entry_point)
if ("${CMAKE_CURRENT_LIST_FILE}" STREQUAL "${entry_point}")
    cmakepp_cli()
endif ()
## variables expected by cmake's find_package method
set(CMAKEPP_FOUND true)
set(CMAKEPP_VERSION_MAJOR "2022")
set(CMAKEPP_VERSION_MINOR "09")
set(CMAKEPP_VERSION_PATCH "0")
set(CMAKEPP_VERSION "${CMAKEPP_VERSION_MAJOR}.${CMAKEPP_VERSION_MINOR}.${CMAKEPP_VERSION_PATCH}")
set(CMAKEPP_BASE_DIR "${cmakepp_base_dir}")
set(CMAKEPP_BIN_DIR "${cmakepp_base_dir}/bin")
set(CMAKEPP_TMP_DIR "${cmakepp_tmp_dir}")
set(cmakepp_path "${CMAKE_CURRENT_LIST_FILE}")
set(CMAKEPP_PATH "${CMAKE_CURRENT_LIST_FILE}")
## setup file
set(ENV{CMAKEPP_PATH} "${CMAKE_CURRENT_LIST_FILE}")
